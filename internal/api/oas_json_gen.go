// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AddKnowledgeBaseResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddKnowledgeBaseResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfAddKnowledgeBaseResponseModel = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes AddKnowledgeBaseResponseModel from json.
func (s *AddKnowledgeBaseResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddKnowledgeBaseResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddKnowledgeBaseResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddKnowledgeBaseResponseModel) {
					name = jsonFieldsNameOfAddKnowledgeBaseResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddKnowledgeBaseResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddKnowledgeBaseResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddProjectResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddProjectResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("project")
		s.Project.Encode(e)
	}
}

var jsonFieldsNameOfAddProjectResponseModel = [1]string{
	0: "project",
}

// Decode decodes AddProjectResponseModel from json.
func (s *AddProjectResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddProjectResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Project.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddProjectResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddProjectResponseModel) {
					name = jsonFieldsNameOfAddProjectResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddProjectResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddProjectResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddPronunciationDictionaryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddPronunciationDictionaryResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_by")
		e.Str(s.CreatedBy)
	}
	{
		e.FieldStart("creation_time_unix")
		e.Int(s.CreationTimeUnix)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("permission_on_resource")
		s.PermissionOnResource.Encode(e)
	}
	{
		e.FieldStart("version_id")
		e.Str(s.VersionID)
	}
	{
		e.FieldStart("version_rules_num")
		e.Int(s.VersionRulesNum)
	}
}

var jsonFieldsNameOfAddPronunciationDictionaryResponseModel = [8]string{
	0: "created_by",
	1: "creation_time_unix",
	2: "description",
	3: "id",
	4: "name",
	5: "permission_on_resource",
	6: "version_id",
	7: "version_rules_num",
}

// Decode decodes AddPronunciationDictionaryResponseModel from json.
func (s *AddPronunciationDictionaryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddPronunciationDictionaryResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_by":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "creation_time_unix":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreationTimeUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creation_time_unix\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permission_on_resource":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.PermissionOnResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission_on_resource\"")
			}
		case "version_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.VersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		case "version_rules_num":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.VersionRulesNum = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_rules_num\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddPronunciationDictionaryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddPronunciationDictionaryResponseModel) {
					name = jsonFieldsNameOfAddPronunciationDictionaryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddPronunciationDictionaryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddPronunciationDictionaryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddPronunciationDictionaryResponseModelPermissionOnResource as json.
func (s AddPronunciationDictionaryResponseModelPermissionOnResource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddPronunciationDictionaryResponseModelPermissionOnResource from json.
func (s *AddPronunciationDictionaryResponseModelPermissionOnResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddPronunciationDictionaryResponseModelPermissionOnResource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddPronunciationDictionaryResponseModelPermissionOnResource(v) {
	case AddPronunciationDictionaryResponseModelPermissionOnResourceAdmin:
		*s = AddPronunciationDictionaryResponseModelPermissionOnResourceAdmin
	case AddPronunciationDictionaryResponseModelPermissionOnResourceEditor:
		*s = AddPronunciationDictionaryResponseModelPermissionOnResourceEditor
	case AddPronunciationDictionaryResponseModelPermissionOnResourceCommenter:
		*s = AddPronunciationDictionaryResponseModelPermissionOnResourceCommenter
	case AddPronunciationDictionaryResponseModelPermissionOnResourceViewer:
		*s = AddPronunciationDictionaryResponseModelPermissionOnResourceViewer
	default:
		*s = AddPronunciationDictionaryResponseModelPermissionOnResource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddPronunciationDictionaryResponseModelPermissionOnResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddPronunciationDictionaryResponseModelPermissionOnResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddPvcVoiceSamplesOKApplicationJSON as json.
func (s AddPvcVoiceSamplesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []SampleResponseModel(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AddPvcVoiceSamplesOKApplicationJSON from json.
func (s *AddPvcVoiceSamplesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddPvcVoiceSamplesOKApplicationJSON to nil")
	}
	var unwrapped []SampleResponseModel
	if err := func() error {
		unwrapped = make([]SampleResponseModel, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem SampleResponseModel
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddPvcVoiceSamplesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddPvcVoiceSamplesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddPvcVoiceSamplesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddVoiceIVCResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddVoiceIVCResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requires_verification")
		e.Bool(s.RequiresVerification)
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfAddVoiceIVCResponseModel = [2]string{
	0: "requires_verification",
	1: "voice_id",
}

// Decode decodes AddVoiceIVCResponseModel from json.
func (s *AddVoiceIVCResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVoiceIVCResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requires_verification":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.RequiresVerification = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_verification\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddVoiceIVCResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddVoiceIVCResponseModel) {
					name = jsonFieldsNameOfAddVoiceIVCResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVoiceIVCResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVoiceIVCResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddVoiceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddVoiceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfAddVoiceResponseModel = [1]string{
	0: "voice_id",
}

// Decode decodes AddVoiceResponseModel from json.
func (s *AddVoiceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddVoiceResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "voice_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddVoiceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddVoiceResponseModel) {
					name = jsonFieldsNameOfAddVoiceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddVoiceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddVoiceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddWorkspaceGroupMemberResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddWorkspaceGroupMemberResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfAddWorkspaceGroupMemberResponseModel = [1]string{
	0: "status",
}

// Decode decodes AddWorkspaceGroupMemberResponseModel from json.
func (s *AddWorkspaceGroupMemberResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddWorkspaceGroupMemberResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddWorkspaceGroupMemberResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddWorkspaceGroupMemberResponseModel) {
					name = jsonFieldsNameOfAddWorkspaceGroupMemberResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddWorkspaceGroupMemberResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddWorkspaceGroupMemberResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddWorkspaceInviteResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddWorkspaceInviteResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfAddWorkspaceInviteResponseModel = [1]string{
	0: "status",
}

// Decode decodes AddWorkspaceInviteResponseModel from json.
func (s *AddWorkspaceInviteResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddWorkspaceInviteResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddWorkspaceInviteResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddWorkspaceInviteResponseModel) {
					name = jsonFieldsNameOfAddWorkspaceInviteResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddWorkspaceInviteResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddWorkspaceInviteResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdditionalFormatResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdditionalFormatResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("content_type")
		e.Str(s.ContentType)
	}
	{
		e.FieldStart("file_extension")
		e.Str(s.FileExtension)
	}
	{
		e.FieldStart("is_base64_encoded")
		e.Bool(s.IsBase64Encoded)
	}
	{
		e.FieldStart("requested_format")
		e.Str(s.RequestedFormat)
	}
}

var jsonFieldsNameOfAdditionalFormatResponseModel = [5]string{
	0: "content",
	1: "content_type",
	2: "file_extension",
	3: "is_base64_encoded",
	4: "requested_format",
}

// Decode decodes AdditionalFormatResponseModel from json.
func (s *AdditionalFormatResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdditionalFormatResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "content_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "file_extension":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.FileExtension = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_extension\"")
			}
		case "is_base64_encoded":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsBase64Encoded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_base64_encoded\"")
			}
		case "requested_format":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RequestedFormat = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_format\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdditionalFormatResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAdditionalFormatResponseModel) {
					name = jsonFieldsNameOfAdditionalFormatResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdditionalFormatResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdditionalFormatResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AdditionalFormats as json.
func (s AdditionalFormats) Encode(e *jx.Encoder) {
	unwrapped := []ExportOptions(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes AdditionalFormats from json.
func (s *AdditionalFormats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdditionalFormats to nil")
	}
	var unwrapped []ExportOptions
	if err := func() error {
		unwrapped = make([]ExportOptions, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ExportOptions
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AdditionalFormats(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AdditionalFormats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdditionalFormats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AgentConfigOverrideInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AgentConfigOverrideInput) encodeFields(e *jx.Encoder) {
	{
		if s.FirstMessage.Set {
			e.FieldStart("first_message")
			s.FirstMessage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
}

var jsonFieldsNameOfAgentConfigOverrideInput = [3]string{
	0: "first_message",
	1: "language",
	2: "prompt",
}

// Decode decodes AgentConfigOverrideInput from json.
func (s *AgentConfigOverrideInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentConfigOverrideInput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "first_message":
			if err := func() error {
				s.FirstMessage.Reset()
				if err := s.FirstMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_message\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AgentConfigOverrideInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AgentConfigOverrideInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentConfigOverrideInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AgentConfigOverrideOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AgentConfigOverrideOutput) encodeFields(e *jx.Encoder) {
	{
		if s.FirstMessage.Set {
			e.FieldStart("first_message")
			s.FirstMessage.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
}

var jsonFieldsNameOfAgentConfigOverrideOutput = [3]string{
	0: "first_message",
	1: "language",
	2: "prompt",
}

// Decode decodes AgentConfigOverrideOutput from json.
func (s *AgentConfigOverrideOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentConfigOverrideOutput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "first_message":
			if err := func() error {
				s.FirstMessage.Reset()
				if err := s.FirstMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_message\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AgentConfigOverrideOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AgentConfigOverrideOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentConfigOverrideOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentDefinitionSource as json.
func (s AgentDefinitionSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AgentDefinitionSource from json.
func (s *AgentDefinitionSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentDefinitionSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AgentDefinitionSource(v) {
	case AgentDefinitionSourceCli:
		*s = AgentDefinitionSourceCli
	case AgentDefinitionSourceUI:
		*s = AgentDefinitionSourceUI
	case AgentDefinitionSourceAPI:
		*s = AgentDefinitionSourceAPI
	case AgentDefinitionSourceTemplate:
		*s = AgentDefinitionSourceTemplate
	case AgentDefinitionSourceUnknown:
		*s = AgentDefinitionSourceUnknown
	default:
		*s = AgentDefinitionSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AgentDefinitionSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentDefinitionSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AgentFailureResponseExample) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AgentFailureResponseExample) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.Str(s.Response)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfAgentFailureResponseExample = [2]string{
	0: "response",
	1: "type",
}

// Decode decodes AgentFailureResponseExample from json.
func (s *AgentFailureResponseExample) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentFailureResponseExample to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Response = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AgentFailureResponseExample")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAgentFailureResponseExample) {
					name = jsonFieldsNameOfAgentFailureResponseExample[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AgentFailureResponseExample) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentFailureResponseExample) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentFailureResponseExampleType as json.
func (s AgentFailureResponseExampleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AgentFailureResponseExampleType from json.
func (s *AgentFailureResponseExampleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentFailureResponseExampleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AgentFailureResponseExampleType(v) {
	case AgentFailureResponseExampleTypeFailure:
		*s = AgentFailureResponseExampleTypeFailure
	default:
		*s = AgentFailureResponseExampleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AgentFailureResponseExampleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentFailureResponseExampleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AgentMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AgentMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.BranchID.Set {
			e.FieldStart("branch_id")
			s.BranchID.Encode(e)
		}
	}
	{
		if s.WorkflowNodeID.Set {
			e.FieldStart("workflow_node_id")
			s.WorkflowNodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfAgentMetadata = [3]string{
	0: "agent_id",
	1: "branch_id",
	2: "workflow_node_id",
}

// Decode decodes AgentMetadata from json.
func (s *AgentMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "branch_id":
			if err := func() error {
				s.BranchID.Reset()
				if err := s.BranchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_id\"")
			}
		case "workflow_node_id":
			if err := func() error {
				s.WorkflowNodeID.Reset()
				if err := s.WorkflowNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AgentMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAgentMetadata) {
					name = jsonFieldsNameOfAgentMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AgentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AgentSuccessfulResponseExample) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AgentSuccessfulResponseExample) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.Str(s.Response)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfAgentSuccessfulResponseExample = [2]string{
	0: "response",
	1: "type",
}

// Decode decodes AgentSuccessfulResponseExample from json.
func (s *AgentSuccessfulResponseExample) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentSuccessfulResponseExample to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Response = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AgentSuccessfulResponseExample")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAgentSuccessfulResponseExample) {
					name = jsonFieldsNameOfAgentSuccessfulResponseExample[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AgentSuccessfulResponseExample) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentSuccessfulResponseExample) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentSuccessfulResponseExampleType as json.
func (s AgentSuccessfulResponseExampleType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AgentSuccessfulResponseExampleType from json.
func (s *AgentSuccessfulResponseExampleType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentSuccessfulResponseExampleType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AgentSuccessfulResponseExampleType(v) {
	case AgentSuccessfulResponseExampleTypeSuccess:
		*s = AgentSuccessfulResponseExampleTypeSuccess
	default:
		*s = AgentSuccessfulResponseExampleType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AgentSuccessfulResponseExampleType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentSuccessfulResponseExampleType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AgentSummaryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AgentSummaryResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		e.FieldStart("created_at_unix_secs")
		e.Int(s.CreatedAtUnixSecs)
	}
	{
		if s.LastCallTimeUnixSecs.Set {
			e.FieldStart("last_call_time_unix_secs")
			s.LastCallTimeUnixSecs.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAgentSummaryResponseModel = [7]string{
	0: "access_info",
	1: "agent_id",
	2: "archived",
	3: "created_at_unix_secs",
	4: "last_call_time_unix_secs",
	5: "name",
	6: "tags",
}

// Decode decodes AgentSummaryResponseModel from json.
func (s *AgentSummaryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AgentSummaryResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "agent_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "created_at_unix_secs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix_secs\"")
			}
		case "last_call_time_unix_secs":
			if err := func() error {
				s.LastCallTimeUnixSecs.Reset()
				if err := s.LastCallTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_call_time_unix_secs\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AgentSummaryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAgentSummaryResponseModel) {
					name = jsonFieldsNameOfAgentSummaryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AgentSummaryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AgentSummaryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AsyncConversationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AsyncConversationMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.DeliveryError.Set {
			e.FieldStart("delivery_error")
			s.DeliveryError.Encode(e)
		}
	}
	{
		e.FieldStart("delivery_status")
		s.DeliveryStatus.Encode(e)
	}
	{
		e.FieldStart("delivery_timestamp")
		e.Int(s.DeliveryTimestamp)
	}
	{
		e.FieldStart("external_id")
		e.Str(s.ExternalID)
	}
	{
		e.FieldStart("external_system")
		e.Str(s.ExternalSystem)
	}
	{
		if s.LastRetryTimestamp.Set {
			e.FieldStart("last_retry_timestamp")
			s.LastRetryTimestamp.Encode(e)
		}
	}
	{
		if s.RetryCount.Set {
			e.FieldStart("retry_count")
			s.RetryCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfAsyncConversationMetadata = [7]string{
	0: "delivery_error",
	1: "delivery_status",
	2: "delivery_timestamp",
	3: "external_id",
	4: "external_system",
	5: "last_retry_timestamp",
	6: "retry_count",
}

// Decode decodes AsyncConversationMetadata from json.
func (s *AsyncConversationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AsyncConversationMetadata to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "delivery_error":
			if err := func() error {
				s.DeliveryError.Reset()
				if err := s.DeliveryError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery_error\"")
			}
		case "delivery_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.DeliveryStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery_status\"")
			}
		case "delivery_timestamp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DeliveryTimestamp = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery_timestamp\"")
			}
		case "external_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExternalID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_id\"")
			}
		case "external_system":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ExternalSystem = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_system\"")
			}
		case "last_retry_timestamp":
			if err := func() error {
				s.LastRetryTimestamp.Reset()
				if err := s.LastRetryTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_retry_timestamp\"")
			}
		case "retry_count":
			if err := func() error {
				s.RetryCount.Reset()
				if err := s.RetryCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AsyncConversationMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAsyncConversationMetadata) {
					name = jsonFieldsNameOfAsyncConversationMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AsyncConversationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AsyncConversationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AsyncConversationMetadataDeliveryStatus as json.
func (s AsyncConversationMetadataDeliveryStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AsyncConversationMetadataDeliveryStatus from json.
func (s *AsyncConversationMetadataDeliveryStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AsyncConversationMetadataDeliveryStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AsyncConversationMetadataDeliveryStatus(v) {
	case AsyncConversationMetadataDeliveryStatusPending:
		*s = AsyncConversationMetadataDeliveryStatusPending
	case AsyncConversationMetadataDeliveryStatusSuccess:
		*s = AsyncConversationMetadataDeliveryStatusSuccess
	case AsyncConversationMetadataDeliveryStatusFailed:
		*s = AsyncConversationMetadataDeliveryStatusFailed
	default:
		*s = AsyncConversationMetadataDeliveryStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AsyncConversationMetadataDeliveryStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AsyncConversationMetadataDeliveryStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioNativeCreateProjectResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioNativeCreateProjectResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("converting")
		e.Bool(s.Converting)
	}
	{
		e.FieldStart("html_snippet")
		e.Str(s.HTMLSnippet)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
}

var jsonFieldsNameOfAudioNativeCreateProjectResponseModel = [3]string{
	0: "converting",
	1: "html_snippet",
	2: "project_id",
}

// Decode decodes AudioNativeCreateProjectResponseModel from json.
func (s *AudioNativeCreateProjectResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioNativeCreateProjectResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "converting":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Converting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"converting\"")
			}
		case "html_snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.HTMLSnippet = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_snippet\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioNativeCreateProjectResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioNativeCreateProjectResponseModel) {
					name = jsonFieldsNameOfAudioNativeCreateProjectResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioNativeCreateProjectResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioNativeCreateProjectResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioNativeEditContentResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioNativeEditContentResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("converting")
		e.Bool(s.Converting)
	}
	{
		e.FieldStart("html_snippet")
		e.Str(s.HTMLSnippet)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("publishing")
		e.Bool(s.Publishing)
	}
}

var jsonFieldsNameOfAudioNativeEditContentResponseModel = [4]string{
	0: "converting",
	1: "html_snippet",
	2: "project_id",
	3: "publishing",
}

// Decode decodes AudioNativeEditContentResponseModel from json.
func (s *AudioNativeEditContentResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioNativeEditContentResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "converting":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Converting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"converting\"")
			}
		case "html_snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.HTMLSnippet = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"html_snippet\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "publishing":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Publishing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioNativeEditContentResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioNativeEditContentResponseModel) {
					name = jsonFieldsNameOfAudioNativeEditContentResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioNativeEditContentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioNativeEditContentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioNativeProjectSettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioNativeProjectSettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AudioPath.Set {
			e.FieldStart("audio_path")
			s.AudioPath.Encode(e)
		}
	}
	{
		if s.AudioURL.Set {
			e.FieldStart("audio_url")
			s.AudioURL.Encode(e)
		}
	}
	{
		e.FieldStart("author")
		e.Str(s.Author)
	}
	{
		e.FieldStart("background_color")
		e.Str(s.BackgroundColor)
	}
	{
		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		e.FieldStart("sessionization")
		e.Int(s.Sessionization)
	}
	{
		e.FieldStart("small")
		e.Bool(s.Small)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("text_color")
		e.Str(s.TextColor)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfAudioNativeProjectSettingsResponseModel = [10]string{
	0: "audio_path",
	1: "audio_url",
	2: "author",
	3: "background_color",
	4: "image",
	5: "sessionization",
	6: "small",
	7: "status",
	8: "text_color",
	9: "title",
}

// Decode decodes AudioNativeProjectSettingsResponseModel from json.
func (s *AudioNativeProjectSettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioNativeProjectSettingsResponseModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_path":
			if err := func() error {
				s.AudioPath.Reset()
				if err := s.AudioPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_path\"")
			}
		case "audio_url":
			if err := func() error {
				s.AudioURL.Reset()
				if err := s.AudioURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_url\"")
			}
		case "author":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Author = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "background_color":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BackgroundColor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background_color\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "sessionization":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Sessionization = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sessionization\"")
			}
		case "small":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Small = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"small\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "text_color":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TextColor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_color\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioNativeProjectSettingsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01111100,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioNativeProjectSettingsResponseModel) {
					name = jsonFieldsNameOfAudioNativeProjectSettingsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioNativeProjectSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioNativeProjectSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AudioNativeProjectSettingsResponseModelStatus as json.
func (s AudioNativeProjectSettingsResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AudioNativeProjectSettingsResponseModelStatus from json.
func (s *AudioNativeProjectSettingsResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioNativeProjectSettingsResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AudioNativeProjectSettingsResponseModelStatus(v) {
	case AudioNativeProjectSettingsResponseModelStatusProcessing:
		*s = AudioNativeProjectSettingsResponseModelStatusProcessing
	case AudioNativeProjectSettingsResponseModelStatusReady:
		*s = AudioNativeProjectSettingsResponseModelStatusReady
	default:
		*s = AudioNativeProjectSettingsResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AudioNativeProjectSettingsResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioNativeProjectSettingsResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioWithTimestampsAndVoiceSegmentsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioWithTimestampsAndVoiceSegmentsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Alignment.Set {
			e.FieldStart("alignment")
			s.Alignment.Encode(e)
		}
	}
	{
		e.FieldStart("audio_base64")
		e.Str(s.AudioBase64)
	}
	{
		if s.NormalizedAlignment.Set {
			e.FieldStart("normalized_alignment")
			s.NormalizedAlignment.Encode(e)
		}
	}
	{
		e.FieldStart("voice_segments")
		e.ArrStart()
		for _, elem := range s.VoiceSegments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAudioWithTimestampsAndVoiceSegmentsResponseModel = [4]string{
	0: "alignment",
	1: "audio_base64",
	2: "normalized_alignment",
	3: "voice_segments",
}

// Decode decodes AudioWithTimestampsAndVoiceSegmentsResponseModel from json.
func (s *AudioWithTimestampsAndVoiceSegmentsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioWithTimestampsAndVoiceSegmentsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alignment":
			if err := func() error {
				s.Alignment.Reset()
				if err := s.Alignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alignment\"")
			}
		case "audio_base64":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base64\"")
			}
		case "normalized_alignment":
			if err := func() error {
				s.NormalizedAlignment.Reset()
				if err := s.NormalizedAlignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normalized_alignment\"")
			}
		case "voice_segments":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.VoiceSegments = make([]VoiceSegment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceSegment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VoiceSegments = append(s.VoiceSegments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioWithTimestampsAndVoiceSegmentsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioWithTimestampsAndVoiceSegmentsResponseModel) {
					name = jsonFieldsNameOfAudioWithTimestampsAndVoiceSegmentsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioWithTimestampsAndVoiceSegmentsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioWithTimestampsAndVoiceSegmentsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AudioWithTimestampsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AudioWithTimestampsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Alignment.Set {
			e.FieldStart("alignment")
			s.Alignment.Encode(e)
		}
	}
	{
		e.FieldStart("audio_base64")
		e.Str(s.AudioBase64)
	}
	{
		if s.NormalizedAlignment.Set {
			e.FieldStart("normalized_alignment")
			s.NormalizedAlignment.Encode(e)
		}
	}
}

var jsonFieldsNameOfAudioWithTimestampsResponseModel = [3]string{
	0: "alignment",
	1: "audio_base64",
	2: "normalized_alignment",
}

// Decode decodes AudioWithTimestampsResponseModel from json.
func (s *AudioWithTimestampsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AudioWithTimestampsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alignment":
			if err := func() error {
				s.Alignment.Reset()
				if err := s.Alignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alignment\"")
			}
		case "audio_base64":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base64\"")
			}
		case "normalized_alignment":
			if err := func() error {
				s.NormalizedAlignment.Reset()
				if err := s.NormalizedAlignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normalized_alignment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AudioWithTimestampsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAudioWithTimestampsResponseModel) {
					name = jsonFieldsNameOfAudioWithTimestampsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AudioWithTimestampsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AudioWithTimestampsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthorizationMethod as json.
func (s AuthorizationMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthorizationMethod from json.
func (s *AuthorizationMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthorizationMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthorizationMethod(v) {
	case AuthorizationMethodInvalid:
		*s = AuthorizationMethodInvalid
	case AuthorizationMethodPublic:
		*s = AuthorizationMethodPublic
	case AuthorizationMethodAuthorizationHeader:
		*s = AuthorizationMethodAuthorizationHeader
	case AuthorizationMethodSignedURL:
		*s = AuthorizationMethodSignedURL
	case AuthorizationMethodShareableLink:
		*s = AuthorizationMethodShareableLink
	case AuthorizationMethodLivekitToken:
		*s = AuthorizationMethodLivekitToken
	case AuthorizationMethodLivekitTokenWebsite:
		*s = AuthorizationMethodLivekitTokenWebsite
	case AuthorizationMethodGenesysAPIKey:
		*s = AuthorizationMethodGenesysAPIKey
	case AuthorizationMethodWhatsapp:
		*s = AuthorizationMethodWhatsapp
	default:
		*s = AuthorizationMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthorizationMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthorizationMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchCallDetailedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchCallDetailedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("agent_name")
		e.Str(s.AgentName)
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("last_updated_at_unix")
		e.Int(s.LastUpdatedAtUnix)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PhoneNumberID.Set {
			e.FieldStart("phone_number_id")
			s.PhoneNumberID.Encode(e)
		}
	}
	{
		if s.PhoneProvider.Set {
			e.FieldStart("phone_provider")
			s.PhoneProvider.Encode(e)
		}
	}
	{
		e.FieldStart("recipients")
		e.ArrStart()
		for _, elem := range s.Recipients {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.RetryCount.Set {
			e.FieldStart("retry_count")
			s.RetryCount.Encode(e)
		}
	}
	{
		e.FieldStart("scheduled_time_unix")
		e.Int(s.ScheduledTimeUnix)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("total_calls_dispatched")
		e.Int(s.TotalCallsDispatched)
	}
	{
		e.FieldStart("total_calls_scheduled")
		e.Int(s.TotalCallsScheduled)
	}
	{
		if s.WhatsappParams.Set {
			e.FieldStart("whatsapp_params")
			s.WhatsappParams.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchCallDetailedResponse = [15]string{
	0:  "agent_id",
	1:  "agent_name",
	2:  "created_at_unix",
	3:  "id",
	4:  "last_updated_at_unix",
	5:  "name",
	6:  "phone_number_id",
	7:  "phone_provider",
	8:  "recipients",
	9:  "retry_count",
	10: "scheduled_time_unix",
	11: "status",
	12: "total_calls_dispatched",
	13: "total_calls_scheduled",
	14: "whatsapp_params",
}

// Decode decodes BatchCallDetailedResponse from json.
func (s *BatchCallDetailedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchCallDetailedResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AgentName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_name\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "last_updated_at_unix":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.LastUpdatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "phone_number_id":
			if err := func() error {
				s.PhoneNumberID.Reset()
				if err := s.PhoneNumberID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "phone_provider":
			if err := func() error {
				s.PhoneProvider.Reset()
				if err := s.PhoneProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_provider\"")
			}
		case "recipients":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Recipients = make([]OutboundCallRecipientResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OutboundCallRecipientResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recipients = append(s.Recipients, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipients\"")
			}
		case "retry_count":
			if err := func() error {
				s.RetryCount.Reset()
				if err := s.RetryCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_count\"")
			}
		case "scheduled_time_unix":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ScheduledTimeUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduled_time_unix\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "total_calls_dispatched":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalCallsDispatched = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_calls_dispatched\"")
			}
		case "total_calls_scheduled":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.TotalCallsScheduled = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_calls_scheduled\"")
			}
		case "whatsapp_params":
			if err := func() error {
				s.WhatsappParams.Reset()
				if err := s.WhatsappParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_params\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchCallDetailedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchCallDetailedResponse) {
					name = jsonFieldsNameOfBatchCallDetailedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchCallDetailedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchCallDetailedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchCallRecipientStatus as json.
func (s BatchCallRecipientStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchCallRecipientStatus from json.
func (s *BatchCallRecipientStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchCallRecipientStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchCallRecipientStatus(v) {
	case BatchCallRecipientStatusPending:
		*s = BatchCallRecipientStatusPending
	case BatchCallRecipientStatusInitiated:
		*s = BatchCallRecipientStatusInitiated
	case BatchCallRecipientStatusInProgress:
		*s = BatchCallRecipientStatusInProgress
	case BatchCallRecipientStatusCompleted:
		*s = BatchCallRecipientStatusCompleted
	case BatchCallRecipientStatusFailed:
		*s = BatchCallRecipientStatusFailed
	case BatchCallRecipientStatusCancelled:
		*s = BatchCallRecipientStatusCancelled
	case BatchCallRecipientStatusVoicemail:
		*s = BatchCallRecipientStatusVoicemail
	default:
		*s = BatchCallRecipientStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchCallRecipientStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchCallRecipientStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchCallResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("agent_name")
		e.Str(s.AgentName)
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("last_updated_at_unix")
		e.Int(s.LastUpdatedAtUnix)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PhoneNumberID.Set {
			e.FieldStart("phone_number_id")
			s.PhoneNumberID.Encode(e)
		}
	}
	{
		if s.PhoneProvider.Set {
			e.FieldStart("phone_provider")
			s.PhoneProvider.Encode(e)
		}
	}
	{
		if s.RetryCount.Set {
			e.FieldStart("retry_count")
			s.RetryCount.Encode(e)
		}
	}
	{
		e.FieldStart("scheduled_time_unix")
		e.Int(s.ScheduledTimeUnix)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("total_calls_dispatched")
		e.Int(s.TotalCallsDispatched)
	}
	{
		e.FieldStart("total_calls_scheduled")
		e.Int(s.TotalCallsScheduled)
	}
	{
		if s.WhatsappParams.Set {
			e.FieldStart("whatsapp_params")
			s.WhatsappParams.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchCallResponse = [14]string{
	0:  "agent_id",
	1:  "agent_name",
	2:  "created_at_unix",
	3:  "id",
	4:  "last_updated_at_unix",
	5:  "name",
	6:  "phone_number_id",
	7:  "phone_provider",
	8:  "retry_count",
	9:  "scheduled_time_unix",
	10: "status",
	11: "total_calls_dispatched",
	12: "total_calls_scheduled",
	13: "whatsapp_params",
}

// Decode decodes BatchCallResponse from json.
func (s *BatchCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchCallResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AgentName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_name\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "last_updated_at_unix":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.LastUpdatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "phone_number_id":
			if err := func() error {
				s.PhoneNumberID.Reset()
				if err := s.PhoneNumberID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "phone_provider":
			if err := func() error {
				s.PhoneProvider.Reset()
				if err := s.PhoneProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_provider\"")
			}
		case "retry_count":
			if err := func() error {
				s.RetryCount.Reset()
				if err := s.RetryCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retry_count\"")
			}
		case "scheduled_time_unix":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ScheduledTimeUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduled_time_unix\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "total_calls_dispatched":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalCallsDispatched = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_calls_dispatched\"")
			}
		case "total_calls_scheduled":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TotalCallsScheduled = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_calls_scheduled\"")
			}
		case "whatsapp_params":
			if err := func() error {
				s.WhatsappParams.Reset()
				if err := s.WhatsappParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_params\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchCallResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00111111,
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchCallResponse) {
					name = jsonFieldsNameOfBatchCallResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchCallStatus as json.
func (s BatchCallStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchCallStatus from json.
func (s *BatchCallStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchCallStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchCallStatus(v) {
	case BatchCallStatusPending:
		*s = BatchCallStatusPending
	case BatchCallStatusInProgress:
		*s = BatchCallStatusInProgress
	case BatchCallStatusCompleted:
		*s = BatchCallStatusCompleted
	case BatchCallStatusFailed:
		*s = BatchCallStatusFailed
	case BatchCallStatusCancelled:
		*s = BatchCallStatusCancelled
	default:
		*s = BatchCallStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchCallStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchCallStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchCallWhatsAppParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchCallWhatsAppParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("whatsapp_call_permission_request_template_language_code")
		e.Str(s.WhatsappCallPermissionRequestTemplateLanguageCode)
	}
	{
		e.FieldStart("whatsapp_call_permission_request_template_name")
		e.Str(s.WhatsappCallPermissionRequestTemplateName)
	}
	{
		if s.WhatsappPhoneNumberID.Set {
			e.FieldStart("whatsapp_phone_number_id")
			s.WhatsappPhoneNumberID.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchCallWhatsAppParams = [3]string{
	0: "whatsapp_call_permission_request_template_language_code",
	1: "whatsapp_call_permission_request_template_name",
	2: "whatsapp_phone_number_id",
}

// Decode decodes BatchCallWhatsAppParams from json.
func (s *BatchCallWhatsAppParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchCallWhatsAppParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "whatsapp_call_permission_request_template_language_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WhatsappCallPermissionRequestTemplateLanguageCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_call_permission_request_template_language_code\"")
			}
		case "whatsapp_call_permission_request_template_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WhatsappCallPermissionRequestTemplateName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_call_permission_request_template_name\"")
			}
		case "whatsapp_phone_number_id":
			if err := func() error {
				s.WhatsappPhoneNumberID.Reset()
				if err := s.WhatsappPhoneNumberID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_phone_number_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchCallWhatsAppParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchCallWhatsAppParams) {
					name = jsonFieldsNameOfBatchCallWhatsAppParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchCallWhatsAppParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchCallWhatsAppParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchFailureResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchFailureResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error_code")
		e.Int(s.ErrorCode)
	}
	{
		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
	{
		e.FieldStart("error_status")
		e.Str(s.ErrorStatus)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfBatchFailureResponseModel = [4]string{
	0: "error_code",
	1: "error_message",
	2: "error_status",
	3: "status",
}

// Decode decodes BatchFailureResponseModel from json.
func (s *BatchFailureResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchFailureResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ErrorCode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "error_status":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ErrorStatus = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_status\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchFailureResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchFailureResponseModel) {
					name = jsonFieldsNameOfBatchFailureResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchFailureResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchFailureResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchFailureResponseModelStatus as json.
func (s BatchFailureResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BatchFailureResponseModelStatus from json.
func (s *BatchFailureResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchFailureResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BatchFailureResponseModelStatus(v) {
	case BatchFailureResponseModelStatusFailure:
		*s = BatchFailureResponseModelStatusFailure
	default:
		*s = BatchFailureResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchFailureResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchFailureResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BillingPeriod as json.
func (s BillingPeriod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BillingPeriod from json.
func (s *BillingPeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BillingPeriod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BillingPeriod(v) {
	case BillingPeriodMonthlyPeriod:
		*s = BillingPeriodMonthlyPeriod
	case BillingPeriod3MonthPeriod:
		*s = BillingPeriod3MonthPeriod
	case BillingPeriod6MonthPeriod:
		*s = BillingPeriod6MonthPeriod
	case BillingPeriodAnnualPeriod:
		*s = BillingPeriodAnnualPeriod
	default:
		*s = BillingPeriod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BillingPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BillingPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
}

var jsonFieldsNameOfBodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost = [1]string{
	0: "language",
}

// Decode decodes BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost from json.
func (s *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost) {
					name = jsonFieldsNameOfBodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfBodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost = [1]string{
	0: "email",
}

// Decode decodes BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost from json.
func (s *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost) {
					name = jsonFieldsNameOfBodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("new_name")
		e.Str(s.NewName)
	}
}

var jsonFieldsNameOfBodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost = [1]string{
	0: "new_name",
}

// Decode decodes BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost from json.
func (s *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost) {
					name = jsonFieldsNameOfBodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyComposeMusicV1MusicPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyComposeMusicV1MusicPost) encodeFields(e *jx.Encoder) {
	{
		if s.CompositionPlan.Set {
			e.FieldStart("composition_plan")
			s.CompositionPlan.Encode(e)
		}
	}
	{
		if s.FinetuneID.Set {
			e.FieldStart("finetune_id")
			s.FinetuneID.Encode(e)
		}
	}
	{
		if s.ForceInstrumental.Set {
			e.FieldStart("force_instrumental")
			s.ForceInstrumental.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.MusicLengthMs.Set {
			e.FieldStart("music_length_ms")
			s.MusicLengthMs.Encode(e)
		}
	}
	{
		if s.MusicPrompt.Set {
			e.FieldStart("music_prompt")
			s.MusicPrompt.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
	{
		if s.RespectSectionsDurations.Set {
			e.FieldStart("respect_sections_durations")
			s.RespectSectionsDurations.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.SignWithC2pa.Set {
			e.FieldStart("sign_with_c2pa")
			s.SignWithC2pa.Encode(e)
		}
	}
	{
		if s.StoreForInpainting.Set {
			e.FieldStart("store_for_inpainting")
			s.StoreForInpainting.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyComposeMusicV1MusicPost = [11]string{
	0:  "composition_plan",
	1:  "finetune_id",
	2:  "force_instrumental",
	3:  "model_id",
	4:  "music_length_ms",
	5:  "music_prompt",
	6:  "prompt",
	7:  "respect_sections_durations",
	8:  "seed",
	9:  "sign_with_c2pa",
	10: "store_for_inpainting",
}

// Decode decodes BodyComposeMusicV1MusicPost from json.
func (s *BodyComposeMusicV1MusicPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyComposeMusicV1MusicPost to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "composition_plan":
			if err := func() error {
				s.CompositionPlan.Reset()
				if err := s.CompositionPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"composition_plan\"")
			}
		case "finetune_id":
			if err := func() error {
				s.FinetuneID.Reset()
				if err := s.FinetuneID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finetune_id\"")
			}
		case "force_instrumental":
			if err := func() error {
				s.ForceInstrumental.Reset()
				if err := s.ForceInstrumental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_instrumental\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "music_length_ms":
			if err := func() error {
				s.MusicLengthMs.Reset()
				if err := s.MusicLengthMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_length_ms\"")
			}
		case "music_prompt":
			if err := func() error {
				s.MusicPrompt.Reset()
				if err := s.MusicPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_prompt\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "respect_sections_durations":
			if err := func() error {
				s.RespectSectionsDurations.Reset()
				if err := s.RespectSectionsDurations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"respect_sections_durations\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "sign_with_c2pa":
			if err := func() error {
				s.SignWithC2pa.Reset()
				if err := s.SignWithC2pa.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sign_with_c2pa\"")
			}
		case "store_for_inpainting":
			if err := func() error {
				s.StoreForInpainting.Reset()
				if err := s.StoreForInpainting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"store_for_inpainting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyComposeMusicV1MusicPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyComposeMusicV1MusicPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyComposeMusicV1MusicPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyComposeMusicV1MusicPostModelID as json.
func (s BodyComposeMusicV1MusicPostModelID) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyComposeMusicV1MusicPostModelID from json.
func (s *BodyComposeMusicV1MusicPostModelID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyComposeMusicV1MusicPostModelID to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyComposeMusicV1MusicPostModelID(v) {
	case BodyComposeMusicV1MusicPostModelIDMusicV1:
		*s = BodyComposeMusicV1MusicPostModelIDMusicV1
	default:
		*s = BodyComposeMusicV1MusicPostModelID(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyComposeMusicV1MusicPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyComposeMusicV1MusicPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPost) encodeFields(e *jx.Encoder) {
	{
		if s.CompositionPlan.Set {
			e.FieldStart("composition_plan")
			s.CompositionPlan.Encode(e)
		}
	}
	{
		if s.FinetuneID.Set {
			e.FieldStart("finetune_id")
			s.FinetuneID.Encode(e)
		}
	}
	{
		if s.ForceInstrumental.Set {
			e.FieldStart("force_instrumental")
			s.ForceInstrumental.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.MusicLengthMs.Set {
			e.FieldStart("music_length_ms")
			s.MusicLengthMs.Encode(e)
		}
	}
	{
		if s.MusicPrompt.Set {
			e.FieldStart("music_prompt")
			s.MusicPrompt.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.SignWithC2pa.Set {
			e.FieldStart("sign_with_c2pa")
			s.SignWithC2pa.Encode(e)
		}
	}
	{
		if s.StoreForInpainting.Set {
			e.FieldStart("store_for_inpainting")
			s.StoreForInpainting.Encode(e)
		}
	}
	{
		if s.WithTimestamps.Set {
			e.FieldStart("with_timestamps")
			s.WithTimestamps.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyComposeMusicWithADetailedResponseV1MusicDetailedPost = [11]string{
	0:  "composition_plan",
	1:  "finetune_id",
	2:  "force_instrumental",
	3:  "model_id",
	4:  "music_length_ms",
	5:  "music_prompt",
	6:  "prompt",
	7:  "seed",
	8:  "sign_with_c2pa",
	9:  "store_for_inpainting",
	10: "with_timestamps",
}

// Decode decodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPost from json.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyComposeMusicWithADetailedResponseV1MusicDetailedPost to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "composition_plan":
			if err := func() error {
				s.CompositionPlan.Reset()
				if err := s.CompositionPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"composition_plan\"")
			}
		case "finetune_id":
			if err := func() error {
				s.FinetuneID.Reset()
				if err := s.FinetuneID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finetune_id\"")
			}
		case "force_instrumental":
			if err := func() error {
				s.ForceInstrumental.Reset()
				if err := s.ForceInstrumental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_instrumental\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "music_length_ms":
			if err := func() error {
				s.MusicLengthMs.Reset()
				if err := s.MusicLengthMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_length_ms\"")
			}
		case "music_prompt":
			if err := func() error {
				s.MusicPrompt.Reset()
				if err := s.MusicPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_prompt\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "sign_with_c2pa":
			if err := func() error {
				s.SignWithC2pa.Reset()
				if err := s.SignWithC2pa.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sign_with_c2pa\"")
			}
		case "store_for_inpainting":
			if err := func() error {
				s.StoreForInpainting.Reset()
				if err := s.StoreForInpainting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"store_for_inpainting\"")
			}
		case "with_timestamps":
			if err := func() error {
				s.WithTimestamps.Reset()
				if err := s.WithTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"with_timestamps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyComposeMusicWithADetailedResponseV1MusicDetailedPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID as json.
func (s BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID from json.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID(v) {
	case BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelIDMusicV1:
		*s = BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelIDMusicV1
	default:
		*s = BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost = [1]string{
	0: "items",
}

// Decode decodes BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost from json.
func (s *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]GetOrCreateRAGIndexRequestModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetOrCreateRAGIndexRequestModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost) {
					name = jsonFieldsNameOfBodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) encodeFields(e *jx.Encoder) {
	{
		if s.SpeakerName.Set {
			e.FieldStart("speaker_name")
			s.SpeakerName.Encode(e)
		}
	}
	{
		if s.VoiceID.Set {
			e.FieldStart("voice_id")
			s.VoiceID.Encode(e)
		}
	}
	{
		if s.VoiceSimilarity.Set {
			e.FieldStart("voice_similarity")
			s.VoiceSimilarity.Encode(e)
		}
	}
	{
		if s.VoiceStability.Set {
			e.FieldStart("voice_stability")
			s.VoiceStability.Encode(e)
		}
	}
	{
		if s.VoiceStyle.Set {
			e.FieldStart("voice_style")
			s.VoiceStyle.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost = [5]string{
	0: "speaker_name",
	1: "voice_id",
	2: "voice_similarity",
	3: "voice_stability",
	4: "voice_style",
}

// Decode decodes BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost from json.
func (s *BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "speaker_name":
			if err := func() error {
				s.SpeakerName.Reset()
				if err := s.SpeakerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_name\"")
			}
		case "voice_id":
			if err := func() error {
				s.VoiceID.Reset()
				if err := s.VoiceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		case "voice_similarity":
			if err := func() error {
				s.VoiceSimilarity.Reset()
				if err := s.VoiceSimilarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_similarity\"")
			}
		case "voice_stability":
			if err := func() error {
				s.VoiceStability.Reset()
				if err := s.VoiceStability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_stability\"")
			}
		case "voice_style":
			if err := func() error {
				s.VoiceStyle.Reset()
				if err := s.VoiceStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_style\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("generated_voice_id")
		e.Str(s.GeneratedVoiceID)
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.PlayedNotSelectedVoiceIds.Set {
			e.FieldStart("played_not_selected_voice_ids")
			s.PlayedNotSelectedVoiceIds.Encode(e)
		}
	}
	{
		e.FieldStart("voice_description")
		e.Str(s.VoiceDescription)
	}
	{
		e.FieldStart("voice_name")
		e.Str(s.VoiceName)
	}
}

var jsonFieldsNameOfBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost = [5]string{
	0: "generated_voice_id",
	1: "labels",
	2: "played_not_selected_voice_ids",
	3: "voice_description",
	4: "voice_name",
}

// Decode decodes BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost from json.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generated_voice_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GeneratedVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_voice_id\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "played_not_selected_voice_ids":
			if err := func() error {
				s.PlayedNotSelectedVoiceIds.Reset()
				if err := s.PlayedNotSelectedVoiceIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"played_not_selected_voice_ids\"")
			}
		case "voice_description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VoiceDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_description\"")
			}
		case "voice_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VoiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost) {
					name = jsonFieldsNameOfBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels from json.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("generated_voice_id")
		e.Str(s.GeneratedVoiceID)
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.PlayedNotSelectedVoiceIds.Set {
			e.FieldStart("played_not_selected_voice_ids")
			s.PlayedNotSelectedVoiceIds.Encode(e)
		}
	}
	{
		e.FieldStart("voice_description")
		e.Str(s.VoiceDescription)
	}
	{
		e.FieldStart("voice_name")
		e.Str(s.VoiceName)
	}
}

var jsonFieldsNameOfBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost = [5]string{
	0: "generated_voice_id",
	1: "labels",
	2: "played_not_selected_voice_ids",
	3: "voice_description",
	4: "voice_name",
}

// Decode decodes BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost from json.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "generated_voice_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GeneratedVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_voice_id\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "played_not_selected_voice_ids":
			if err := func() error {
				s.PlayedNotSelectedVoiceIds.Reset()
				if err := s.PlayedNotSelectedVoiceIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"played_not_selected_voice_ids\"")
			}
		case "voice_description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VoiceDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_description\"")
			}
		case "voice_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VoiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost) {
					name = jsonFieldsNameOfBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels from json.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreatePVCVoiceV1VoicesPvcPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreatePVCVoiceV1VoicesPvcPost) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		e.FieldStart("language")
		e.Str(s.Language)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfBodyCreatePVCVoiceV1VoicesPvcPost = [4]string{
	0: "description",
	1: "labels",
	2: "language",
	3: "name",
}

// Decode decodes BodyCreatePVCVoiceV1VoicesPvcPost from json.
func (s *BodyCreatePVCVoiceV1VoicesPvcPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreatePVCVoiceV1VoicesPvcPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "language":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Language = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreatePVCVoiceV1VoicesPvcPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreatePVCVoiceV1VoicesPvcPost) {
					name = jsonFieldsNameOfBodyCreatePVCVoiceV1VoicesPvcPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreatePVCVoiceV1VoicesPvcPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreatePVCVoiceV1VoicesPvcPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BodyCreatePVCVoiceV1VoicesPvcPostLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BodyCreatePVCVoiceV1VoicesPvcPostLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes BodyCreatePVCVoiceV1VoicesPvcPostLabels from json.
func (s *BodyCreatePVCVoiceV1VoicesPvcPostLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreatePVCVoiceV1VoicesPvcPostLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreatePVCVoiceV1VoicesPvcPostLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyCreatePVCVoiceV1VoicesPvcPostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreatePVCVoiceV1VoicesPvcPostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost) encodeFields(e *jx.Encoder) {
	{
		if s.InvalidateAffectedText.Set {
			e.FieldStart("invalidate_affected_text")
			s.InvalidateAffectedText.Encode(e)
		}
	}
	{
		e.FieldStart("pronunciation_dictionary_locators")
		e.ArrStart()
		for _, elem := range s.PronunciationDictionaryLocators {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost = [2]string{
	0: "invalidate_affected_text",
	1: "pronunciation_dictionary_locators",
}

// Decode decodes BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost from json.
func (s *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "invalidate_affected_text":
			if err := func() error {
				s.InvalidateAffectedText.Reset()
				if err := s.InvalidateAffectedText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"invalidate_affected_text\"")
			}
		case "pronunciation_dictionary_locators":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.PronunciationDictionaryLocators = make([]PronunciationDictionaryVersionLocatorDBModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PronunciationDictionaryVersionLocatorDBModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PronunciationDictionaryLocators = append(s.PronunciationDictionaryLocators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost) {
					name = jsonFieldsNameOfBodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost) encodeFields(e *jx.Encoder) {
	{
		if s.CharacterLimit.Set {
			e.FieldStart("character_limit")
			s.CharacterLimit.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
}

var jsonFieldsNameOfBodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost = [3]string{
	0: "character_limit",
	1: "name",
	2: "permissions",
}

// Decode decodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost from json.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_limit":
			if err := func() error {
				s.CharacterLimit.Reset()
				if err := s.CharacterLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_limit\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost) {
					name = jsonFieldsNameOfBodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions as json.
func (s BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions) Encode(e *jx.Encoder) {
	switch s.Type {
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemArrayBodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions:
		e.ArrStart()
		for _, elem := range s.BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions:
		s.BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1.Encode(e)
	}
}

// Decode decodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions from json.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemArray = make([]BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemArray = append(s.BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemArrayBodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions
	case jx.String:
		if err := s.BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1.Decode(d); err != nil {
			return err
		}
		s.Type = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item as json.
func (s BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item from json.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item(v) {
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemTextToSpeech:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemTextToSpeech
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechToSpeech:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechToSpeech
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechToText:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechToText
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemModelsRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemModelsRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemModelsWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemModelsWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemVoicesRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemVoicesRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemVoicesWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemVoicesWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechHistoryRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechHistoryRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechHistoryWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSpeechHistoryWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSoundGeneration:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemSoundGeneration
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemAudioIsolation:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemAudioIsolation
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemVoiceGeneration:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemVoiceGeneration
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemDubbingRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemDubbingRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemDubbingWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemDubbingWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemPronunciationDictionariesRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemPronunciationDictionariesRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemPronunciationDictionariesWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemPronunciationDictionariesWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemUserRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemUserRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemUserWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemUserWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemProjectsRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemProjectsRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemProjectsWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemProjectsWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemAudioNativeRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemAudioNativeRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemAudioNativeWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemAudioNativeWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemWorkspaceRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemWorkspaceRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemWorkspaceWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemWorkspaceWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemForcedAlignment:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemForcedAlignment
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemConvaiRead:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemConvaiRead
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemConvaiWrite:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemConvaiWrite
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemMusicGeneration:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0ItemMusicGeneration
	default:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions0Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1 as json.
func (s BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1 from json.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1(v) {
	case BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1All:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1All
	default:
		*s = BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPostPermissions1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ParentFolderID.Set {
			e.FieldStart("parent_folder_id")
			s.ParentFolderID.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfBodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost = [3]string{
	0: "name",
	1: "parent_folder_id",
	2: "text",
}

// Decode decodes BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost from json.
func (s *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parent_folder_id":
			if err := func() error {
				s.ParentFolderID.Reset()
				if err := s.ParentFolderID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_folder_id\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost) {
					name = jsonFieldsNameOfBodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ParentFolderID.Set {
			e.FieldStart("parent_folder_id")
			s.ParentFolderID.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfBodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost = [3]string{
	0: "name",
	1: "parent_folder_id",
	2: "url",
}

// Decode decodes BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost from json.
func (s *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parent_folder_id":
			if err := func() error {
				s.ParentFolderID.Reset()
				if err := s.ParentFolderID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_folder_id\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost) {
					name = jsonFieldsNameOfBodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("settings")
		s.Settings.Encode(e)
	}
}

var jsonFieldsNameOfBodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost = [1]string{
	0: "settings",
}

// Decode decodes BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost from json.
func (s *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost) {
					name = jsonFieldsNameOfBodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfBodyDeleteExistingInvitationV1WorkspaceInvitesDelete = [1]string{
	0: "email",
}

// Decode decodes BodyDeleteExistingInvitationV1WorkspaceInvitesDelete from json.
func (s *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyDeleteExistingInvitationV1WorkspaceInvitesDelete to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyDeleteExistingInvitationV1WorkspaceInvitesDelete")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyDeleteExistingInvitationV1WorkspaceInvitesDelete) {
					name = jsonFieldsNameOfBodyDeleteExistingInvitationV1WorkspaceInvitesDelete[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfBodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost = [1]string{
	0: "email",
}

// Decode decodes BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost from json.
func (s *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost) {
					name = jsonFieldsNameOfBodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyDownloadHistoryItemsV1HistoryDownloadPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyDownloadHistoryItemsV1HistoryDownloadPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("history_item_ids")
		e.ArrStart()
		for _, elem := range s.HistoryItemIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.OutputFormat.Set {
			e.FieldStart("output_format")
			s.OutputFormat.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyDownloadHistoryItemsV1HistoryDownloadPost = [2]string{
	0: "history_item_ids",
	1: "output_format",
}

// Decode decodes BodyDownloadHistoryItemsV1HistoryDownloadPost from json.
func (s *BodyDownloadHistoryItemsV1HistoryDownloadPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyDownloadHistoryItemsV1HistoryDownloadPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "history_item_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.HistoryItemIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.HistoryItemIds = append(s.HistoryItemIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history_item_ids\"")
			}
		case "output_format":
			if err := func() error {
				s.OutputFormat.Reset()
				if err := s.OutputFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output_format\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyDownloadHistoryItemsV1HistoryDownloadPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyDownloadHistoryItemsV1HistoryDownloadPost) {
					name = jsonFieldsNameOfBodyDownloadHistoryItemsV1HistoryDownloadPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyDownloadHistoryItemsV1HistoryDownloadPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyDownloadHistoryItemsV1HistoryDownloadPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("languages")
		if s.Languages == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.Languages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("segments")
		e.ArrStart()
		for _, elem := range s.Segments {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost = [2]string{
	0: "languages",
	1: "segments",
}

// Decode decodes BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost from json.
func (s *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "languages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.Languages = make([]string, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem string
						v, err := d.Str()
						elem = string(v)
						if err != nil {
							return err
						}
						s.Languages = append(s.Languages, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages\"")
			}
		case "segments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Segments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost) {
					name = jsonFieldsNameOfBodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost = [1]string{
	0: "name",
}

// Decode decodes BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost from json.
func (s *BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPost) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyEditPVCVoiceV1VoicesPvcVoiceIDPost = [4]string{
	0: "description",
	1: "labels",
	2: "language",
	3: "name",
}

// Decode decodes BodyEditPVCVoiceV1VoicesPvcVoiceIDPost from json.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyEditPVCVoiceV1VoicesPvcVoiceIDPost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyEditPVCVoiceV1VoicesPvcVoiceIDPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels from json.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch) encodeFields(e *jx.Encoder) {
	{
		if s.CharacterLimit.Set {
			e.FieldStart("character_limit")
			s.CharacterLimit.Encode(e)
		}
	}
	{
		e.FieldStart("is_enabled")
		e.Bool(s.IsEnabled)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("permissions")
		s.Permissions.Encode(e)
	}
}

var jsonFieldsNameOfBodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch = [4]string{
	0: "character_limit",
	1: "is_enabled",
	2: "name",
	3: "permissions",
}

// Decode decodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch from json.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_limit":
			if err := func() error {
				s.CharacterLimit.Reset()
				if err := s.CharacterLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_limit\"")
			}
		case "is_enabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_enabled\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permissions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch) {
					name = jsonFieldsNameOfBodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions as json.
func (s BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions) Encode(e *jx.Encoder) {
	switch s.Type {
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemArrayBodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions:
		e.ArrStart()
		for _, elem := range s.BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions:
		s.BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1.Encode(e)
	}
}

// Decode decodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions from json.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemArray = make([]BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemArray = append(s.BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemArrayBodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions
	case jx.String:
		if err := s.BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1.Decode(d); err != nil {
			return err
		}
		s.Type = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item as json.
func (s BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item from json.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item(v) {
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemTextToSpeech:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemTextToSpeech
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechToSpeech:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechToSpeech
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechToText:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechToText
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemModelsRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemModelsRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemModelsWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemModelsWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemVoicesRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemVoicesRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemVoicesWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemVoicesWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechHistoryRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechHistoryRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechHistoryWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSpeechHistoryWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSoundGeneration:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemSoundGeneration
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemAudioIsolation:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemAudioIsolation
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemVoiceGeneration:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemVoiceGeneration
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemDubbingRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemDubbingRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemDubbingWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemDubbingWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemPronunciationDictionariesRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemPronunciationDictionariesRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemPronunciationDictionariesWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemPronunciationDictionariesWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemUserRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemUserRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemUserWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemUserWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemProjectsRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemProjectsRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemProjectsWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemProjectsWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemAudioNativeRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemAudioNativeRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemAudioNativeWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemAudioNativeWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemWorkspaceRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemWorkspaceRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemWorkspaceWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemWorkspaceWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemForcedAlignment:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemForcedAlignment
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemConvaiRead:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemConvaiRead
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemConvaiWrite:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemConvaiWrite
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemMusicGeneration:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0ItemMusicGeneration
	default:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions0Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1 as json.
func (s BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1 from json.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1(v) {
	case BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1All:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1All
	default:
		*s = BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatchPermissions1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accent")
		e.Str(s.Accent)
	}
	{
		e.FieldStart("accent_strength")
		e.Float64(s.AccentStrength)
	}
	{
		e.FieldStart("age")
		s.Age.Encode(e)
	}
	{
		e.FieldStart("gender")
		s.Gender.Encode(e)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfBodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost = [5]string{
	0: "accent",
	1: "accent_strength",
	2: "age",
	3: "gender",
	4: "text",
}

// Decode decodes BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost from json.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Accent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accent\"")
			}
		case "accent_strength":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.AccentStrength = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accent_strength\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Age.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "gender":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Gender.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gender\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost) {
					name = jsonFieldsNameOfBodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge as json.
func (s BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge from json.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge(v) {
	case BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeYoung:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeYoung
	case BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeMiddleAged:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeMiddleAged
	case BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeOld:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeOld
	default:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender as json.
func (s BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender from json.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender(v) {
	case BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderFemale:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderFemale
	case BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderMale:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderMale
	default:
		*s = BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyGenerateCompositionPlanV1MusicPlanPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyGenerateCompositionPlanV1MusicPlanPost) encodeFields(e *jx.Encoder) {
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.MusicLengthMs.Set {
			e.FieldStart("music_length_ms")
			s.MusicLengthMs.Encode(e)
		}
	}
	{
		e.FieldStart("prompt")
		e.Str(s.Prompt)
	}
	{
		if s.SourceCompositionPlan.Set {
			e.FieldStart("source_composition_plan")
			s.SourceCompositionPlan.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyGenerateCompositionPlanV1MusicPlanPost = [4]string{
	0: "model_id",
	1: "music_length_ms",
	2: "prompt",
	3: "source_composition_plan",
}

// Decode decodes BodyGenerateCompositionPlanV1MusicPlanPost from json.
func (s *BodyGenerateCompositionPlanV1MusicPlanPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyGenerateCompositionPlanV1MusicPlanPost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "music_length_ms":
			if err := func() error {
				s.MusicLengthMs.Reset()
				if err := s.MusicLengthMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_length_ms\"")
			}
		case "prompt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Prompt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "source_composition_plan":
			if err := func() error {
				s.SourceCompositionPlan.Reset()
				if err := s.SourceCompositionPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_composition_plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyGenerateCompositionPlanV1MusicPlanPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyGenerateCompositionPlanV1MusicPlanPost) {
					name = jsonFieldsNameOfBodyGenerateCompositionPlanV1MusicPlanPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyGenerateCompositionPlanV1MusicPlanPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyGenerateCompositionPlanV1MusicPlanPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyGenerateCompositionPlanV1MusicPlanPostModelID as json.
func (s BodyGenerateCompositionPlanV1MusicPlanPostModelID) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyGenerateCompositionPlanV1MusicPlanPostModelID from json.
func (s *BodyGenerateCompositionPlanV1MusicPlanPostModelID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyGenerateCompositionPlanV1MusicPlanPostModelID to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyGenerateCompositionPlanV1MusicPlanPostModelID(v) {
	case BodyGenerateCompositionPlanV1MusicPlanPostModelIDMusicV1:
		*s = BodyGenerateCompositionPlanV1MusicPlanPostModelIDMusicV1
	default:
		*s = BodyGenerateCompositionPlanV1MusicPlanPostModelID(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyGenerateCompositionPlanV1MusicPlanPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyGenerateCompositionPlanV1MusicPlanPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("agent_phone_number_id")
		e.Str(s.AgentPhoneNumberID)
	}
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		e.FieldStart("to_number")
		e.Str(s.ToNumber)
	}
}

var jsonFieldsNameOfBodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost = [4]string{
	0: "agent_id",
	1: "agent_phone_number_id",
	2: "conversation_initiation_client_data",
	3: "to_number",
}

// Decode decodes BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost from json.
func (s *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_phone_number_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AgentPhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_phone_number_id\"")
			}
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "to_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ToNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost) {
					name = jsonFieldsNameOfBodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("agent_phone_number_id")
		e.Str(s.AgentPhoneNumberID)
	}
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		e.FieldStart("to_number")
		e.Str(s.ToNumber)
	}
}

var jsonFieldsNameOfBodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost = [4]string{
	0: "agent_id",
	1: "agent_phone_number_id",
	2: "conversation_initiation_client_data",
	3: "to_number",
}

// Decode decodes BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost from json.
func (s *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_phone_number_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AgentPhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_phone_number_id\"")
			}
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "to_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ToNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost) {
					name = jsonFieldsNameOfBodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("emails")
		e.ArrStart()
		for _, elem := range s.Emails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.GroupIds.Set {
			e.FieldStart("group_ids")
			s.GroupIds.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost = [2]string{
	0: "emails",
	1: "group_ids",
}

// Decode decodes BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost from json.
func (s *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "emails":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Emails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Emails = append(s.Emails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emails\"")
			}
		case "group_ids":
			if err := func() error {
				s.GroupIds.Reset()
				if err := s.GroupIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost) {
					name = jsonFieldsNameOfBodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyInviteUserV1WorkspaceInvitesAddPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyInviteUserV1WorkspaceInvitesAddPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.GroupIds.Set {
			e.FieldStart("group_ids")
			s.GroupIds.Encode(e)
		}
	}
	{
		if s.WorkspacePermission.Set {
			e.FieldStart("workspace_permission")
			s.WorkspacePermission.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyInviteUserV1WorkspaceInvitesAddPost = [3]string{
	0: "email",
	1: "group_ids",
	2: "workspace_permission",
}

// Decode decodes BodyInviteUserV1WorkspaceInvitesAddPost from json.
func (s *BodyInviteUserV1WorkspaceInvitesAddPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyInviteUserV1WorkspaceInvitesAddPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "group_ids":
			if err := func() error {
				s.GroupIds.Reset()
				if err := s.GroupIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_ids\"")
			}
		case "workspace_permission":
			if err := func() error {
				s.WorkspacePermission.Reset()
				if err := s.WorkspacePermission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyInviteUserV1WorkspaceInvitesAddPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyInviteUserV1WorkspaceInvitesAddPost) {
					name = jsonFieldsNameOfBodyInviteUserV1WorkspaceInvitesAddPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyInviteUserV1WorkspaceInvitesAddPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyInviteUserV1WorkspaceInvitesAddPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission as json.
func (s BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission from json.
func (s *BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission(v) {
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionExternal:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionExternal
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionWorkspaceAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionWorkspaceAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionWorkspaceMember:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionWorkspaceMember
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSupportL1:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSupportL1
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSupportL2:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSupportL2
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionModerator:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionModerator
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSales:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSales
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionVoiceMixer:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionVoiceMixer
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionVoiceAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionVoiceAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionConvaiAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionConvaiAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionEnterpriseViewer:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionEnterpriseViewer
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionQualityCheckAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionQualityCheckAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionWorkspaceMigrationAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionWorkspaceMigrationAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionHumanReviewer:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionHumanReviewer
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionProductionsAdmin:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionProductionsAdmin
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSupport:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionSupport
	case BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionInternal:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermissionInternal
	default:
		*s = BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		e.FieldStart("whatsapp_call_permission_request_template_language_code")
		e.Str(s.WhatsappCallPermissionRequestTemplateLanguageCode)
	}
	{
		e.FieldStart("whatsapp_call_permission_request_template_name")
		e.Str(s.WhatsappCallPermissionRequestTemplateName)
	}
	{
		e.FieldStart("whatsapp_phone_number_id")
		e.Str(s.WhatsappPhoneNumberID)
	}
	{
		e.FieldStart("whatsapp_user_id")
		e.Str(s.WhatsappUserID)
	}
}

var jsonFieldsNameOfBodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost = [6]string{
	0: "agent_id",
	1: "conversation_initiation_client_data",
	2: "whatsapp_call_permission_request_template_language_code",
	3: "whatsapp_call_permission_request_template_name",
	4: "whatsapp_phone_number_id",
	5: "whatsapp_user_id",
}

// Decode decodes BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost from json.
func (s *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "whatsapp_call_permission_request_template_language_code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WhatsappCallPermissionRequestTemplateLanguageCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_call_permission_request_template_language_code\"")
			}
		case "whatsapp_call_permission_request_template_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.WhatsappCallPermissionRequestTemplateName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_call_permission_request_template_name\"")
			}
		case "whatsapp_phone_number_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.WhatsappPhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_phone_number_id\"")
			}
		case "whatsapp_user_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.WhatsappUserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost) {
					name = jsonFieldsNameOfBodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("segment_ids")
		e.ArrStart()
		for _, elem := range s.SegmentIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("speaker_id")
		e.Str(s.SpeakerID)
	}
}

var jsonFieldsNameOfBodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost = [2]string{
	0: "segment_ids",
	1: "speaker_id",
}

// Decode decodes BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost from json.
func (s *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "segment_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.SegmentIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SegmentIds = append(s.SegmentIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_ids\"")
			}
		case "speaker_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SpeakerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost) {
					name = jsonFieldsNameOfBodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		e.FieldStart("from_number")
		e.Str(s.FromNumber)
	}
	{
		e.FieldStart("to_number")
		e.Str(s.ToNumber)
	}
}

var jsonFieldsNameOfBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost = [5]string{
	0: "agent_id",
	1: "conversation_initiation_client_data",
	2: "direction",
	3: "from_number",
	4: "to_number",
}

// Decode decodes BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost from json.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "from_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FromNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_number\"")
			}
		case "to_number":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ToNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost) {
					name = jsonFieldsNameOfBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection as json.
func (s BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection from json.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection(v) {
	case BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirectionInbound:
		*s = BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirectionInbound
	case BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirectionOutbound:
		*s = BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirectionOutbound
	default:
		*s = BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule_strings")
		e.ArrStart()
		for _, elem := range s.RuleStrings {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost = [1]string{
	0: "rule_strings",
}

// Decode decodes BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost from json.
func (s *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule_strings":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.RuleStrings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RuleStrings = append(s.RuleStrings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule_strings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost) {
					name = jsonFieldsNameOfBodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) encodeFields(e *jx.Encoder) {
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost = [1]string{
	0: "model_id",
}

// Decode decodes BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost from json.
func (s *BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost) encodeFields(e *jx.Encoder) {
	{
		if s.GroupID.Set {
			e.FieldStart("group_id")
			s.GroupID.Encode(e)
		}
	}
	{
		e.FieldStart("resource_type")
		s.ResourceType.Encode(e)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.UserEmail.Set {
			e.FieldStart("user_email")
			s.UserEmail.Encode(e)
		}
	}
	{
		if s.WorkspaceAPIKeyID.Set {
			e.FieldStart("workspace_api_key_id")
			s.WorkspaceAPIKeyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost = [5]string{
	0: "group_id",
	1: "resource_type",
	2: "role",
	3: "user_email",
	4: "workspace_api_key_id",
}

// Decode decodes BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost from json.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			if err := func() error {
				s.GroupID.Reset()
				if err := s.GroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "resource_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_type\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "user_email":
			if err := func() error {
				s.UserEmail.Reset()
				if err := s.UserEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_email\"")
			}
		case "workspace_api_key_id":
			if err := func() error {
				s.WorkspaceAPIKeyID.Reset()
				if err := s.WorkspaceAPIKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_api_key_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost) {
					name = jsonFieldsNameOfBodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole as json.
func (s BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole from json.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole(v) {
	case BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleAdmin:
		*s = BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleAdmin
	case BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleEditor:
		*s = BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleEditor
	case BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleCommenter:
		*s = BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleCommenter
	case BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleViewer:
		*s = BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRoleViewer
	default:
		*s = BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePostRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodySoundGenerationV1SoundGenerationPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodySoundGenerationV1SoundGenerationPost) encodeFields(e *jx.Encoder) {
	{
		if s.DurationSeconds.Set {
			e.FieldStart("duration_seconds")
			s.DurationSeconds.Encode(e)
		}
	}
	{
		if s.Loop.Set {
			e.FieldStart("loop")
			s.Loop.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.PromptInfluence.Set {
			e.FieldStart("prompt_influence")
			s.PromptInfluence.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfBodySoundGenerationV1SoundGenerationPost = [5]string{
	0: "duration_seconds",
	1: "loop",
	2: "model_id",
	3: "prompt_influence",
	4: "text",
}

// Decode decodes BodySoundGenerationV1SoundGenerationPost from json.
func (s *BodySoundGenerationV1SoundGenerationPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodySoundGenerationV1SoundGenerationPost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_seconds":
			if err := func() error {
				s.DurationSeconds.Reset()
				if err := s.DurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_seconds\"")
			}
		case "loop":
			if err := func() error {
				s.Loop.Reset()
				if err := s.Loop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loop\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "prompt_influence":
			if err := func() error {
				s.PromptInfluence.Reset()
				if err := s.PromptInfluence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_influence\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodySoundGenerationV1SoundGenerationPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodySoundGenerationV1SoundGenerationPost) {
					name = jsonFieldsNameOfBodySoundGenerationV1SoundGenerationPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodySoundGenerationV1SoundGenerationPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodySoundGenerationV1SoundGenerationPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata as json.
func (s BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata:
		e.Str(s.String)
	case BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata:
		s.BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1.Encode(e)
	}
}

// Decode decodes BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata from json.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1.Decode(d); err != nil {
			return err
		}
		s.Type = BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1 = [0]string{}

// Decode decodes BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1 from json.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) encodeFields(e *jx.Encoder) {
	{
		if s.ConvertToMpeg.Set {
			e.FieldStart("convert_to_mpeg")
			s.ConvertToMpeg.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost = [1]string{
	0: "convert_to_mpeg",
}

// Decode decodes BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost from json.
func (s *BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "convert_to_mpeg":
			if err := func() error {
				s.ConvertToMpeg.Reset()
				if err := s.ConvertToMpeg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"convert_to_mpeg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyStreamComposedMusicV1MusicStreamPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyStreamComposedMusicV1MusicStreamPost) encodeFields(e *jx.Encoder) {
	{
		if s.CompositionPlan.Set {
			e.FieldStart("composition_plan")
			s.CompositionPlan.Encode(e)
		}
	}
	{
		if s.FinetuneID.Set {
			e.FieldStart("finetune_id")
			s.FinetuneID.Encode(e)
		}
	}
	{
		if s.ForceInstrumental.Set {
			e.FieldStart("force_instrumental")
			s.ForceInstrumental.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.MusicLengthMs.Set {
			e.FieldStart("music_length_ms")
			s.MusicLengthMs.Encode(e)
		}
	}
	{
		if s.MusicPrompt.Set {
			e.FieldStart("music_prompt")
			s.MusicPrompt.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.StoreForInpainting.Set {
			e.FieldStart("store_for_inpainting")
			s.StoreForInpainting.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyStreamComposedMusicV1MusicStreamPost = [9]string{
	0: "composition_plan",
	1: "finetune_id",
	2: "force_instrumental",
	3: "model_id",
	4: "music_length_ms",
	5: "music_prompt",
	6: "prompt",
	7: "seed",
	8: "store_for_inpainting",
}

// Decode decodes BodyStreamComposedMusicV1MusicStreamPost from json.
func (s *BodyStreamComposedMusicV1MusicStreamPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyStreamComposedMusicV1MusicStreamPost to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "composition_plan":
			if err := func() error {
				s.CompositionPlan.Reset()
				if err := s.CompositionPlan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"composition_plan\"")
			}
		case "finetune_id":
			if err := func() error {
				s.FinetuneID.Reset()
				if err := s.FinetuneID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finetune_id\"")
			}
		case "force_instrumental":
			if err := func() error {
				s.ForceInstrumental.Reset()
				if err := s.ForceInstrumental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_instrumental\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "music_length_ms":
			if err := func() error {
				s.MusicLengthMs.Reset()
				if err := s.MusicLengthMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_length_ms\"")
			}
		case "music_prompt":
			if err := func() error {
				s.MusicPrompt.Reset()
				if err := s.MusicPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"music_prompt\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "store_for_inpainting":
			if err := func() error {
				s.StoreForInpainting.Reset()
				if err := s.StoreForInpainting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"store_for_inpainting\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyStreamComposedMusicV1MusicStreamPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyStreamComposedMusicV1MusicStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyStreamComposedMusicV1MusicStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyStreamComposedMusicV1MusicStreamPostModelID as json.
func (s BodyStreamComposedMusicV1MusicStreamPostModelID) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyStreamComposedMusicV1MusicStreamPostModelID from json.
func (s *BodyStreamComposedMusicV1MusicStreamPostModelID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyStreamComposedMusicV1MusicStreamPostModelID to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyStreamComposedMusicV1MusicStreamPostModelID(v) {
	case BodyStreamComposedMusicV1MusicStreamPostModelIDMusicV1:
		*s = BodyStreamComposedMusicV1MusicStreamPostModelIDMusicV1
	default:
		*s = BodyStreamComposedMusicV1MusicStreamPostModelID(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyStreamComposedMusicV1MusicStreamPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyStreamComposedMusicV1MusicStreamPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) encodeFields(e *jx.Encoder) {
	{
		if s.ConvertToMpeg.Set {
			e.FieldStart("convert_to_mpeg")
			s.ConvertToMpeg.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost = [1]string{
	0: "convert_to_mpeg",
}

// Decode decodes BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost from json.
func (s *BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "convert_to_mpeg":
			if err := func() error {
				s.ConvertToMpeg.Reset()
				if err := s.ConvertToMpeg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"convert_to_mpeg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.AgentPhoneNumberID.Set {
			e.FieldStart("agent_phone_number_id")
			s.AgentPhoneNumberID.Encode(e)
		}
	}
	{
		e.FieldStart("call_name")
		e.Str(s.CallName)
	}
	{
		e.FieldStart("recipients")
		e.ArrStart()
		for _, elem := range s.Recipients {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ScheduledTimeUnix.Set {
			e.FieldStart("scheduled_time_unix")
			s.ScheduledTimeUnix.Encode(e)
		}
	}
	{
		if s.WhatsappParams.Set {
			e.FieldStart("whatsapp_params")
			s.WhatsappParams.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost = [6]string{
	0: "agent_id",
	1: "agent_phone_number_id",
	2: "call_name",
	3: "recipients",
	4: "scheduled_time_unix",
	5: "whatsapp_params",
}

// Decode decodes BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost from json.
func (s *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_phone_number_id":
			if err := func() error {
				s.AgentPhoneNumberID.Reset()
				if err := s.AgentPhoneNumberID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_phone_number_id\"")
			}
		case "call_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CallName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_name\"")
			}
		case "recipients":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Recipients = make([]OutboundCallRecipient, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OutboundCallRecipient
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Recipients = append(s.Recipients, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recipients\"")
			}
		case "scheduled_time_unix":
			if err := func() error {
				s.ScheduledTimeUnix.Reset()
				if err := s.ScheduledTimeUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheduled_time_unix\"")
			}
		case "whatsapp_params":
			if err := func() error {
				s.WhatsappParams.Reset()
				if err := s.WhatsappParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_params\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost) {
					name = jsonFieldsNameOfBodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToDialogueFullWithTimestamps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToDialogueFullWithTimestamps) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		e.FieldStart("inputs")
		e.ArrStart()
		for _, elem := range s.Inputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToDialogueFullWithTimestamps = [7]string{
	0: "apply_text_normalization",
	1: "inputs",
	2: "language_code",
	3: "model_id",
	4: "pronunciation_dictionary_locators",
	5: "seed",
	6: "settings",
}

// Decode decodes BodyTextToDialogueFullWithTimestamps from json.
func (s *BodyTextToDialogueFullWithTimestamps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueFullWithTimestamps to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "inputs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inputs = make([]DialogueInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DialogueInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inputs = append(s.Inputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputs\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToDialogueFullWithTimestamps")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToDialogueFullWithTimestamps) {
					name = jsonFieldsNameOfBodyTextToDialogueFullWithTimestamps[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToDialogueFullWithTimestamps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueFullWithTimestamps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueFullWithTimestampsApplyTextNormalization as json.
func (s BodyTextToDialogueFullWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToDialogueFullWithTimestampsApplyTextNormalization from json.
func (s *BodyTextToDialogueFullWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueFullWithTimestampsApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToDialogueFullWithTimestampsApplyTextNormalization(v) {
	case BodyTextToDialogueFullWithTimestampsApplyTextNormalizationAuto:
		*s = BodyTextToDialogueFullWithTimestampsApplyTextNormalizationAuto
	case BodyTextToDialogueFullWithTimestampsApplyTextNormalizationOn:
		*s = BodyTextToDialogueFullWithTimestampsApplyTextNormalizationOn
	case BodyTextToDialogueFullWithTimestampsApplyTextNormalizationOff:
		*s = BodyTextToDialogueFullWithTimestampsApplyTextNormalizationOff
	default:
		*s = BodyTextToDialogueFullWithTimestampsApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToDialogueFullWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueFullWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		e.FieldStart("inputs")
		e.ArrStart()
		for _, elem := range s.Inputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost = [7]string{
	0: "apply_text_normalization",
	1: "inputs",
	2: "language_code",
	3: "model_id",
	4: "pronunciation_dictionary_locators",
	5: "seed",
	6: "settings",
}

// Decode decodes BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost from json.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "inputs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inputs = make([]DialogueInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DialogueInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inputs = append(s.Inputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputs\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost) {
					name = jsonFieldsNameOfBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization as json.
func (s BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization from json.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization(v) {
	case BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalizationAuto:
		*s = BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalizationAuto
	case BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalizationOn:
		*s = BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalizationOn
	case BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalizationOff:
		*s = BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalizationOff
	default:
		*s = BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePost) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		e.FieldStart("inputs")
		e.ArrStart()
		for _, elem := range s.Inputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToDialogueMultiVoiceV1TextToDialoguePost = [7]string{
	0: "apply_text_normalization",
	1: "inputs",
	2: "language_code",
	3: "model_id",
	4: "pronunciation_dictionary_locators",
	5: "seed",
	6: "settings",
}

// Decode decodes BodyTextToDialogueMultiVoiceV1TextToDialoguePost from json.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueMultiVoiceV1TextToDialoguePost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "inputs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inputs = make([]DialogueInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DialogueInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inputs = append(s.Inputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputs\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToDialogueMultiVoiceV1TextToDialoguePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToDialogueMultiVoiceV1TextToDialoguePost) {
					name = jsonFieldsNameOfBodyTextToDialogueMultiVoiceV1TextToDialoguePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization as json.
func (s BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization from json.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization(v) {
	case BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalizationAuto:
		*s = BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalizationAuto
	case BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalizationOn:
		*s = BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalizationOn
	case BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalizationOff:
		*s = BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalizationOff
	default:
		*s = BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToDialogueStreamWithTimestamps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToDialogueStreamWithTimestamps) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		e.FieldStart("inputs")
		e.ArrStart()
		for _, elem := range s.Inputs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToDialogueStreamWithTimestamps = [7]string{
	0: "apply_text_normalization",
	1: "inputs",
	2: "language_code",
	3: "model_id",
	4: "pronunciation_dictionary_locators",
	5: "seed",
	6: "settings",
}

// Decode decodes BodyTextToDialogueStreamWithTimestamps from json.
func (s *BodyTextToDialogueStreamWithTimestamps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueStreamWithTimestamps to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "inputs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inputs = make([]DialogueInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DialogueInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inputs = append(s.Inputs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputs\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToDialogueStreamWithTimestamps")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToDialogueStreamWithTimestamps) {
					name = jsonFieldsNameOfBodyTextToDialogueStreamWithTimestamps[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToDialogueStreamWithTimestamps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueStreamWithTimestamps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueStreamWithTimestampsApplyTextNormalization as json.
func (s BodyTextToDialogueStreamWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToDialogueStreamWithTimestampsApplyTextNormalization from json.
func (s *BodyTextToDialogueStreamWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToDialogueStreamWithTimestampsApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToDialogueStreamWithTimestampsApplyTextNormalization(v) {
	case BodyTextToDialogueStreamWithTimestampsApplyTextNormalizationAuto:
		*s = BodyTextToDialogueStreamWithTimestampsApplyTextNormalizationAuto
	case BodyTextToDialogueStreamWithTimestampsApplyTextNormalizationOn:
		*s = BodyTextToDialogueStreamWithTimestampsApplyTextNormalizationOn
	case BodyTextToDialogueStreamWithTimestampsApplyTextNormalizationOff:
		*s = BodyTextToDialogueStreamWithTimestampsApplyTextNormalizationOff
	default:
		*s = BodyTextToDialogueStreamWithTimestampsApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToDialogueStreamWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToDialogueStreamWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToSpeechFull) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToSpeechFull) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyLanguageTextNormalization.Set {
			e.FieldStart("apply_language_text_normalization")
			s.ApplyLanguageTextNormalization.Encode(e)
		}
	}
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.NextRequestIds.Set {
			e.FieldStart("next_request_ids")
			s.NextRequestIds.Encode(e)
		}
	}
	{
		if s.NextText.Set {
			e.FieldStart("next_text")
			s.NextText.Encode(e)
		}
	}
	{
		if s.PreviousRequestIds.Set {
			e.FieldStart("previous_request_ids")
			s.PreviousRequestIds.Encode(e)
		}
	}
	{
		if s.PreviousText.Set {
			e.FieldStart("previous_text")
			s.PreviousText.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.UsePvcAsIvc.Set {
			e.FieldStart("use_pvc_as_ivc")
			s.UsePvcAsIvc.Encode(e)
		}
	}
	{
		if s.VoiceSettings.Set {
			e.FieldStart("voice_settings")
			s.VoiceSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToSpeechFull = [13]string{
	0:  "apply_language_text_normalization",
	1:  "apply_text_normalization",
	2:  "language_code",
	3:  "model_id",
	4:  "next_request_ids",
	5:  "next_text",
	6:  "previous_request_ids",
	7:  "previous_text",
	8:  "pronunciation_dictionary_locators",
	9:  "seed",
	10: "text",
	11: "use_pvc_as_ivc",
	12: "voice_settings",
}

// Decode decodes BodyTextToSpeechFull from json.
func (s *BodyTextToSpeechFull) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechFull to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_language_text_normalization":
			if err := func() error {
				s.ApplyLanguageTextNormalization.Reset()
				if err := s.ApplyLanguageTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_language_text_normalization\"")
			}
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "next_request_ids":
			if err := func() error {
				s.NextRequestIds.Reset()
				if err := s.NextRequestIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_request_ids\"")
			}
		case "next_text":
			if err := func() error {
				s.NextText.Reset()
				if err := s.NextText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_text\"")
			}
		case "previous_request_ids":
			if err := func() error {
				s.PreviousRequestIds.Reset()
				if err := s.PreviousRequestIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_request_ids\"")
			}
		case "previous_text":
			if err := func() error {
				s.PreviousText.Reset()
				if err := s.PreviousText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_text\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "text":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "use_pvc_as_ivc":
			if err := func() error {
				s.UsePvcAsIvc.Reset()
				if err := s.UsePvcAsIvc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_pvc_as_ivc\"")
			}
		case "voice_settings":
			if err := func() error {
				s.VoiceSettings.Reset()
				if err := s.VoiceSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToSpeechFull")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToSpeechFull) {
					name = jsonFieldsNameOfBodyTextToSpeechFull[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToSpeechFull) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechFull) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechFullApplyTextNormalization as json.
func (s BodyTextToSpeechFullApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToSpeechFullApplyTextNormalization from json.
func (s *BodyTextToSpeechFullApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechFullApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToSpeechFullApplyTextNormalization(v) {
	case BodyTextToSpeechFullApplyTextNormalizationAuto:
		*s = BodyTextToSpeechFullApplyTextNormalizationAuto
	case BodyTextToSpeechFullApplyTextNormalizationOn:
		*s = BodyTextToSpeechFullApplyTextNormalizationOn
	case BodyTextToSpeechFullApplyTextNormalizationOff:
		*s = BodyTextToSpeechFullApplyTextNormalizationOff
	default:
		*s = BodyTextToSpeechFullApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToSpeechFullApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechFullApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToSpeechFullWithTimestamps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToSpeechFullWithTimestamps) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyLanguageTextNormalization.Set {
			e.FieldStart("apply_language_text_normalization")
			s.ApplyLanguageTextNormalization.Encode(e)
		}
	}
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.NextRequestIds != nil {
			e.FieldStart("next_request_ids")
			e.ArrStart()
			for _, elem := range s.NextRequestIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextText.Set {
			e.FieldStart("next_text")
			s.NextText.Encode(e)
		}
	}
	{
		if s.PreviousRequestIds != nil {
			e.FieldStart("previous_request_ids")
			e.ArrStart()
			for _, elem := range s.PreviousRequestIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PreviousText.Set {
			e.FieldStart("previous_text")
			s.PreviousText.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators != nil {
			e.FieldStart("pronunciation_dictionary_locators")
			e.ArrStart()
			for _, elem := range s.PronunciationDictionaryLocators {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.UsePvcAsIvc.Set {
			e.FieldStart("use_pvc_as_ivc")
			s.UsePvcAsIvc.Encode(e)
		}
	}
	{
		if s.VoiceSettings.Set {
			e.FieldStart("voice_settings")
			s.VoiceSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToSpeechFullWithTimestamps = [13]string{
	0:  "apply_language_text_normalization",
	1:  "apply_text_normalization",
	2:  "language_code",
	3:  "model_id",
	4:  "next_request_ids",
	5:  "next_text",
	6:  "previous_request_ids",
	7:  "previous_text",
	8:  "pronunciation_dictionary_locators",
	9:  "seed",
	10: "text",
	11: "use_pvc_as_ivc",
	12: "voice_settings",
}

// Decode decodes BodyTextToSpeechFullWithTimestamps from json.
func (s *BodyTextToSpeechFullWithTimestamps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechFullWithTimestamps to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_language_text_normalization":
			if err := func() error {
				s.ApplyLanguageTextNormalization.Reset()
				if err := s.ApplyLanguageTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_language_text_normalization\"")
			}
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "next_request_ids":
			if err := func() error {
				s.NextRequestIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NextRequestIds = append(s.NextRequestIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_request_ids\"")
			}
		case "next_text":
			if err := func() error {
				s.NextText.Reset()
				if err := s.NextText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_text\"")
			}
		case "previous_request_ids":
			if err := func() error {
				s.PreviousRequestIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PreviousRequestIds = append(s.PreviousRequestIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_request_ids\"")
			}
		case "previous_text":
			if err := func() error {
				s.PreviousText.Reset()
				if err := s.PreviousText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_text\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators = make([]PronunciationDictionaryVersionLocatorRequestModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PronunciationDictionaryVersionLocatorRequestModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PronunciationDictionaryLocators = append(s.PronunciationDictionaryLocators, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "text":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "use_pvc_as_ivc":
			if err := func() error {
				s.UsePvcAsIvc.Reset()
				if err := s.UsePvcAsIvc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_pvc_as_ivc\"")
			}
		case "voice_settings":
			if err := func() error {
				s.VoiceSettings.Reset()
				if err := s.VoiceSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToSpeechFullWithTimestamps")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToSpeechFullWithTimestamps) {
					name = jsonFieldsNameOfBodyTextToSpeechFullWithTimestamps[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToSpeechFullWithTimestamps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechFullWithTimestamps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechFullWithTimestampsApplyTextNormalization as json.
func (s BodyTextToSpeechFullWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToSpeechFullWithTimestampsApplyTextNormalization from json.
func (s *BodyTextToSpeechFullWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechFullWithTimestampsApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToSpeechFullWithTimestampsApplyTextNormalization(v) {
	case BodyTextToSpeechFullWithTimestampsApplyTextNormalizationAuto:
		*s = BodyTextToSpeechFullWithTimestampsApplyTextNormalizationAuto
	case BodyTextToSpeechFullWithTimestampsApplyTextNormalizationOn:
		*s = BodyTextToSpeechFullWithTimestampsApplyTextNormalizationOn
	case BodyTextToSpeechFullWithTimestampsApplyTextNormalizationOff:
		*s = BodyTextToSpeechFullWithTimestampsApplyTextNormalizationOff
	default:
		*s = BodyTextToSpeechFullWithTimestampsApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToSpeechFullWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechFullWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToSpeechStream) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToSpeechStream) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyLanguageTextNormalization.Set {
			e.FieldStart("apply_language_text_normalization")
			s.ApplyLanguageTextNormalization.Encode(e)
		}
	}
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.NextRequestIds.Set {
			e.FieldStart("next_request_ids")
			s.NextRequestIds.Encode(e)
		}
	}
	{
		if s.NextText.Set {
			e.FieldStart("next_text")
			s.NextText.Encode(e)
		}
	}
	{
		if s.PreviousRequestIds.Set {
			e.FieldStart("previous_request_ids")
			s.PreviousRequestIds.Encode(e)
		}
	}
	{
		if s.PreviousText.Set {
			e.FieldStart("previous_text")
			s.PreviousText.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.UsePvcAsIvc.Set {
			e.FieldStart("use_pvc_as_ivc")
			s.UsePvcAsIvc.Encode(e)
		}
	}
	{
		if s.VoiceSettings.Set {
			e.FieldStart("voice_settings")
			s.VoiceSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToSpeechStream = [13]string{
	0:  "apply_language_text_normalization",
	1:  "apply_text_normalization",
	2:  "language_code",
	3:  "model_id",
	4:  "next_request_ids",
	5:  "next_text",
	6:  "previous_request_ids",
	7:  "previous_text",
	8:  "pronunciation_dictionary_locators",
	9:  "seed",
	10: "text",
	11: "use_pvc_as_ivc",
	12: "voice_settings",
}

// Decode decodes BodyTextToSpeechStream from json.
func (s *BodyTextToSpeechStream) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechStream to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_language_text_normalization":
			if err := func() error {
				s.ApplyLanguageTextNormalization.Reset()
				if err := s.ApplyLanguageTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_language_text_normalization\"")
			}
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "next_request_ids":
			if err := func() error {
				s.NextRequestIds.Reset()
				if err := s.NextRequestIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_request_ids\"")
			}
		case "next_text":
			if err := func() error {
				s.NextText.Reset()
				if err := s.NextText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_text\"")
			}
		case "previous_request_ids":
			if err := func() error {
				s.PreviousRequestIds.Reset()
				if err := s.PreviousRequestIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_request_ids\"")
			}
		case "previous_text":
			if err := func() error {
				s.PreviousText.Reset()
				if err := s.PreviousText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_text\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "text":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "use_pvc_as_ivc":
			if err := func() error {
				s.UsePvcAsIvc.Reset()
				if err := s.UsePvcAsIvc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_pvc_as_ivc\"")
			}
		case "voice_settings":
			if err := func() error {
				s.VoiceSettings.Reset()
				if err := s.VoiceSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToSpeechStream")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToSpeechStream) {
					name = jsonFieldsNameOfBodyTextToSpeechStream[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToSpeechStream) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechStream) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechStreamApplyTextNormalization as json.
func (s BodyTextToSpeechStreamApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToSpeechStreamApplyTextNormalization from json.
func (s *BodyTextToSpeechStreamApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechStreamApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToSpeechStreamApplyTextNormalization(v) {
	case BodyTextToSpeechStreamApplyTextNormalizationAuto:
		*s = BodyTextToSpeechStreamApplyTextNormalizationAuto
	case BodyTextToSpeechStreamApplyTextNormalizationOn:
		*s = BodyTextToSpeechStreamApplyTextNormalizationOn
	case BodyTextToSpeechStreamApplyTextNormalizationOff:
		*s = BodyTextToSpeechStreamApplyTextNormalizationOff
	default:
		*s = BodyTextToSpeechStreamApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToSpeechStreamApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechStreamApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTextToSpeechStreamWithTimestamps) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTextToSpeechStreamWithTimestamps) encodeFields(e *jx.Encoder) {
	{
		if s.ApplyLanguageTextNormalization.Set {
			e.FieldStart("apply_language_text_normalization")
			s.ApplyLanguageTextNormalization.Encode(e)
		}
	}
	{
		if s.ApplyTextNormalization.Set {
			e.FieldStart("apply_text_normalization")
			s.ApplyTextNormalization.Encode(e)
		}
	}
	{
		if s.LanguageCode.Set {
			e.FieldStart("language_code")
			s.LanguageCode.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.NextRequestIds.Set {
			e.FieldStart("next_request_ids")
			s.NextRequestIds.Encode(e)
		}
	}
	{
		if s.NextText.Set {
			e.FieldStart("next_text")
			s.NextText.Encode(e)
		}
	}
	{
		if s.PreviousRequestIds.Set {
			e.FieldStart("previous_request_ids")
			s.PreviousRequestIds.Encode(e)
		}
	}
	{
		if s.PreviousText.Set {
			e.FieldStart("previous_text")
			s.PreviousText.Encode(e)
		}
	}
	{
		if s.PronunciationDictionaryLocators.Set {
			e.FieldStart("pronunciation_dictionary_locators")
			s.PronunciationDictionaryLocators.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.UsePvcAsIvc.Set {
			e.FieldStart("use_pvc_as_ivc")
			s.UsePvcAsIvc.Encode(e)
		}
	}
	{
		if s.VoiceSettings.Set {
			e.FieldStart("voice_settings")
			s.VoiceSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyTextToSpeechStreamWithTimestamps = [13]string{
	0:  "apply_language_text_normalization",
	1:  "apply_text_normalization",
	2:  "language_code",
	3:  "model_id",
	4:  "next_request_ids",
	5:  "next_text",
	6:  "previous_request_ids",
	7:  "previous_text",
	8:  "pronunciation_dictionary_locators",
	9:  "seed",
	10: "text",
	11: "use_pvc_as_ivc",
	12: "voice_settings",
}

// Decode decodes BodyTextToSpeechStreamWithTimestamps from json.
func (s *BodyTextToSpeechStreamWithTimestamps) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechStreamWithTimestamps to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apply_language_text_normalization":
			if err := func() error {
				s.ApplyLanguageTextNormalization.Reset()
				if err := s.ApplyLanguageTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_language_text_normalization\"")
			}
		case "apply_text_normalization":
			if err := func() error {
				s.ApplyTextNormalization.Reset()
				if err := s.ApplyTextNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apply_text_normalization\"")
			}
		case "language_code":
			if err := func() error {
				s.LanguageCode.Reset()
				if err := s.LanguageCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "next_request_ids":
			if err := func() error {
				s.NextRequestIds.Reset()
				if err := s.NextRequestIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_request_ids\"")
			}
		case "next_text":
			if err := func() error {
				s.NextText.Reset()
				if err := s.NextText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_text\"")
			}
		case "previous_request_ids":
			if err := func() error {
				s.PreviousRequestIds.Reset()
				if err := s.PreviousRequestIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_request_ids\"")
			}
		case "previous_text":
			if err := func() error {
				s.PreviousText.Reset()
				if err := s.PreviousText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous_text\"")
			}
		case "pronunciation_dictionary_locators":
			if err := func() error {
				s.PronunciationDictionaryLocators.Reset()
				if err := s.PronunciationDictionaryLocators.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_locators\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "text":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "use_pvc_as_ivc":
			if err := func() error {
				s.UsePvcAsIvc.Reset()
				if err := s.UsePvcAsIvc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_pvc_as_ivc\"")
			}
		case "voice_settings":
			if err := func() error {
				s.VoiceSettings.Reset()
				if err := s.VoiceSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTextToSpeechStreamWithTimestamps")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTextToSpeechStreamWithTimestamps) {
					name = jsonFieldsNameOfBodyTextToSpeechStreamWithTimestamps[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTextToSpeechStreamWithTimestamps) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechStreamWithTimestamps) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechStreamWithTimestampsApplyTextNormalization as json.
func (s BodyTextToSpeechStreamWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyTextToSpeechStreamWithTimestampsApplyTextNormalization from json.
func (s *BodyTextToSpeechStreamWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTextToSpeechStreamWithTimestampsApplyTextNormalization to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyTextToSpeechStreamWithTimestampsApplyTextNormalization(v) {
	case BodyTextToSpeechStreamWithTimestampsApplyTextNormalizationAuto:
		*s = BodyTextToSpeechStreamWithTimestampsApplyTextNormalizationAuto
	case BodyTextToSpeechStreamWithTimestampsApplyTextNormalizationOn:
		*s = BodyTextToSpeechStreamWithTimestampsApplyTextNormalizationOn
	case BodyTextToSpeechStreamWithTimestampsApplyTextNormalizationOff:
		*s = BodyTextToSpeechStreamWithTimestampsApplyTextNormalizationOff
	default:
		*s = BodyTextToSpeechStreamWithTimestampsApplyTextNormalization(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyTextToSpeechStreamWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTextToSpeechStreamWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("segments")
		e.ArrStart()
		for _, elem := range s.Segments {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost = [1]string{
	0: "segments",
}

// Decode decodes BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost from json.
func (s *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "segments":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Segments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost) {
					name = jsonFieldsNameOfBodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("languages")
		if s.Languages == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.Languages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("segments")
		e.ArrStart()
		for _, elem := range s.Segments {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost = [2]string{
	0: "languages",
	1: "segments",
}

// Decode decodes BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost from json.
func (s *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "languages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.Languages = make([]string, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem string
						v, err := d.Str()
						elem = string(v)
						if err != nil {
							return err
						}
						s.Languages = append(s.Languages, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages\"")
			}
		case "segments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Segments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost) {
					name = jsonFieldsNameOfBodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost) encodeFields(e *jx.Encoder) {
	{
		if s.GroupID.Set {
			e.FieldStart("group_id")
			s.GroupID.Encode(e)
		}
	}
	{
		e.FieldStart("resource_type")
		s.ResourceType.Encode(e)
	}
	{
		if s.UserEmail.Set {
			e.FieldStart("user_email")
			s.UserEmail.Encode(e)
		}
	}
	{
		if s.WorkspaceAPIKeyID.Set {
			e.FieldStart("workspace_api_key_id")
			s.WorkspaceAPIKeyID.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost = [4]string{
	0: "group_id",
	1: "resource_type",
	2: "user_email",
	3: "workspace_api_key_id",
}

// Decode decodes BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost from json.
func (s *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group_id":
			if err := func() error {
				s.GroupID.Reset()
				if err := s.GroupID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "resource_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_type\"")
			}
		case "user_email":
			if err := func() error {
				s.UserEmail.Reset()
				if err := s.UserEmail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_email\"")
			}
		case "workspace_api_key_id":
			if err := func() error {
				s.WorkspaceAPIKeyID.Reset()
				if err := s.WorkspaceAPIKeyID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_api_key_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost) {
					name = jsonFieldsNameOfBodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfBodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch = [1]string{
	0: "name",
}

// Decode decodes BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch from json.
func (s *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch) {
					name = jsonFieldsNameOfBodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdateMemberV1WorkspaceMembersPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdateMemberV1WorkspaceMembersPost) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		if s.IsLocked.Set {
			e.FieldStart("is_locked")
			s.IsLocked.Encode(e)
		}
	}
	{
		if s.WorkspaceRole.Set {
			e.FieldStart("workspace_role")
			s.WorkspaceRole.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyUpdateMemberV1WorkspaceMembersPost = [3]string{
	0: "email",
	1: "is_locked",
	2: "workspace_role",
}

// Decode decodes BodyUpdateMemberV1WorkspaceMembersPost from json.
func (s *BodyUpdateMemberV1WorkspaceMembersPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdateMemberV1WorkspaceMembersPost to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "is_locked":
			if err := func() error {
				s.IsLocked.Reset()
				if err := s.IsLocked.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_locked\"")
			}
		case "workspace_role":
			if err := func() error {
				s.WorkspaceRole.Reset()
				if err := s.WorkspaceRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdateMemberV1WorkspaceMembersPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyUpdateMemberV1WorkspaceMembersPost) {
					name = jsonFieldsNameOfBodyUpdateMemberV1WorkspaceMembersPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdateMemberV1WorkspaceMembersPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdateMemberV1WorkspaceMembersPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole as json.
func (s BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole from json.
func (s *BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole(v) {
	case BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRoleWorkspaceAdmin:
		*s = BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRoleWorkspaceAdmin
	case BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRoleWorkspaceMember:
		*s = BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRoleWorkspaceMember
	default:
		*s = BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) encodeFields(e *jx.Encoder) {
	{
		if s.Languages.Set {
			e.FieldStart("languages")
			s.Languages.Encode(e)
		}
	}
	{
		if s.SpeakerName.Set {
			e.FieldStart("speaker_name")
			s.SpeakerName.Encode(e)
		}
	}
	{
		if s.VoiceID.Set {
			e.FieldStart("voice_id")
			s.VoiceID.Encode(e)
		}
	}
	{
		if s.VoiceSimilarity.Set {
			e.FieldStart("voice_similarity")
			s.VoiceSimilarity.Encode(e)
		}
	}
	{
		if s.VoiceStability.Set {
			e.FieldStart("voice_stability")
			s.VoiceStability.Encode(e)
		}
	}
	{
		if s.VoiceStyle.Set {
			e.FieldStart("voice_style")
			s.VoiceStyle.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch = [6]string{
	0: "languages",
	1: "speaker_name",
	2: "voice_id",
	3: "voice_similarity",
	4: "voice_stability",
	5: "voice_style",
}

// Decode decodes BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch from json.
func (s *BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "languages":
			if err := func() error {
				s.Languages.Reset()
				if err := s.Languages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages\"")
			}
		case "speaker_name":
			if err := func() error {
				s.SpeakerName.Reset()
				if err := s.SpeakerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_name\"")
			}
		case "voice_id":
			if err := func() error {
				s.VoiceID.Reset()
				if err := s.VoiceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		case "voice_similarity":
			if err := func() error {
				s.VoiceSimilarity.Reset()
				if err := s.VoiceSimilarity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_similarity\"")
			}
		case "voice_stability":
			if err := func() error {
				s.VoiceStability.Reset()
				if err := s.VoiceStability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_stability\"")
			}
		case "voice_style":
			if err := func() error {
				s.VoiceStyle.Reset()
				if err := s.VoiceStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_style\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) encodeFields(e *jx.Encoder) {
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		if s.RemoveBackgroundNoise.Set {
			e.FieldStart("remove_background_noise")
			s.RemoveBackgroundNoise.Encode(e)
		}
	}
	{
		if s.SelectedSpeakerIds.Set {
			e.FieldStart("selected_speaker_ids")
			s.SelectedSpeakerIds.Encode(e)
		}
	}
	{
		if s.TrimEndTime.Set {
			e.FieldStart("trim_end_time")
			s.TrimEndTime.Encode(e)
		}
	}
	{
		if s.TrimStartTime.Set {
			e.FieldStart("trim_start_time")
			s.TrimStartTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost = [5]string{
	0: "file_name",
	1: "remove_background_noise",
	2: "selected_speaker_ids",
	3: "trim_end_time",
	4: "trim_start_time",
}

// Decode decodes BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost from json.
func (s *BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "remove_background_noise":
			if err := func() error {
				s.RemoveBackgroundNoise.Reset()
				if err := s.RemoveBackgroundNoise.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_background_noise\"")
			}
		case "selected_speaker_ids":
			if err := func() error {
				s.SelectedSpeakerIds.Reset()
				if err := s.SelectedSpeakerIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_speaker_ids\"")
			}
		case "trim_end_time":
			if err := func() error {
				s.TrimEndTime.Reset()
				if err := s.TrimEndTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trim_end_time\"")
			}
		case "trim_start_time":
			if err := func() error {
				s.TrimStartTime.Reset()
				if err := s.TrimStartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trim_start_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) encodeFields(e *jx.Encoder) {
	{
		if s.Archived.Set {
			e.FieldStart("archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch = [2]string{
	0: "archived",
	1: "name",
}

// Decode decodes BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch from json.
func (s *BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost) encodeFields(e *jx.Encoder) {
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		e.FieldStart("default_paragraph_voice_id")
		e.Str(s.DefaultParagraphVoiceID)
	}
	{
		e.FieldStart("default_title_voice_id")
		e.Str(s.DefaultTitleVoiceID)
	}
	{
		if s.IsbnNumber.Set {
			e.FieldStart("isbn_number")
			s.IsbnNumber.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.VolumeNormalization.Set {
			e.FieldStart("volume_normalization")
			s.VolumeNormalization.Encode(e)
		}
	}
}

var jsonFieldsNameOfBodyUpdateStudioProjectV1StudioProjectsProjectIDPost = [7]string{
	0: "author",
	1: "default_paragraph_voice_id",
	2: "default_title_voice_id",
	3: "isbn_number",
	4: "name",
	5: "title",
	6: "volume_normalization",
}

// Decode decodes BodyUpdateStudioProjectV1StudioProjectsProjectIDPost from json.
func (s *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdateStudioProjectV1StudioProjectsProjectIDPost to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "default_paragraph_voice_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DefaultParagraphVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_paragraph_voice_id\"")
			}
		case "default_title_voice_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DefaultTitleVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_title_voice_id\"")
			}
		case "isbn_number":
			if err := func() error {
				s.IsbnNumber.Reset()
				if err := s.IsbnNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isbn_number\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "volume_normalization":
			if err := func() error {
				s.VolumeNormalization.Reset()
				if err := s.VolumeNormalization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_normalization\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdateStudioProjectV1StudioProjectsProjectIDPost")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyUpdateStudioProjectV1StudioProjectsProjectIDPost) {
					name = jsonFieldsNameOfBodyUpdateStudioProjectV1StudioProjectsProjectIDPost[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_disabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfBodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch = [2]string{
	0: "is_disabled",
	1: "name",
}

// Decode decodes BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch from json.
func (s *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_disabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_disabled\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch) {
					name = jsonFieldsNameOfBodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleCharacterAnimationModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleCharacterAnimationModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enter_type")
		s.EnterType.Encode(e)
	}
	{
		e.FieldStart("exit_type")
		s.ExitType.Encode(e)
	}
}

var jsonFieldsNameOfCaptionStyleCharacterAnimationModel = [2]string{
	0: "enter_type",
	1: "exit_type",
}

// Decode decodes CaptionStyleCharacterAnimationModel from json.
func (s *CaptionStyleCharacterAnimationModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleCharacterAnimationModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enter_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnterType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enter_type\"")
			}
		case "exit_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ExitType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exit_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleCharacterAnimationModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptionStyleCharacterAnimationModel) {
					name = jsonFieldsNameOfCaptionStyleCharacterAnimationModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleCharacterAnimationModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleCharacterAnimationModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleCharacterAnimationModelEnterType as json.
func (s CaptionStyleCharacterAnimationModelEnterType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleCharacterAnimationModelEnterType from json.
func (s *CaptionStyleCharacterAnimationModelEnterType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleCharacterAnimationModelEnterType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleCharacterAnimationModelEnterType(v) {
	case CaptionStyleCharacterAnimationModelEnterTypeNone:
		*s = CaptionStyleCharacterAnimationModelEnterTypeNone
	case CaptionStyleCharacterAnimationModelEnterTypeFade:
		*s = CaptionStyleCharacterAnimationModelEnterTypeFade
	default:
		*s = CaptionStyleCharacterAnimationModelEnterType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleCharacterAnimationModelEnterType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleCharacterAnimationModelEnterType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleCharacterAnimationModelExitType as json.
func (s CaptionStyleCharacterAnimationModelExitType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleCharacterAnimationModelExitType from json.
func (s *CaptionStyleCharacterAnimationModelExitType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleCharacterAnimationModelExitType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleCharacterAnimationModelExitType(v) {
	case CaptionStyleCharacterAnimationModelExitTypeNone:
		*s = CaptionStyleCharacterAnimationModelExitTypeNone
	case CaptionStyleCharacterAnimationModelExitTypeFade:
		*s = CaptionStyleCharacterAnimationModelExitTypeFade
	default:
		*s = CaptionStyleCharacterAnimationModelExitType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleCharacterAnimationModelExitType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleCharacterAnimationModelExitType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleHorizontalPlacementModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleHorizontalPlacementModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("align")
		s.Align.Encode(e)
	}
	{
		e.FieldStart("translate_pct")
		e.Float64(s.TranslatePct)
	}
}

var jsonFieldsNameOfCaptionStyleHorizontalPlacementModel = [2]string{
	0: "align",
	1: "translate_pct",
}

// Decode decodes CaptionStyleHorizontalPlacementModel from json.
func (s *CaptionStyleHorizontalPlacementModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleHorizontalPlacementModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "align":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Align.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"align\"")
			}
		case "translate_pct":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TranslatePct = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translate_pct\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleHorizontalPlacementModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptionStyleHorizontalPlacementModel) {
					name = jsonFieldsNameOfCaptionStyleHorizontalPlacementModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleHorizontalPlacementModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleHorizontalPlacementModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleHorizontalPlacementModelAlign as json.
func (s CaptionStyleHorizontalPlacementModelAlign) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleHorizontalPlacementModelAlign from json.
func (s *CaptionStyleHorizontalPlacementModelAlign) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleHorizontalPlacementModelAlign to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleHorizontalPlacementModelAlign(v) {
	case CaptionStyleHorizontalPlacementModelAlignLeft:
		*s = CaptionStyleHorizontalPlacementModelAlignLeft
	case CaptionStyleHorizontalPlacementModelAlignCenter:
		*s = CaptionStyleHorizontalPlacementModelAlignCenter
	case CaptionStyleHorizontalPlacementModelAlignRight:
		*s = CaptionStyleHorizontalPlacementModelAlignRight
	default:
		*s = CaptionStyleHorizontalPlacementModelAlign(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleHorizontalPlacementModelAlign) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleHorizontalPlacementModelAlign) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleModel) encodeFields(e *jx.Encoder) {
	{
		if s.AutoBreakEnabled.Set {
			e.FieldStart("auto_break_enabled")
			s.AutoBreakEnabled.Encode(e)
		}
	}
	{
		if s.BackgroundColor.Set {
			e.FieldStart("background_color")
			s.BackgroundColor.Encode(e)
		}
	}
	{
		if s.BackgroundEnabled.Set {
			e.FieldStart("background_enabled")
			s.BackgroundEnabled.Encode(e)
		}
	}
	{
		if s.BackgroundOpacity.Set {
			e.FieldStart("background_opacity")
			s.BackgroundOpacity.Encode(e)
		}
	}
	{
		if s.CharacterAnimation.Set {
			e.FieldStart("character_animation")
			s.CharacterAnimation.Encode(e)
		}
	}
	{
		if s.HorizontalPlacement.Set {
			e.FieldStart("horizontal_placement")
			s.HorizontalPlacement.Encode(e)
		}
	}
	{
		if s.MaxLinesPerSection.Set {
			e.FieldStart("max_lines_per_section")
			s.MaxLinesPerSection.Encode(e)
		}
	}
	{
		if s.MaxWordsPerLine.Set {
			e.FieldStart("max_words_per_line")
			s.MaxWordsPerLine.Encode(e)
		}
	}
	{
		if s.SectionAnimation.Set {
			e.FieldStart("section_animation")
			s.SectionAnimation.Encode(e)
		}
	}
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
	{
		if s.TextAlign.Set {
			e.FieldStart("text_align")
			s.TextAlign.Encode(e)
		}
	}
	{
		if s.TextColor.Set {
			e.FieldStart("text_color")
			s.TextColor.Encode(e)
		}
	}
	{
		if s.TextFont.Set {
			e.FieldStart("text_font")
			s.TextFont.Encode(e)
		}
	}
	{
		if s.TextScale.Set {
			e.FieldStart("text_scale")
			s.TextScale.Encode(e)
		}
	}
	{
		if s.TextStyle.Set {
			e.FieldStart("text_style")
			s.TextStyle.Encode(e)
		}
	}
	{
		if s.TextWeight.Set {
			e.FieldStart("text_weight")
			s.TextWeight.Encode(e)
		}
	}
	{
		if s.VerticalPlacement.Set {
			e.FieldStart("vertical_placement")
			s.VerticalPlacement.Encode(e)
		}
	}
	{
		if s.WidthPct.Set {
			e.FieldStart("width_pct")
			s.WidthPct.Encode(e)
		}
	}
	{
		if s.WordAnimation.Set {
			e.FieldStart("word_animation")
			s.WordAnimation.Encode(e)
		}
	}
	{
		if s.WordHighlightsBackgroundColor.Set {
			e.FieldStart("word_highlights_background_color")
			s.WordHighlightsBackgroundColor.Encode(e)
		}
	}
	{
		if s.WordHighlightsColor.Set {
			e.FieldStart("word_highlights_color")
			s.WordHighlightsColor.Encode(e)
		}
	}
	{
		if s.WordHighlightsEnabled.Set {
			e.FieldStart("word_highlights_enabled")
			s.WordHighlightsEnabled.Encode(e)
		}
	}
	{
		if s.WordHighlightsOpacity.Set {
			e.FieldStart("word_highlights_opacity")
			s.WordHighlightsOpacity.Encode(e)
		}
	}
}

var jsonFieldsNameOfCaptionStyleModel = [23]string{
	0:  "auto_break_enabled",
	1:  "background_color",
	2:  "background_enabled",
	3:  "background_opacity",
	4:  "character_animation",
	5:  "horizontal_placement",
	6:  "max_lines_per_section",
	7:  "max_words_per_line",
	8:  "section_animation",
	9:  "template",
	10: "text_align",
	11: "text_color",
	12: "text_font",
	13: "text_scale",
	14: "text_style",
	15: "text_weight",
	16: "vertical_placement",
	17: "width_pct",
	18: "word_animation",
	19: "word_highlights_background_color",
	20: "word_highlights_color",
	21: "word_highlights_enabled",
	22: "word_highlights_opacity",
}

// Decode decodes CaptionStyleModel from json.
func (s *CaptionStyleModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_break_enabled":
			if err := func() error {
				s.AutoBreakEnabled.Reset()
				if err := s.AutoBreakEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_break_enabled\"")
			}
		case "background_color":
			if err := func() error {
				s.BackgroundColor.Reset()
				if err := s.BackgroundColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background_color\"")
			}
		case "background_enabled":
			if err := func() error {
				s.BackgroundEnabled.Reset()
				if err := s.BackgroundEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background_enabled\"")
			}
		case "background_opacity":
			if err := func() error {
				s.BackgroundOpacity.Reset()
				if err := s.BackgroundOpacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background_opacity\"")
			}
		case "character_animation":
			if err := func() error {
				s.CharacterAnimation.Reset()
				if err := s.CharacterAnimation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_animation\"")
			}
		case "horizontal_placement":
			if err := func() error {
				s.HorizontalPlacement.Reset()
				if err := s.HorizontalPlacement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"horizontal_placement\"")
			}
		case "max_lines_per_section":
			if err := func() error {
				s.MaxLinesPerSection.Reset()
				if err := s.MaxLinesPerSection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_lines_per_section\"")
			}
		case "max_words_per_line":
			if err := func() error {
				s.MaxWordsPerLine.Reset()
				if err := s.MaxWordsPerLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_words_per_line\"")
			}
		case "section_animation":
			if err := func() error {
				s.SectionAnimation.Reset()
				if err := s.SectionAnimation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"section_animation\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "text_align":
			if err := func() error {
				s.TextAlign.Reset()
				if err := s.TextAlign.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_align\"")
			}
		case "text_color":
			if err := func() error {
				s.TextColor.Reset()
				if err := s.TextColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_color\"")
			}
		case "text_font":
			if err := func() error {
				s.TextFont.Reset()
				if err := s.TextFont.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_font\"")
			}
		case "text_scale":
			if err := func() error {
				s.TextScale.Reset()
				if err := s.TextScale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_scale\"")
			}
		case "text_style":
			if err := func() error {
				s.TextStyle.Reset()
				if err := s.TextStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_style\"")
			}
		case "text_weight":
			if err := func() error {
				s.TextWeight.Reset()
				if err := s.TextWeight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_weight\"")
			}
		case "vertical_placement":
			if err := func() error {
				s.VerticalPlacement.Reset()
				if err := s.VerticalPlacement.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vertical_placement\"")
			}
		case "width_pct":
			if err := func() error {
				s.WidthPct.Reset()
				if err := s.WidthPct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"width_pct\"")
			}
		case "word_animation":
			if err := func() error {
				s.WordAnimation.Reset()
				if err := s.WordAnimation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word_animation\"")
			}
		case "word_highlights_background_color":
			if err := func() error {
				s.WordHighlightsBackgroundColor.Reset()
				if err := s.WordHighlightsBackgroundColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word_highlights_background_color\"")
			}
		case "word_highlights_color":
			if err := func() error {
				s.WordHighlightsColor.Reset()
				if err := s.WordHighlightsColor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word_highlights_color\"")
			}
		case "word_highlights_enabled":
			if err := func() error {
				s.WordHighlightsEnabled.Reset()
				if err := s.WordHighlightsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word_highlights_enabled\"")
			}
		case "word_highlights_opacity":
			if err := func() error {
				s.WordHighlightsOpacity.Reset()
				if err := s.WordHighlightsOpacity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word_highlights_opacity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModelTextAlign as json.
func (s CaptionStyleModelTextAlign) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleModelTextAlign from json.
func (s *CaptionStyleModelTextAlign) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleModelTextAlign to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleModelTextAlign(v) {
	case CaptionStyleModelTextAlignStart:
		*s = CaptionStyleModelTextAlignStart
	case CaptionStyleModelTextAlignCenter:
		*s = CaptionStyleModelTextAlignCenter
	case CaptionStyleModelTextAlignEnd:
		*s = CaptionStyleModelTextAlignEnd
	default:
		*s = CaptionStyleModelTextAlign(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleModelTextAlign) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleModelTextAlign) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModelTextStyle as json.
func (s CaptionStyleModelTextStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleModelTextStyle from json.
func (s *CaptionStyleModelTextStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleModelTextStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleModelTextStyle(v) {
	case CaptionStyleModelTextStyleNormal:
		*s = CaptionStyleModelTextStyleNormal
	case CaptionStyleModelTextStyleItalic:
		*s = CaptionStyleModelTextStyleItalic
	default:
		*s = CaptionStyleModelTextStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleModelTextStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleModelTextStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModelTextWeight as json.
func (s CaptionStyleModelTextWeight) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleModelTextWeight from json.
func (s *CaptionStyleModelTextWeight) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleModelTextWeight to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleModelTextWeight(v) {
	case CaptionStyleModelTextWeightNormal:
		*s = CaptionStyleModelTextWeightNormal
	case CaptionStyleModelTextWeightBold:
		*s = CaptionStyleModelTextWeightBold
	default:
		*s = CaptionStyleModelTextWeight(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleModelTextWeight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleModelTextWeight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleSectionAnimationModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleSectionAnimationModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enter_type")
		s.EnterType.Encode(e)
	}
	{
		e.FieldStart("exit_type")
		s.ExitType.Encode(e)
	}
}

var jsonFieldsNameOfCaptionStyleSectionAnimationModel = [2]string{
	0: "enter_type",
	1: "exit_type",
}

// Decode decodes CaptionStyleSectionAnimationModel from json.
func (s *CaptionStyleSectionAnimationModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleSectionAnimationModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enter_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnterType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enter_type\"")
			}
		case "exit_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ExitType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exit_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleSectionAnimationModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptionStyleSectionAnimationModel) {
					name = jsonFieldsNameOfCaptionStyleSectionAnimationModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleSectionAnimationModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleSectionAnimationModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleSectionAnimationModelEnterType as json.
func (s CaptionStyleSectionAnimationModelEnterType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleSectionAnimationModelEnterType from json.
func (s *CaptionStyleSectionAnimationModelEnterType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleSectionAnimationModelEnterType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleSectionAnimationModelEnterType(v) {
	case CaptionStyleSectionAnimationModelEnterTypeNone:
		*s = CaptionStyleSectionAnimationModelEnterTypeNone
	case CaptionStyleSectionAnimationModelEnterTypeFade:
		*s = CaptionStyleSectionAnimationModelEnterTypeFade
	case CaptionStyleSectionAnimationModelEnterTypeScale:
		*s = CaptionStyleSectionAnimationModelEnterTypeScale
	default:
		*s = CaptionStyleSectionAnimationModelEnterType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleSectionAnimationModelEnterType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleSectionAnimationModelEnterType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleSectionAnimationModelExitType as json.
func (s CaptionStyleSectionAnimationModelExitType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleSectionAnimationModelExitType from json.
func (s *CaptionStyleSectionAnimationModelExitType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleSectionAnimationModelExitType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleSectionAnimationModelExitType(v) {
	case CaptionStyleSectionAnimationModelExitTypeNone:
		*s = CaptionStyleSectionAnimationModelExitTypeNone
	case CaptionStyleSectionAnimationModelExitTypeFade:
		*s = CaptionStyleSectionAnimationModelExitTypeFade
	case CaptionStyleSectionAnimationModelExitTypeScale:
		*s = CaptionStyleSectionAnimationModelExitTypeScale
	default:
		*s = CaptionStyleSectionAnimationModelExitType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleSectionAnimationModelExitType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleSectionAnimationModelExitType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleTemplateModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleTemplateModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		if s.RequiresHighFps.Set {
			e.FieldStart("requires_high_fps")
			s.RequiresHighFps.Encode(e)
		}
	}
}

var jsonFieldsNameOfCaptionStyleTemplateModel = [3]string{
	0: "key",
	1: "label",
	2: "requires_high_fps",
}

// Decode decodes CaptionStyleTemplateModel from json.
func (s *CaptionStyleTemplateModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleTemplateModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "requires_high_fps":
			if err := func() error {
				s.RequiresHighFps.Reset()
				if err := s.RequiresHighFps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_high_fps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleTemplateModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptionStyleTemplateModel) {
					name = jsonFieldsNameOfCaptionStyleTemplateModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleTemplateModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleTemplateModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleVerticalPlacementModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleVerticalPlacementModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("align")
		s.Align.Encode(e)
	}
	{
		e.FieldStart("translate_pct")
		e.Float64(s.TranslatePct)
	}
}

var jsonFieldsNameOfCaptionStyleVerticalPlacementModel = [2]string{
	0: "align",
	1: "translate_pct",
}

// Decode decodes CaptionStyleVerticalPlacementModel from json.
func (s *CaptionStyleVerticalPlacementModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleVerticalPlacementModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "align":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Align.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"align\"")
			}
		case "translate_pct":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TranslatePct = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translate_pct\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleVerticalPlacementModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptionStyleVerticalPlacementModel) {
					name = jsonFieldsNameOfCaptionStyleVerticalPlacementModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleVerticalPlacementModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleVerticalPlacementModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleVerticalPlacementModelAlign as json.
func (s CaptionStyleVerticalPlacementModelAlign) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleVerticalPlacementModelAlign from json.
func (s *CaptionStyleVerticalPlacementModelAlign) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleVerticalPlacementModelAlign to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleVerticalPlacementModelAlign(v) {
	case CaptionStyleVerticalPlacementModelAlignTop:
		*s = CaptionStyleVerticalPlacementModelAlignTop
	case CaptionStyleVerticalPlacementModelAlignCenter:
		*s = CaptionStyleVerticalPlacementModelAlignCenter
	case CaptionStyleVerticalPlacementModelAlignBottom:
		*s = CaptionStyleVerticalPlacementModelAlignBottom
	default:
		*s = CaptionStyleVerticalPlacementModelAlign(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleVerticalPlacementModelAlign) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleVerticalPlacementModelAlign) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CaptionStyleWordAnimationModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CaptionStyleWordAnimationModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enter_type")
		s.EnterType.Encode(e)
	}
	{
		e.FieldStart("exit_type")
		s.ExitType.Encode(e)
	}
}

var jsonFieldsNameOfCaptionStyleWordAnimationModel = [2]string{
	0: "enter_type",
	1: "exit_type",
}

// Decode decodes CaptionStyleWordAnimationModel from json.
func (s *CaptionStyleWordAnimationModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleWordAnimationModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enter_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EnterType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enter_type\"")
			}
		case "exit_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ExitType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exit_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CaptionStyleWordAnimationModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCaptionStyleWordAnimationModel) {
					name = jsonFieldsNameOfCaptionStyleWordAnimationModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CaptionStyleWordAnimationModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleWordAnimationModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleWordAnimationModelEnterType as json.
func (s CaptionStyleWordAnimationModelEnterType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleWordAnimationModelEnterType from json.
func (s *CaptionStyleWordAnimationModelEnterType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleWordAnimationModelEnterType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleWordAnimationModelEnterType(v) {
	case CaptionStyleWordAnimationModelEnterTypeNone:
		*s = CaptionStyleWordAnimationModelEnterTypeNone
	case CaptionStyleWordAnimationModelEnterTypeFade:
		*s = CaptionStyleWordAnimationModelEnterTypeFade
	case CaptionStyleWordAnimationModelEnterTypeScale:
		*s = CaptionStyleWordAnimationModelEnterTypeScale
	default:
		*s = CaptionStyleWordAnimationModelEnterType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleWordAnimationModelEnterType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleWordAnimationModelEnterType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleWordAnimationModelExitType as json.
func (s CaptionStyleWordAnimationModelExitType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CaptionStyleWordAnimationModelExitType from json.
func (s *CaptionStyleWordAnimationModelExitType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CaptionStyleWordAnimationModelExitType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CaptionStyleWordAnimationModelExitType(v) {
	case CaptionStyleWordAnimationModelExitTypeNone:
		*s = CaptionStyleWordAnimationModelExitTypeNone
	case CaptionStyleWordAnimationModelExitTypeFade:
		*s = CaptionStyleWordAnimationModelExitTypeFade
	case CaptionStyleWordAnimationModelExitTypeScale:
		*s = CaptionStyleWordAnimationModelExitTypeScale
	default:
		*s = CaptionStyleWordAnimationModelExitType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CaptionStyleWordAnimationModelExitType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CaptionStyleWordAnimationModelExitType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChapterResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChapterResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("can_be_downloaded")
		e.Bool(s.CanBeDownloaded)
	}
	{
		e.FieldStart("chapter_id")
		e.Str(s.ChapterID)
	}
	{
		if s.ConversionProgress.Set {
			e.FieldStart("conversion_progress")
			s.ConversionProgress.Encode(e)
		}
	}
	{
		if s.HasVideo.Set {
			e.FieldStart("has_video")
			s.HasVideo.Encode(e)
		}
	}
	{
		if s.LastConversionDateUnix.Set {
			e.FieldStart("last_conversion_date_unix")
			s.LastConversionDateUnix.Encode(e)
		}
	}
	{
		if s.LastConversionError.Set {
			e.FieldStart("last_conversion_error")
			s.LastConversionError.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.Statistics.Set {
			e.FieldStart("statistics")
			s.Statistics.Encode(e)
		}
	}
	{
		if s.VoiceIds.Set {
			e.FieldStart("voice_ids")
			s.VoiceIds.Encode(e)
		}
	}
}

var jsonFieldsNameOfChapterResponseModel = [10]string{
	0: "can_be_downloaded",
	1: "chapter_id",
	2: "conversion_progress",
	3: "has_video",
	4: "last_conversion_date_unix",
	5: "last_conversion_error",
	6: "name",
	7: "state",
	8: "statistics",
	9: "voice_ids",
}

// Decode decodes ChapterResponseModel from json.
func (s *ChapterResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChapterResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_be_downloaded":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanBeDownloaded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_be_downloaded\"")
			}
		case "chapter_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ChapterID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapter_id\"")
			}
		case "conversion_progress":
			if err := func() error {
				s.ConversionProgress.Reset()
				if err := s.ConversionProgress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversion_progress\"")
			}
		case "has_video":
			if err := func() error {
				s.HasVideo.Reset()
				if err := s.HasVideo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_video\"")
			}
		case "last_conversion_date_unix":
			if err := func() error {
				s.LastConversionDateUnix.Reset()
				if err := s.LastConversionDateUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_conversion_date_unix\"")
			}
		case "last_conversion_error":
			if err := func() error {
				s.LastConversionError.Reset()
				if err := s.LastConversionError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_conversion_error\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "statistics":
			if err := func() error {
				s.Statistics.Reset()
				if err := s.Statistics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statistics\"")
			}
		case "voice_ids":
			if err := func() error {
				s.VoiceIds.Reset()
				if err := s.VoiceIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChapterResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChapterResponseModel) {
					name = jsonFieldsNameOfChapterResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChapterResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChapterResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChapterResponseModelState as json.
func (s ChapterResponseModelState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ChapterResponseModelState from json.
func (s *ChapterResponseModelState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChapterResponseModelState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ChapterResponseModelState(v) {
	case ChapterResponseModelStateDefault:
		*s = ChapterResponseModelStateDefault
	case ChapterResponseModelStateConverting:
		*s = ChapterResponseModelStateConverting
	default:
		*s = ChapterResponseModelState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ChapterResponseModelState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChapterResponseModelState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChapterSnapshotExtendedResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChapterSnapshotExtendedResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chapter_id")
		e.Str(s.ChapterID)
	}
	{
		e.FieldStart("chapter_snapshot_id")
		e.Str(s.ChapterSnapshotID)
	}
	{
		e.FieldStart("character_alignments")
		e.ArrStart()
		for _, elem := range s.CharacterAlignments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
}

var jsonFieldsNameOfChapterSnapshotExtendedResponseModel = [6]string{
	0: "chapter_id",
	1: "chapter_snapshot_id",
	2: "character_alignments",
	3: "created_at_unix",
	4: "name",
	5: "project_id",
}

// Decode decodes ChapterSnapshotExtendedResponseModel from json.
func (s *ChapterSnapshotExtendedResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChapterSnapshotExtendedResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapter_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ChapterID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapter_id\"")
			}
		case "chapter_snapshot_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ChapterSnapshotID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapter_snapshot_id\"")
			}
		case "character_alignments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.CharacterAlignments = make([]CharacterAlignmentModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterAlignmentModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CharacterAlignments = append(s.CharacterAlignments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_alignments\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChapterSnapshotExtendedResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChapterSnapshotExtendedResponseModel) {
					name = jsonFieldsNameOfChapterSnapshotExtendedResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChapterSnapshotExtendedResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChapterSnapshotExtendedResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChapterSnapshotResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChapterSnapshotResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chapter_id")
		e.Str(s.ChapterID)
	}
	{
		e.FieldStart("chapter_snapshot_id")
		e.Str(s.ChapterSnapshotID)
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
}

var jsonFieldsNameOfChapterSnapshotResponseModel = [5]string{
	0: "chapter_id",
	1: "chapter_snapshot_id",
	2: "created_at_unix",
	3: "name",
	4: "project_id",
}

// Decode decodes ChapterSnapshotResponseModel from json.
func (s *ChapterSnapshotResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChapterSnapshotResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapter_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ChapterID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapter_id\"")
			}
		case "chapter_snapshot_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ChapterSnapshotID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapter_snapshot_id\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChapterSnapshotResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChapterSnapshotResponseModel) {
					name = jsonFieldsNameOfChapterSnapshotResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChapterSnapshotResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChapterSnapshotResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChapterSnapshotsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChapterSnapshotsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("snapshots")
		e.ArrStart()
		for _, elem := range s.Snapshots {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfChapterSnapshotsResponseModel = [1]string{
	0: "snapshots",
}

// Decode decodes ChapterSnapshotsResponseModel from json.
func (s *ChapterSnapshotsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChapterSnapshotsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "snapshots":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Snapshots = make([]ChapterSnapshotResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChapterSnapshotResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snapshots = append(s.Snapshots, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshots\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChapterSnapshotsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChapterSnapshotsResponseModel) {
					name = jsonFieldsNameOfChapterSnapshotsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChapterSnapshotsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChapterSnapshotsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChapterStatisticsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChapterStatisticsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("characters_converted")
		e.Int(s.CharactersConverted)
	}
	{
		e.FieldStart("characters_unconverted")
		e.Int(s.CharactersUnconverted)
	}
	{
		e.FieldStart("paragraphs_converted")
		e.Int(s.ParagraphsConverted)
	}
	{
		e.FieldStart("paragraphs_unconverted")
		e.Int(s.ParagraphsUnconverted)
	}
}

var jsonFieldsNameOfChapterStatisticsResponseModel = [4]string{
	0: "characters_converted",
	1: "characters_unconverted",
	2: "paragraphs_converted",
	3: "paragraphs_unconverted",
}

// Decode decodes ChapterStatisticsResponseModel from json.
func (s *ChapterStatisticsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChapterStatisticsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "characters_converted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CharactersConverted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters_converted\"")
			}
		case "characters_unconverted":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CharactersUnconverted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters_unconverted\"")
			}
		case "paragraphs_converted":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ParagraphsConverted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paragraphs_converted\"")
			}
		case "paragraphs_unconverted":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ParagraphsUnconverted = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paragraphs_unconverted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChapterStatisticsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChapterStatisticsResponseModel) {
					name = jsonFieldsNameOfChapterStatisticsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChapterStatisticsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChapterStatisticsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterAlignmentModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterAlignmentModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_end_times_seconds")
		e.ArrStart()
		for _, elem := range s.CharacterEndTimesSeconds {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("character_start_times_seconds")
		e.ArrStart()
		for _, elem := range s.CharacterStartTimesSeconds {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("characters")
		e.ArrStart()
		for _, elem := range s.Characters {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCharacterAlignmentModel = [3]string{
	0: "character_end_times_seconds",
	1: "character_start_times_seconds",
	2: "characters",
}

// Decode decodes CharacterAlignmentModel from json.
func (s *CharacterAlignmentModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterAlignmentModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_end_times_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CharacterEndTimesSeconds = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.CharacterEndTimesSeconds = append(s.CharacterEndTimesSeconds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_end_times_seconds\"")
			}
		case "character_start_times_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CharacterStartTimesSeconds = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.CharacterStartTimesSeconds = append(s.CharacterStartTimesSeconds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_start_times_seconds\"")
			}
		case "characters":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Characters = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Characters = append(s.Characters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterAlignmentModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterAlignmentModel) {
					name = jsonFieldsNameOfCharacterAlignmentModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterAlignmentModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterAlignmentModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CharacterAlignmentResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CharacterAlignmentResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_end_times_seconds")
		e.ArrStart()
		for _, elem := range s.CharacterEndTimesSeconds {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("character_start_times_seconds")
		e.ArrStart()
		for _, elem := range s.CharacterStartTimesSeconds {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("characters")
		e.ArrStart()
		for _, elem := range s.Characters {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCharacterAlignmentResponseModel = [3]string{
	0: "character_end_times_seconds",
	1: "character_start_times_seconds",
	2: "characters",
}

// Decode decodes CharacterAlignmentResponseModel from json.
func (s *CharacterAlignmentResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterAlignmentResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_end_times_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CharacterEndTimesSeconds = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.CharacterEndTimesSeconds = append(s.CharacterEndTimesSeconds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_end_times_seconds\"")
			}
		case "character_start_times_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CharacterStartTimesSeconds = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.CharacterStartTimesSeconds = append(s.CharacterStartTimesSeconds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_start_times_seconds\"")
			}
		case "characters":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Characters = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Characters = append(s.Characters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CharacterAlignmentResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCharacterAlignmentResponseModel) {
					name = jsonFieldsNameOfCharacterAlignmentResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CharacterAlignmentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterAlignmentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterRefreshPeriod as json.
func (s CharacterRefreshPeriod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CharacterRefreshPeriod from json.
func (s *CharacterRefreshPeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CharacterRefreshPeriod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CharacterRefreshPeriod(v) {
	case CharacterRefreshPeriodMonthlyPeriod:
		*s = CharacterRefreshPeriodMonthlyPeriod
	case CharacterRefreshPeriod3MonthPeriod:
		*s = CharacterRefreshPeriod3MonthPeriod
	case CharacterRefreshPeriod6MonthPeriod:
		*s = CharacterRefreshPeriod6MonthPeriod
	case CharacterRefreshPeriodAnnualPeriod:
		*s = CharacterRefreshPeriodAnnualPeriod
	default:
		*s = CharacterRefreshPeriod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CharacterRefreshPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CharacterRefreshPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConvAISecretLocator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConvAISecretLocator) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("secret_id")
		e.Str(s.SecretID)
	}
}

var jsonFieldsNameOfConvAISecretLocator = [1]string{
	0: "secret_id",
}

// Decode decodes ConvAISecretLocator from json.
func (s *ConvAISecretLocator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAISecretLocator to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "secret_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SecretID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConvAISecretLocator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConvAISecretLocator) {
					name = jsonFieldsNameOfConvAISecretLocator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConvAISecretLocator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAISecretLocator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConvAIStoredSecretDependencies) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConvAIStoredSecretDependencies) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agents")
		e.ArrStart()
		for _, elem := range s.Agents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("others")
		e.ArrStart()
		for _, elem := range s.Others {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.PhoneNumbers != nil {
			e.FieldStart("phone_numbers")
			e.ArrStart()
			for _, elem := range s.PhoneNumbers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("tools")
		e.ArrStart()
		for _, elem := range s.Tools {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfConvAIStoredSecretDependencies = [4]string{
	0: "agents",
	1: "others",
	2: "phone_numbers",
	3: "tools",
}

// Decode decodes ConvAIStoredSecretDependencies from json.
func (s *ConvAIStoredSecretDependencies) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAIStoredSecretDependencies to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agents":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Agents = make([]ConvAIStoredSecretDependenciesAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConvAIStoredSecretDependenciesAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Agents = append(s.Agents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agents\"")
			}
		case "others":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Others = make([]SecretDependencyType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SecretDependencyType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Others = append(s.Others, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"others\"")
			}
		case "phone_numbers":
			if err := func() error {
				s.PhoneNumbers = make([]DependentPhoneNumberIdentifier, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DependentPhoneNumberIdentifier
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PhoneNumbers = append(s.PhoneNumbers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_numbers\"")
			}
		case "tools":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Tools = make([]ConvAIStoredSecretDependenciesToolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConvAIStoredSecretDependenciesToolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConvAIStoredSecretDependencies")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConvAIStoredSecretDependencies) {
					name = jsonFieldsNameOfConvAIStoredSecretDependencies[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConvAIStoredSecretDependencies) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAIStoredSecretDependencies) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConvAIStoredSecretDependenciesAgentsItem as json.
func (s ConvAIStoredSecretDependenciesAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConvAIStoredSecretDependenciesAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierConvAIStoredSecretDependenciesAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierConvAIStoredSecretDependenciesAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes ConvAIStoredSecretDependenciesAgentsItem from json.
func (s *ConvAIStoredSecretDependenciesAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAIStoredSecretDependenciesAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierConvAIStoredSecretDependenciesAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierConvAIStoredSecretDependenciesAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierConvAIStoredSecretDependenciesAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierConvAIStoredSecretDependenciesAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConvAIStoredSecretDependenciesAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAIStoredSecretDependenciesAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConvAIStoredSecretDependenciesToolsItem as json.
func (s ConvAIStoredSecretDependenciesToolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConvAIStoredSecretDependenciesToolsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableToolIdentifierConvAIStoredSecretDependenciesToolsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableToolIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	case DependentUnknownToolIdentifierConvAIStoredSecretDependenciesToolsItem:
		e.FieldStart("type")
		e.Str("unknown")
	}
}

// Decode decodes ConvAIStoredSecretDependenciesToolsItem from json.
func (s *ConvAIStoredSecretDependenciesToolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAIStoredSecretDependenciesToolsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableToolIdentifierConvAIStoredSecretDependenciesToolsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownToolIdentifierConvAIStoredSecretDependenciesToolsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableToolIdentifierConvAIStoredSecretDependenciesToolsItem:
		if err := s.DependentAvailableToolIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownToolIdentifierConvAIStoredSecretDependenciesToolsItem:
		if err := s.DependentUnknownToolIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConvAIStoredSecretDependenciesToolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAIStoredSecretDependenciesToolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConvAIWebhooks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConvAIWebhooks) encodeFields(e *jx.Encoder) {
	{
		if s.Events != nil {
			e.FieldStart("events")
			e.ArrStart()
			for _, elem := range s.Events {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PostCallWebhookID.Set {
			e.FieldStart("post_call_webhook_id")
			s.PostCallWebhookID.Encode(e)
		}
	}
	{
		if s.SendAudio.Set {
			e.FieldStart("send_audio")
			s.SendAudio.Encode(e)
		}
	}
}

var jsonFieldsNameOfConvAIWebhooks = [3]string{
	0: "events",
	1: "post_call_webhook_id",
	2: "send_audio",
}

// Decode decodes ConvAIWebhooks from json.
func (s *ConvAIWebhooks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAIWebhooks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "events":
			if err := func() error {
				s.Events = make([]WebhookEventType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WebhookEventType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Events = append(s.Events, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"events\"")
			}
		case "post_call_webhook_id":
			if err := func() error {
				s.PostCallWebhookID.Reset()
				if err := s.PostCallWebhookID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_call_webhook_id\"")
			}
		case "send_audio":
			if err := func() error {
				s.SendAudio.Reset()
				if err := s.SendAudio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"send_audio\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConvAIWebhooks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConvAIWebhooks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAIWebhooks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConvAIWorkspaceStoredSecretConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConvAIWorkspaceStoredSecretConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secret_id")
		e.Str(s.SecretID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("used_by")
		s.UsedBy.Encode(e)
	}
}

var jsonFieldsNameOfConvAIWorkspaceStoredSecretConfig = [4]string{
	0: "name",
	1: "secret_id",
	2: "type",
	3: "used_by",
}

// Decode decodes ConvAIWorkspaceStoredSecretConfig from json.
func (s *ConvAIWorkspaceStoredSecretConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAIWorkspaceStoredSecretConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secret_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "used_by":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.UsedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used_by\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConvAIWorkspaceStoredSecretConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConvAIWorkspaceStoredSecretConfig) {
					name = jsonFieldsNameOfConvAIWorkspaceStoredSecretConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConvAIWorkspaceStoredSecretConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAIWorkspaceStoredSecretConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConvAIWorkspaceStoredSecretConfigType as json.
func (s ConvAIWorkspaceStoredSecretConfigType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConvAIWorkspaceStoredSecretConfigType from json.
func (s *ConvAIWorkspaceStoredSecretConfigType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvAIWorkspaceStoredSecretConfigType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConvAIWorkspaceStoredSecretConfigType(v) {
	case ConvAIWorkspaceStoredSecretConfigTypeStored:
		*s = ConvAIWorkspaceStoredSecretConfigTypeStored
	default:
		*s = ConvAIWorkspaceStoredSecretConfigType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConvAIWorkspaceStoredSecretConfigType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvAIWorkspaceStoredSecretConfigType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationChargingCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationChargingCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.CallCharge.Set {
			e.FieldStart("call_charge")
			s.CallCharge.Encode(e)
		}
	}
	{
		if s.DevDiscount.Set {
			e.FieldStart("dev_discount")
			s.DevDiscount.Encode(e)
		}
	}
	{
		if s.FreeLlmDollarsConsumed.Set {
			e.FieldStart("free_llm_dollars_consumed")
			s.FreeLlmDollarsConsumed.Encode(e)
		}
	}
	{
		if s.FreeMinutesConsumed.Set {
			e.FieldStart("free_minutes_consumed")
			s.FreeMinutesConsumed.Encode(e)
		}
	}
	{
		if s.IsBurst.Set {
			e.FieldStart("is_burst")
			s.IsBurst.Encode(e)
		}
	}
	{
		if s.LlmCharge.Set {
			e.FieldStart("llm_charge")
			s.LlmCharge.Encode(e)
		}
	}
	{
		if s.LlmPrice.Set {
			e.FieldStart("llm_price")
			s.LlmPrice.Encode(e)
		}
	}
	{
		if s.LlmUsage.Set {
			e.FieldStart("llm_usage")
			s.LlmUsage.Encode(e)
		}
	}
	{
		if s.Tier.Set {
			e.FieldStart("tier")
			s.Tier.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationChargingCommonModel = [9]string{
	0: "call_charge",
	1: "dev_discount",
	2: "free_llm_dollars_consumed",
	3: "free_minutes_consumed",
	4: "is_burst",
	5: "llm_charge",
	6: "llm_price",
	7: "llm_usage",
	8: "tier",
}

// Decode decodes ConversationChargingCommonModel from json.
func (s *ConversationChargingCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationChargingCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_charge":
			if err := func() error {
				s.CallCharge.Reset()
				if err := s.CallCharge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_charge\"")
			}
		case "dev_discount":
			if err := func() error {
				s.DevDiscount.Reset()
				if err := s.DevDiscount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dev_discount\"")
			}
		case "free_llm_dollars_consumed":
			if err := func() error {
				s.FreeLlmDollarsConsumed.Reset()
				if err := s.FreeLlmDollarsConsumed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_llm_dollars_consumed\"")
			}
		case "free_minutes_consumed":
			if err := func() error {
				s.FreeMinutesConsumed.Reset()
				if err := s.FreeMinutesConsumed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_minutes_consumed\"")
			}
		case "is_burst":
			if err := func() error {
				s.IsBurst.Reset()
				if err := s.IsBurst.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_burst\"")
			}
		case "llm_charge":
			if err := func() error {
				s.LlmCharge.Reset()
				if err := s.LlmCharge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_charge\"")
			}
		case "llm_price":
			if err := func() error {
				s.LlmPrice.Reset()
				if err := s.LlmPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_price\"")
			}
		case "llm_usage":
			if err := func() error {
				s.LlmUsage.Reset()
				if err := s.LlmUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_usage\"")
			}
		case "tier":
			if err := func() error {
				s.Tier.Reset()
				if err := s.Tier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationChargingCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationChargingCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationChargingCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationConfigClientOverrideInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationConfigClientOverrideInput) encodeFields(e *jx.Encoder) {
	{
		if s.Agent.Set {
			e.FieldStart("agent")
			s.Agent.Encode(e)
		}
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
	{
		if s.Tts.Set {
			e.FieldStart("tts")
			s.Tts.Encode(e)
		}
	}
	{
		if s.Turn.Set {
			e.FieldStart("turn")
			s.Turn.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationConfigClientOverrideInput = [4]string{
	0: "agent",
	1: "conversation",
	2: "tts",
	3: "turn",
}

// Decode decodes ConversationConfigClientOverrideInput from json.
func (s *ConversationConfigClientOverrideInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationConfigClientOverrideInput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent":
			if err := func() error {
				s.Agent.Reset()
				if err := s.Agent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		case "tts":
			if err := func() error {
				s.Tts.Reset()
				if err := s.Tts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tts\"")
			}
		case "turn":
			if err := func() error {
				s.Turn.Reset()
				if err := s.Turn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationConfigClientOverrideInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationConfigClientOverrideInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationConfigClientOverrideInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationConfigClientOverrideOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationConfigClientOverrideOutput) encodeFields(e *jx.Encoder) {
	{
		if s.Agent.Set {
			e.FieldStart("agent")
			s.Agent.Encode(e)
		}
	}
	{
		if s.Conversation.Set {
			e.FieldStart("conversation")
			s.Conversation.Encode(e)
		}
	}
	{
		if s.Tts.Set {
			e.FieldStart("tts")
			s.Tts.Encode(e)
		}
	}
	{
		if s.Turn.Set {
			e.FieldStart("turn")
			s.Turn.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationConfigClientOverrideOutput = [4]string{
	0: "agent",
	1: "conversation",
	2: "tts",
	3: "turn",
}

// Decode decodes ConversationConfigClientOverrideOutput from json.
func (s *ConversationConfigClientOverrideOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationConfigClientOverrideOutput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent":
			if err := func() error {
				s.Agent.Reset()
				if err := s.Agent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent\"")
			}
		case "conversation":
			if err := func() error {
				s.Conversation.Reset()
				if err := s.Conversation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation\"")
			}
		case "tts":
			if err := func() error {
				s.Tts.Reset()
				if err := s.Tts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tts\"")
			}
		case "turn":
			if err := func() error {
				s.Turn.Reset()
				if err := s.Turn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"turn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationConfigClientOverrideOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationConfigClientOverrideOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationConfigClientOverrideOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationConfigOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationConfigOverride) encodeFields(e *jx.Encoder) {
	{
		if s.TextOnly.Set {
			e.FieldStart("text_only")
			s.TextOnly.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationConfigOverride = [1]string{
	0: "text_only",
}

// Decode decodes ConversationConfigOverride from json.
func (s *ConversationConfigOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationConfigOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text_only":
			if err := func() error {
				s.TextOnly.Reset()
				if err := s.TextOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_only\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationConfigOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationDeletionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationDeletionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.DeleteAudio.Set {
			e.FieldStart("delete_audio")
			s.DeleteAudio.Encode(e)
		}
	}
	{
		if s.DeleteTranscriptAndPii.Set {
			e.FieldStart("delete_transcript_and_pii")
			s.DeleteTranscriptAndPii.Encode(e)
		}
	}
	{
		if s.DeletedAudioAtTimeUnixSecs.Set {
			e.FieldStart("deleted_audio_at_time_unix_secs")
			s.DeletedAudioAtTimeUnixSecs.Encode(e)
		}
	}
	{
		if s.DeletedLogsAtTimeUnixSecs.Set {
			e.FieldStart("deleted_logs_at_time_unix_secs")
			s.DeletedLogsAtTimeUnixSecs.Encode(e)
		}
	}
	{
		if s.DeletedTranscriptAtTimeUnixSecs.Set {
			e.FieldStart("deleted_transcript_at_time_unix_secs")
			s.DeletedTranscriptAtTimeUnixSecs.Encode(e)
		}
	}
	{
		if s.DeletionTimeUnixSecs.Set {
			e.FieldStart("deletion_time_unix_secs")
			s.DeletionTimeUnixSecs.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationDeletionSettings = [6]string{
	0: "delete_audio",
	1: "delete_transcript_and_pii",
	2: "deleted_audio_at_time_unix_secs",
	3: "deleted_logs_at_time_unix_secs",
	4: "deleted_transcript_at_time_unix_secs",
	5: "deletion_time_unix_secs",
}

// Decode decodes ConversationDeletionSettings from json.
func (s *ConversationDeletionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationDeletionSettings to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "delete_audio":
			if err := func() error {
				s.DeleteAudio.Reset()
				if err := s.DeleteAudio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_audio\"")
			}
		case "delete_transcript_and_pii":
			if err := func() error {
				s.DeleteTranscriptAndPii.Reset()
				if err := s.DeleteTranscriptAndPii.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete_transcript_and_pii\"")
			}
		case "deleted_audio_at_time_unix_secs":
			if err := func() error {
				s.DeletedAudioAtTimeUnixSecs.Reset()
				if err := s.DeletedAudioAtTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_audio_at_time_unix_secs\"")
			}
		case "deleted_logs_at_time_unix_secs":
			if err := func() error {
				s.DeletedLogsAtTimeUnixSecs.Reset()
				if err := s.DeletedLogsAtTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_logs_at_time_unix_secs\"")
			}
		case "deleted_transcript_at_time_unix_secs":
			if err := func() error {
				s.DeletedTranscriptAtTimeUnixSecs.Reset()
				if err := s.DeletedTranscriptAtTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted_transcript_at_time_unix_secs\"")
			}
		case "deletion_time_unix_secs":
			if err := func() error {
				s.DeletionTimeUnixSecs.Reset()
				if err := s.DeletionTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletion_time_unix_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationDeletionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationDeletionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationDeletionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationFeedbackRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationFeedbackRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.Feedback.Set {
			e.FieldStart("feedback")
			s.Feedback.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationFeedbackRequestModel = [1]string{
	0: "feedback",
}

// Decode decodes ConversationFeedbackRequestModel from json.
func (s *ConversationFeedbackRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationFeedbackRequestModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "feedback":
			if err := func() error {
				s.Feedback.Reset()
				if err := s.Feedback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationFeedbackRequestModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationFeedbackRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationFeedbackRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationFeedbackType as json.
func (s ConversationFeedbackType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationFeedbackType from json.
func (s *ConversationFeedbackType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationFeedbackType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationFeedbackType(v) {
	case ConversationFeedbackTypeThumbs:
		*s = ConversationFeedbackTypeThumbs
	case ConversationFeedbackTypeRating:
		*s = ConversationFeedbackTypeRating
	default:
		*s = ConversationFeedbackType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationFeedbackType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationFeedbackType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryAnalysisCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryAnalysisCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("call_successful")
		s.CallSuccessful.Encode(e)
	}
	{
		if s.CallSummaryTitle.Set {
			e.FieldStart("call_summary_title")
			s.CallSummaryTitle.Encode(e)
		}
	}
	{
		if s.DataCollectionResults.Set {
			e.FieldStart("data_collection_results")
			s.DataCollectionResults.Encode(e)
		}
	}
	{
		if s.EvaluationCriteriaResults.Set {
			e.FieldStart("evaluation_criteria_results")
			s.EvaluationCriteriaResults.Encode(e)
		}
	}
	{
		e.FieldStart("transcript_summary")
		e.Str(s.TranscriptSummary)
	}
}

var jsonFieldsNameOfConversationHistoryAnalysisCommonModel = [5]string{
	0: "call_successful",
	1: "call_summary_title",
	2: "data_collection_results",
	3: "evaluation_criteria_results",
	4: "transcript_summary",
}

// Decode decodes ConversationHistoryAnalysisCommonModel from json.
func (s *ConversationHistoryAnalysisCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryAnalysisCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "call_successful":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CallSuccessful.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_successful\"")
			}
		case "call_summary_title":
			if err := func() error {
				s.CallSummaryTitle.Reset()
				if err := s.CallSummaryTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_summary_title\"")
			}
		case "data_collection_results":
			if err := func() error {
				s.DataCollectionResults.Reset()
				if err := s.DataCollectionResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_collection_results\"")
			}
		case "evaluation_criteria_results":
			if err := func() error {
				s.EvaluationCriteriaResults.Reset()
				if err := s.EvaluationCriteriaResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluation_criteria_results\"")
			}
		case "transcript_summary":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TranscriptSummary = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcript_summary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryAnalysisCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryAnalysisCommonModel) {
					name = jsonFieldsNameOfConversationHistoryAnalysisCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryAnalysisCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryAnalysisCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationHistoryAnalysisCommonModelDataCollectionResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationHistoryAnalysisCommonModelDataCollectionResults) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationHistoryAnalysisCommonModelDataCollectionResults from json.
func (s *ConversationHistoryAnalysisCommonModelDataCollectionResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryAnalysisCommonModelDataCollectionResults to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DataCollectionResultCommonModel
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryAnalysisCommonModelDataCollectionResults")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryAnalysisCommonModelDataCollectionResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryAnalysisCommonModelDataCollectionResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults from json.
func (s *ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ConversationHistoryEvaluationCriteriaResultCommonModel
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryBatchCallModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryBatchCallModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("batch_call_id")
		e.Str(s.BatchCallID)
	}
	{
		e.FieldStart("batch_call_recipient_id")
		e.Str(s.BatchCallRecipientID)
	}
}

var jsonFieldsNameOfConversationHistoryBatchCallModel = [2]string{
	0: "batch_call_id",
	1: "batch_call_recipient_id",
}

// Decode decodes ConversationHistoryBatchCallModel from json.
func (s *ConversationHistoryBatchCallModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryBatchCallModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "batch_call_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BatchCallID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_call_id\"")
			}
		case "batch_call_recipient_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.BatchCallRecipientID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_call_recipient_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryBatchCallModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryBatchCallModel) {
					name = jsonFieldsNameOfConversationHistoryBatchCallModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryBatchCallModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryBatchCallModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryElevenAssistantCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryElevenAssistantCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.IsElevenAssistant.Set {
			e.FieldStart("is_eleven_assistant")
			s.IsElevenAssistant.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryElevenAssistantCommonModel = [1]string{
	0: "is_eleven_assistant",
}

// Decode decodes ConversationHistoryElevenAssistantCommonModel from json.
func (s *ConversationHistoryElevenAssistantCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryElevenAssistantCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_eleven_assistant":
			if err := func() error {
				s.IsElevenAssistant.Reset()
				if err := s.IsElevenAssistant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_eleven_assistant\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryElevenAssistantCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryElevenAssistantCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryElevenAssistantCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryErrorCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryErrorCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryErrorCommonModel = [2]string{
	0: "code",
	1: "reason",
}

// Decode decodes ConversationHistoryErrorCommonModel from json.
func (s *ConversationHistoryErrorCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryErrorCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryErrorCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryErrorCommonModel) {
					name = jsonFieldsNameOfConversationHistoryErrorCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryErrorCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryErrorCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryEvaluationCriteriaResultCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryEvaluationCriteriaResultCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("criteria_id")
		e.Str(s.CriteriaID)
	}
	{
		e.FieldStart("rationale")
		e.Str(s.Rationale)
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryEvaluationCriteriaResultCommonModel = [3]string{
	0: "criteria_id",
	1: "rationale",
	2: "result",
}

// Decode decodes ConversationHistoryEvaluationCriteriaResultCommonModel from json.
func (s *ConversationHistoryEvaluationCriteriaResultCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryEvaluationCriteriaResultCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "criteria_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CriteriaID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criteria_id\"")
			}
		case "rationale":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Rationale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryEvaluationCriteriaResultCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryEvaluationCriteriaResultCommonModel) {
					name = jsonFieldsNameOfConversationHistoryEvaluationCriteriaResultCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryEvaluationCriteriaResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryEvaluationCriteriaResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryFeedbackCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryFeedbackCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.Comment.Set {
			e.FieldStart("comment")
			s.Comment.Encode(e)
		}
	}
	{
		if s.Dislikes.Set {
			e.FieldStart("dislikes")
			s.Dislikes.Encode(e)
		}
	}
	{
		if s.Likes.Set {
			e.FieldStart("likes")
			s.Likes.Encode(e)
		}
	}
	{
		if s.OverallScore.Set {
			e.FieldStart("overall_score")
			s.OverallScore.Encode(e)
		}
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryFeedbackCommonModel = [6]string{
	0: "comment",
	1: "dislikes",
	2: "likes",
	3: "overall_score",
	4: "rating",
	5: "type",
}

// Decode decodes ConversationHistoryFeedbackCommonModel from json.
func (s *ConversationHistoryFeedbackCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryFeedbackCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comment":
			if err := func() error {
				s.Comment.Reset()
				if err := s.Comment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comment\"")
			}
		case "dislikes":
			if err := func() error {
				s.Dislikes.Reset()
				if err := s.Dislikes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dislikes\"")
			}
		case "likes":
			if err := func() error {
				s.Likes.Reset()
				if err := s.Likes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"likes\"")
			}
		case "overall_score":
			if err := func() error {
				s.OverallScore.Reset()
				if err := s.OverallScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overall_score\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryFeedbackCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryFeedbackCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryFeedbackCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryMetadataCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryMetadataCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.AcceptedTimeUnixSecs.Set {
			e.FieldStart("accepted_time_unix_secs")
			s.AcceptedTimeUnixSecs.Encode(e)
		}
	}
	{
		if s.AgentCreatedFrom.Set {
			e.FieldStart("agent_created_from")
			s.AgentCreatedFrom.Encode(e)
		}
	}
	{
		if s.AgentLastUpdatedFrom.Set {
			e.FieldStart("agent_last_updated_from")
			s.AgentLastUpdatedFrom.Encode(e)
		}
	}
	{
		if s.AsyncMetadata.Set {
			e.FieldStart("async_metadata")
			s.AsyncMetadata.Encode(e)
		}
	}
	{
		if s.AuthorizationMethod.Set {
			e.FieldStart("authorization_method")
			s.AuthorizationMethod.Encode(e)
		}
	}
	{
		if s.BatchCall.Set {
			e.FieldStart("batch_call")
			s.BatchCall.Encode(e)
		}
	}
	{
		e.FieldStart("call_duration_secs")
		e.Int(s.CallDurationSecs)
	}
	{
		if s.Charging.Set {
			e.FieldStart("charging")
			s.Charging.Encode(e)
		}
	}
	{
		if s.ConversationInitiationSource.Set {
			e.FieldStart("conversation_initiation_source")
			s.ConversationInitiationSource.Encode(e)
		}
	}
	{
		if s.ConversationInitiationSourceVersion.Set {
			e.FieldStart("conversation_initiation_source_version")
			s.ConversationInitiationSourceVersion.Encode(e)
		}
	}
	{
		if s.Cost.Set {
			e.FieldStart("cost")
			s.Cost.Encode(e)
		}
	}
	{
		if s.DeletionSettings.Set {
			e.FieldStart("deletion_settings")
			s.DeletionSettings.Encode(e)
		}
	}
	{
		if s.ElevenAssistant.Set {
			e.FieldStart("eleven_assistant")
			s.ElevenAssistant.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.FeaturesUsage.Set {
			e.FieldStart("features_usage")
			s.FeaturesUsage.Encode(e)
		}
	}
	{
		if s.Feedback.Set {
			e.FieldStart("feedback")
			s.Feedback.Encode(e)
		}
	}
	{
		if s.InitiationTrigger.Set {
			e.FieldStart("initiation_trigger")
			s.InitiationTrigger.Encode(e)
		}
	}
	{
		if s.InitiatorID.Set {
			e.FieldStart("initiator_id")
			s.InitiatorID.Encode(e)
		}
	}
	{
		if s.MainLanguage.Set {
			e.FieldStart("main_language")
			s.MainLanguage.Encode(e)
		}
	}
	{
		if s.PhoneCall.Set {
			e.FieldStart("phone_call")
			s.PhoneCall.Encode(e)
		}
	}
	{
		if s.RagUsage.Set {
			e.FieldStart("rag_usage")
			s.RagUsage.Encode(e)
		}
	}
	{
		e.FieldStart("start_time_unix_secs")
		e.Int(s.StartTimeUnixSecs)
	}
	{
		if s.TerminationReason.Set {
			e.FieldStart("termination_reason")
			s.TerminationReason.Encode(e)
		}
	}
	{
		if s.TextOnly.Set {
			e.FieldStart("text_only")
			s.TextOnly.Encode(e)
		}
	}
	{
		if s.Timezone.Set {
			e.FieldStart("timezone")
			s.Timezone.Encode(e)
		}
	}
	{
		if s.Warnings != nil {
			e.FieldStart("warnings")
			e.ArrStart()
			for _, elem := range s.Warnings {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Whatsapp.Set {
			e.FieldStart("whatsapp")
			s.Whatsapp.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryMetadataCommonModel = [27]string{
	0:  "accepted_time_unix_secs",
	1:  "agent_created_from",
	2:  "agent_last_updated_from",
	3:  "async_metadata",
	4:  "authorization_method",
	5:  "batch_call",
	6:  "call_duration_secs",
	7:  "charging",
	8:  "conversation_initiation_source",
	9:  "conversation_initiation_source_version",
	10: "cost",
	11: "deletion_settings",
	12: "eleven_assistant",
	13: "error",
	14: "features_usage",
	15: "feedback",
	16: "initiation_trigger",
	17: "initiator_id",
	18: "main_language",
	19: "phone_call",
	20: "rag_usage",
	21: "start_time_unix_secs",
	22: "termination_reason",
	23: "text_only",
	24: "timezone",
	25: "warnings",
	26: "whatsapp",
}

// Decode decodes ConversationHistoryMetadataCommonModel from json.
func (s *ConversationHistoryMetadataCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryMetadataCommonModel to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accepted_time_unix_secs":
			if err := func() error {
				s.AcceptedTimeUnixSecs.Reset()
				if err := s.AcceptedTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accepted_time_unix_secs\"")
			}
		case "agent_created_from":
			if err := func() error {
				s.AgentCreatedFrom.Reset()
				if err := s.AgentCreatedFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_created_from\"")
			}
		case "agent_last_updated_from":
			if err := func() error {
				s.AgentLastUpdatedFrom.Reset()
				if err := s.AgentLastUpdatedFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_last_updated_from\"")
			}
		case "async_metadata":
			if err := func() error {
				s.AsyncMetadata.Reset()
				if err := s.AsyncMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"async_metadata\"")
			}
		case "authorization_method":
			if err := func() error {
				s.AuthorizationMethod.Reset()
				if err := s.AuthorizationMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorization_method\"")
			}
		case "batch_call":
			if err := func() error {
				s.BatchCall.Reset()
				if err := s.BatchCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_call\"")
			}
		case "call_duration_secs":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.CallDurationSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_duration_secs\"")
			}
		case "charging":
			if err := func() error {
				s.Charging.Reset()
				if err := s.Charging.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"charging\"")
			}
		case "conversation_initiation_source":
			if err := func() error {
				s.ConversationInitiationSource.Reset()
				if err := s.ConversationInitiationSource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_source\"")
			}
		case "conversation_initiation_source_version":
			if err := func() error {
				s.ConversationInitiationSourceVersion.Reset()
				if err := s.ConversationInitiationSourceVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_source_version\"")
			}
		case "cost":
			if err := func() error {
				s.Cost.Reset()
				if err := s.Cost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cost\"")
			}
		case "deletion_settings":
			if err := func() error {
				s.DeletionSettings.Reset()
				if err := s.DeletionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletion_settings\"")
			}
		case "eleven_assistant":
			if err := func() error {
				s.ElevenAssistant.Reset()
				if err := s.ElevenAssistant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eleven_assistant\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "features_usage":
			if err := func() error {
				s.FeaturesUsage.Reset()
				if err := s.FeaturesUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"features_usage\"")
			}
		case "feedback":
			if err := func() error {
				s.Feedback.Reset()
				if err := s.Feedback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback\"")
			}
		case "initiation_trigger":
			if err := func() error {
				s.InitiationTrigger.Reset()
				if err := s.InitiationTrigger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiation_trigger\"")
			}
		case "initiator_id":
			if err := func() error {
				s.InitiatorID.Reset()
				if err := s.InitiatorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiator_id\"")
			}
		case "main_language":
			if err := func() error {
				s.MainLanguage.Reset()
				if err := s.MainLanguage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"main_language\"")
			}
		case "phone_call":
			if err := func() error {
				s.PhoneCall.Reset()
				if err := s.PhoneCall.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_call\"")
			}
		case "rag_usage":
			if err := func() error {
				s.RagUsage.Reset()
				if err := s.RagUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_usage\"")
			}
		case "start_time_unix_secs":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.StartTimeUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time_unix_secs\"")
			}
		case "termination_reason":
			if err := func() error {
				s.TerminationReason.Reset()
				if err := s.TerminationReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination_reason\"")
			}
		case "text_only":
			if err := func() error {
				s.TextOnly.Reset()
				if err := s.TextOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text_only\"")
			}
		case "timezone":
			if err := func() error {
				s.Timezone.Reset()
				if err := s.Timezone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timezone\"")
			}
		case "warnings":
			if err := func() error {
				s.Warnings = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Warnings = append(s.Warnings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"warnings\"")
			}
		case "whatsapp":
			if err := func() error {
				s.Whatsapp.Reset()
				if err := s.Whatsapp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryMetadataCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01000000,
		0b00000000,
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryMetadataCommonModel) {
					name = jsonFieldsNameOfConversationHistoryMetadataCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryMetadataCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryMetadataCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryMetadataCommonModelInitiationTrigger as json.
func (s ConversationHistoryMetadataCommonModelInitiationTrigger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConversationHistoryMetadataCommonModelInitiationTrigger) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DefaultConversationInitiationTriggerConversationHistoryMetadataCommonModelInitiationTrigger:
		e.FieldStart("trigger_type")
		e.Str("default")
	case ZendeskConversationInitiationTriggerConversationHistoryMetadataCommonModelInitiationTrigger:
		e.FieldStart("trigger_type")
		e.Str("zendesk")
		{
			s := s.ZendeskConversationInitiationTrigger
			{
				e.FieldStart("ticket_id")
				e.Int(s.TicketID)
			}
		}
	}
}

// Decode decodes ConversationHistoryMetadataCommonModelInitiationTrigger from json.
func (s *ConversationHistoryMetadataCommonModelInitiationTrigger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryMetadataCommonModelInitiationTrigger to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "trigger_type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "default":
					s.Type = DefaultConversationInitiationTriggerConversationHistoryMetadataCommonModelInitiationTrigger
					found = true
				case "zendesk":
					s.Type = ZendeskConversationInitiationTriggerConversationHistoryMetadataCommonModelInitiationTrigger
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefaultConversationInitiationTriggerConversationHistoryMetadataCommonModelInitiationTrigger:
		if err := s.DefaultConversationInitiationTrigger.Decode(d); err != nil {
			return err
		}
	case ZendeskConversationInitiationTriggerConversationHistoryMetadataCommonModelInitiationTrigger:
		if err := s.ZendeskConversationInitiationTrigger.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryMetadataCommonModelInitiationTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryMetadataCommonModelInitiationTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryMetadataCommonModelPhoneCall as json.
func (s ConversationHistoryMetadataCommonModelPhoneCall) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConversationHistoryMetadataCommonModelPhoneCall) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTwilioPhoneCallModelConversationHistoryMetadataCommonModelPhoneCall:
		e.FieldStart("type")
		e.Str("twilio")
		{
			s := s.ConversationHistoryTwilioPhoneCallModel
			{
				e.FieldStart("agent_number")
				e.Str(s.AgentNumber)
			}
			{
				e.FieldStart("call_sid")
				e.Str(s.CallSid)
			}
			{
				e.FieldStart("direction")
				s.Direction.Encode(e)
			}
			{
				e.FieldStart("external_number")
				e.Str(s.ExternalNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				e.FieldStart("stream_sid")
				e.Str(s.StreamSid)
			}
		}
	case ConversationHistorySIPTrunkingPhoneCallModelConversationHistoryMetadataCommonModelPhoneCall:
		e.FieldStart("type")
		e.Str("sip_trunking")
		{
			s := s.ConversationHistorySIPTrunkingPhoneCallModel
			{
				e.FieldStart("agent_number")
				e.Str(s.AgentNumber)
			}
			{
				e.FieldStart("call_sid")
				e.Str(s.CallSid)
			}
			{
				e.FieldStart("direction")
				s.Direction.Encode(e)
			}
			{
				e.FieldStart("external_number")
				e.Str(s.ExternalNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
		}
	}
}

// Decode decodes ConversationHistoryMetadataCommonModelPhoneCall from json.
func (s *ConversationHistoryMetadataCommonModelPhoneCall) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryMetadataCommonModelPhoneCall to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "twilio":
					s.Type = ConversationHistoryTwilioPhoneCallModelConversationHistoryMetadataCommonModelPhoneCall
					found = true
				case "sip_trunking":
					s.Type = ConversationHistorySIPTrunkingPhoneCallModelConversationHistoryMetadataCommonModelPhoneCall
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ConversationHistoryTwilioPhoneCallModelConversationHistoryMetadataCommonModelPhoneCall:
		if err := s.ConversationHistoryTwilioPhoneCallModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistorySIPTrunkingPhoneCallModelConversationHistoryMetadataCommonModelPhoneCall:
		if err := s.ConversationHistorySIPTrunkingPhoneCallModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryMetadataCommonModelPhoneCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryMetadataCommonModelPhoneCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryMultivoiceMessageModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryMultivoiceMessageModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("parts")
		e.ArrStart()
		for _, elem := range s.Parts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfConversationHistoryMultivoiceMessageModel = [1]string{
	0: "parts",
}

// Decode decodes ConversationHistoryMultivoiceMessageModel from json.
func (s *ConversationHistoryMultivoiceMessageModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryMultivoiceMessageModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Parts = make([]ConversationHistoryMultivoiceMessagePartModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryMultivoiceMessagePartModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parts = append(s.Parts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryMultivoiceMessageModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryMultivoiceMessageModel) {
					name = jsonFieldsNameOfConversationHistoryMultivoiceMessageModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryMultivoiceMessageModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryMultivoiceMessageModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryMultivoiceMessagePartModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryMultivoiceMessagePartModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("time_in_call_secs")
		s.TimeInCallSecs.Encode(e)
	}
	{
		e.FieldStart("voice_label")
		s.VoiceLabel.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryMultivoiceMessagePartModel = [3]string{
	0: "text",
	1: "time_in_call_secs",
	2: "voice_label",
}

// Decode decodes ConversationHistoryMultivoiceMessagePartModel from json.
func (s *ConversationHistoryMultivoiceMessagePartModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryMultivoiceMessagePartModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "time_in_call_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TimeInCallSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_in_call_secs\"")
			}
		case "voice_label":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.VoiceLabel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_label\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryMultivoiceMessagePartModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryMultivoiceMessagePartModel) {
					name = jsonFieldsNameOfConversationHistoryMultivoiceMessagePartModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryMultivoiceMessagePartModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryMultivoiceMessagePartModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryRagUsageCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryRagUsageCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("embedding_model")
		e.Str(s.EmbeddingModel)
	}
	{
		e.FieldStart("usage_count")
		e.Int(s.UsageCount)
	}
}

var jsonFieldsNameOfConversationHistoryRagUsageCommonModel = [2]string{
	0: "embedding_model",
	1: "usage_count",
}

// Decode decodes ConversationHistoryRagUsageCommonModel from json.
func (s *ConversationHistoryRagUsageCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryRagUsageCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "embedding_model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EmbeddingModel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"embedding_model\"")
			}
		case "usage_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UsageCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryRagUsageCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryRagUsageCommonModel) {
					name = jsonFieldsNameOfConversationHistoryRagUsageCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryRagUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryRagUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistorySIPTrunkingPhoneCallModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistorySIPTrunkingPhoneCallModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_number")
		e.Str(s.AgentNumber)
	}
	{
		e.FieldStart("call_sid")
		e.Str(s.CallSid)
	}
	{
		e.FieldStart("direction")
		s.Direction.Encode(e)
	}
	{
		e.FieldStart("external_number")
		e.Str(s.ExternalNumber)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistorySIPTrunkingPhoneCallModel = [6]string{
	0: "agent_number",
	1: "call_sid",
	2: "direction",
	3: "external_number",
	4: "phone_number_id",
	5: "type",
}

// Decode decodes ConversationHistorySIPTrunkingPhoneCallModel from json.
func (s *ConversationHistorySIPTrunkingPhoneCallModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistorySIPTrunkingPhoneCallModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_number\"")
			}
		case "call_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "direction":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "external_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExternalNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_number\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistorySIPTrunkingPhoneCallModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistorySIPTrunkingPhoneCallModel) {
					name = jsonFieldsNameOfConversationHistorySIPTrunkingPhoneCallModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistorySIPTrunkingPhoneCallModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistorySIPTrunkingPhoneCallModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistorySIPTrunkingPhoneCallModelDirection as json.
func (s ConversationHistorySIPTrunkingPhoneCallModelDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistorySIPTrunkingPhoneCallModelDirection from json.
func (s *ConversationHistorySIPTrunkingPhoneCallModelDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistorySIPTrunkingPhoneCallModelDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistorySIPTrunkingPhoneCallModelDirection(v) {
	case ConversationHistorySIPTrunkingPhoneCallModelDirectionInbound:
		*s = ConversationHistorySIPTrunkingPhoneCallModelDirectionInbound
	case ConversationHistorySIPTrunkingPhoneCallModelDirectionOutbound:
		*s = ConversationHistorySIPTrunkingPhoneCallModelDirectionOutbound
	default:
		*s = ConversationHistorySIPTrunkingPhoneCallModelDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistorySIPTrunkingPhoneCallModelDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistorySIPTrunkingPhoneCallModelDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistorySIPTrunkingPhoneCallModelType as json.
func (s ConversationHistorySIPTrunkingPhoneCallModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistorySIPTrunkingPhoneCallModelType from json.
func (s *ConversationHistorySIPTrunkingPhoneCallModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistorySIPTrunkingPhoneCallModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistorySIPTrunkingPhoneCallModelType(v) {
	case ConversationHistorySIPTrunkingPhoneCallModelTypeSipTrunking:
		*s = ConversationHistorySIPTrunkingPhoneCallModelTypeSipTrunking
	default:
		*s = ConversationHistorySIPTrunkingPhoneCallModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistorySIPTrunkingPhoneCallModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistorySIPTrunkingPhoneCallModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("credential_id")
		e.Str(s.CredentialID)
	}
	{
		if s.DynamicVariableUpdates != nil {
			e.FieldStart("dynamic_variable_updates")
			e.ArrStart()
			for _, elem := range s.DynamicVariableUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("integration_connection_id")
		e.Str(s.IntegrationConnectionID)
	}
	{
		e.FieldStart("integration_id")
		e.Str(s.IntegrationID)
	}
	{
		e.FieldStart("is_error")
		e.Bool(s.IsError)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		e.FieldStart("result_value")
		e.Str(s.ResultValue)
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		if s.ToolLatencySecs.Set {
			e.FieldStart("tool_latency_secs")
			s.ToolLatencySecs.Encode(e)
		}
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel = [11]string{
	0:  "credential_id",
	1:  "dynamic_variable_updates",
	2:  "integration_connection_id",
	3:  "integration_id",
	4:  "is_error",
	5:  "request_id",
	6:  "result_value",
	7:  "tool_has_been_called",
	8:  "tool_latency_secs",
	9:  "tool_name",
	10: "type",
}

// Decode decodes ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel from json.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credential_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CredentialID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_id\"")
			}
		case "dynamic_variable_updates":
			if err := func() error {
				s.DynamicVariableUpdates = make([]DynamicVariableUpdateCommonModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DynamicVariableUpdateCommonModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DynamicVariableUpdates = append(s.DynamicVariableUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable_updates\"")
			}
		case "integration_connection_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IntegrationConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_connection_id\"")
			}
		case "integration_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IntegrationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_id\"")
			}
		case "is_error":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsError = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_error\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "result_value":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ResultValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_value\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_latency_secs":
			if err := func() error {
				s.ToolLatencySecs.Reset()
				if err := s.ToolLatencySecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_latency_secs\"")
			}
		case "tool_name":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111101,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel) {
					name = jsonFieldsNameOfConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType as json.
func (s ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType from json.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType(v) {
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelTypeAPIIntegrationWebhook:
		*s = ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelTypeAPIIntegrationWebhook
	default:
		*s = ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptCommonModelInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptCommonModelInput) encodeFields(e *jx.Encoder) {
	{
		if s.AgentMetadata.Set {
			e.FieldStart("agent_metadata")
			s.AgentMetadata.Encode(e)
		}
	}
	{
		if s.ConversationTurnMetrics.Set {
			e.FieldStart("conversation_turn_metrics")
			s.ConversationTurnMetrics.Encode(e)
		}
	}
	{
		if s.Feedback.Set {
			e.FieldStart("feedback")
			s.Feedback.Encode(e)
		}
	}
	{
		if s.Interrupted.Set {
			e.FieldStart("interrupted")
			s.Interrupted.Encode(e)
		}
	}
	{
		if s.LlmOverride.Set {
			e.FieldStart("llm_override")
			s.LlmOverride.Encode(e)
		}
	}
	{
		if s.LlmUsage.Set {
			e.FieldStart("llm_usage")
			s.LlmUsage.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.MultivoiceMessage.Set {
			e.FieldStart("multivoice_message")
			s.MultivoiceMessage.Encode(e)
		}
	}
	{
		if s.OriginalMessage.Set {
			e.FieldStart("original_message")
			s.OriginalMessage.Encode(e)
		}
	}
	{
		if s.RagRetrievalInfo.Set {
			e.FieldStart("rag_retrieval_info")
			s.RagRetrievalInfo.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.SourceMedium.Set {
			e.FieldStart("source_medium")
			s.SourceMedium.Encode(e)
		}
	}
	{
		e.FieldStart("time_in_call_secs")
		e.Int(s.TimeInCallSecs)
	}
	{
		if s.ToolCalls != nil {
			e.FieldStart("tool_calls")
			e.ArrStart()
			for _, elem := range s.ToolCalls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ToolResults != nil {
			e.FieldStart("tool_results")
			e.ArrStart()
			for _, elem := range s.ToolResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptCommonModelInput = [15]string{
	0:  "agent_metadata",
	1:  "conversation_turn_metrics",
	2:  "feedback",
	3:  "interrupted",
	4:  "llm_override",
	5:  "llm_usage",
	6:  "message",
	7:  "multivoice_message",
	8:  "original_message",
	9:  "rag_retrieval_info",
	10: "role",
	11: "source_medium",
	12: "time_in_call_secs",
	13: "tool_calls",
	14: "tool_results",
}

// Decode decodes ConversationHistoryTranscriptCommonModelInput from json.
func (s *ConversationHistoryTranscriptCommonModelInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelInput to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_metadata":
			if err := func() error {
				s.AgentMetadata.Reset()
				if err := s.AgentMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_metadata\"")
			}
		case "conversation_turn_metrics":
			if err := func() error {
				s.ConversationTurnMetrics.Reset()
				if err := s.ConversationTurnMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_turn_metrics\"")
			}
		case "feedback":
			if err := func() error {
				s.Feedback.Reset()
				if err := s.Feedback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback\"")
			}
		case "interrupted":
			if err := func() error {
				s.Interrupted.Reset()
				if err := s.Interrupted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interrupted\"")
			}
		case "llm_override":
			if err := func() error {
				s.LlmOverride.Reset()
				if err := s.LlmOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_override\"")
			}
		case "llm_usage":
			if err := func() error {
				s.LlmUsage.Reset()
				if err := s.LlmUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_usage\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "multivoice_message":
			if err := func() error {
				s.MultivoiceMessage.Reset()
				if err := s.MultivoiceMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multivoice_message\"")
			}
		case "original_message":
			if err := func() error {
				s.OriginalMessage.Reset()
				if err := s.OriginalMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_message\"")
			}
		case "rag_retrieval_info":
			if err := func() error {
				s.RagRetrievalInfo.Reset()
				if err := s.RagRetrievalInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_retrieval_info\"")
			}
		case "role":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "source_medium":
			if err := func() error {
				s.SourceMedium.Reset()
				if err := s.SourceMedium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_medium\"")
			}
		case "time_in_call_secs":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TimeInCallSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_in_call_secs\"")
			}
		case "tool_calls":
			if err := func() error {
				s.ToolCalls = make([]ConversationHistoryTranscriptToolCallCommonModelInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptToolCallCommonModelInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolCalls = append(s.ToolCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		case "tool_results":
			if err := func() error {
				s.ToolResults = make([]ConversationHistoryTranscriptCommonModelInputToolResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelInputToolResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolResults = append(s.ToolResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptCommonModelInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptCommonModelInput) {
					name = jsonFieldsNameOfConversationHistoryTranscriptCommonModelInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptCommonModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelInputRole as json.
func (s ConversationHistoryTranscriptCommonModelInputRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptCommonModelInputRole from json.
func (s *ConversationHistoryTranscriptCommonModelInputRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelInputRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptCommonModelInputRole(v) {
	case ConversationHistoryTranscriptCommonModelInputRoleUser:
		*s = ConversationHistoryTranscriptCommonModelInputRoleUser
	case ConversationHistoryTranscriptCommonModelInputRoleAgent:
		*s = ConversationHistoryTranscriptCommonModelInputRoleAgent
	default:
		*s = ConversationHistoryTranscriptCommonModelInputRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptCommonModelInputRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelInputRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelInputSourceMedium as json.
func (s ConversationHistoryTranscriptCommonModelInputSourceMedium) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptCommonModelInputSourceMedium from json.
func (s *ConversationHistoryTranscriptCommonModelInputSourceMedium) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelInputSourceMedium to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptCommonModelInputSourceMedium(v) {
	case ConversationHistoryTranscriptCommonModelInputSourceMediumAudio:
		*s = ConversationHistoryTranscriptCommonModelInputSourceMediumAudio
	case ConversationHistoryTranscriptCommonModelInputSourceMediumText:
		*s = ConversationHistoryTranscriptCommonModelInputSourceMediumText
	default:
		*s = ConversationHistoryTranscriptCommonModelInputSourceMedium(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptCommonModelInputSourceMedium) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelInputSourceMedium) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelInputToolResultsItem as json.
func (s ConversationHistoryTranscriptCommonModelInputToolResultsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput.Encode(e)
	}
}

func (s ConversationHistoryTranscriptCommonModelInputToolResultsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputConversationHistoryTranscriptCommonModelInputToolResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput.encodeFields(e)
	}
}

// Decode decodes ConversationHistoryTranscriptCommonModelInputToolResultsItem from json.
func (s *ConversationHistoryTranscriptCommonModelInputToolResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelInputToolResultsItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "credential_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_connection_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "result":
				// Multiple variants have this field - use type checking to discriminate
				typ := d.Next()
				switch typ {
				case jx.Object:
					match := ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				default:
					// Unknown type for this field
					return d.Skip()
				}
			case "type":
				// Value-based discrimination: check enum value
				if typ := d.Next(); typ != jx.String {
					return d.Skip()
				}
				value, err := d.StrBytes()
				if err != nil {
					return err
				}
				switch string(value) {
				case "api_integration_webhook":
					match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "client":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "mcp":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "system":
					match := ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "webhook":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "workflow":
					match := ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputConversationHistoryTranscriptCommonModelInputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				default:
					// Unknown enum value, ignore and continue
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		if err := s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		if err := s.ConversationHistoryTranscriptSystemToolResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelInputToolResultsItem:
		if err := s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputConversationHistoryTranscriptCommonModelInputToolResultsItem:
		if err := s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptCommonModelInputToolResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelInputToolResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptCommonModelOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptCommonModelOutput) encodeFields(e *jx.Encoder) {
	{
		if s.AgentMetadata.Set {
			e.FieldStart("agent_metadata")
			s.AgentMetadata.Encode(e)
		}
	}
	{
		if s.ConversationTurnMetrics.Set {
			e.FieldStart("conversation_turn_metrics")
			s.ConversationTurnMetrics.Encode(e)
		}
	}
	{
		if s.Feedback.Set {
			e.FieldStart("feedback")
			s.Feedback.Encode(e)
		}
	}
	{
		if s.Interrupted.Set {
			e.FieldStart("interrupted")
			s.Interrupted.Encode(e)
		}
	}
	{
		if s.LlmOverride.Set {
			e.FieldStart("llm_override")
			s.LlmOverride.Encode(e)
		}
	}
	{
		if s.LlmUsage.Set {
			e.FieldStart("llm_usage")
			s.LlmUsage.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.MultivoiceMessage.Set {
			e.FieldStart("multivoice_message")
			s.MultivoiceMessage.Encode(e)
		}
	}
	{
		if s.OriginalMessage.Set {
			e.FieldStart("original_message")
			s.OriginalMessage.Encode(e)
		}
	}
	{
		if s.RagRetrievalInfo.Set {
			e.FieldStart("rag_retrieval_info")
			s.RagRetrievalInfo.Encode(e)
		}
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.SourceMedium.Set {
			e.FieldStart("source_medium")
			s.SourceMedium.Encode(e)
		}
	}
	{
		e.FieldStart("time_in_call_secs")
		e.Int(s.TimeInCallSecs)
	}
	{
		if s.ToolCalls != nil {
			e.FieldStart("tool_calls")
			e.ArrStart()
			for _, elem := range s.ToolCalls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ToolResults != nil {
			e.FieldStart("tool_results")
			e.ArrStart()
			for _, elem := range s.ToolResults {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptCommonModelOutput = [15]string{
	0:  "agent_metadata",
	1:  "conversation_turn_metrics",
	2:  "feedback",
	3:  "interrupted",
	4:  "llm_override",
	5:  "llm_usage",
	6:  "message",
	7:  "multivoice_message",
	8:  "original_message",
	9:  "rag_retrieval_info",
	10: "role",
	11: "source_medium",
	12: "time_in_call_secs",
	13: "tool_calls",
	14: "tool_results",
}

// Decode decodes ConversationHistoryTranscriptCommonModelOutput from json.
func (s *ConversationHistoryTranscriptCommonModelOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelOutput to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_metadata":
			if err := func() error {
				s.AgentMetadata.Reset()
				if err := s.AgentMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_metadata\"")
			}
		case "conversation_turn_metrics":
			if err := func() error {
				s.ConversationTurnMetrics.Reset()
				if err := s.ConversationTurnMetrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_turn_metrics\"")
			}
		case "feedback":
			if err := func() error {
				s.Feedback.Reset()
				if err := s.Feedback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback\"")
			}
		case "interrupted":
			if err := func() error {
				s.Interrupted.Reset()
				if err := s.Interrupted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interrupted\"")
			}
		case "llm_override":
			if err := func() error {
				s.LlmOverride.Reset()
				if err := s.LlmOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_override\"")
			}
		case "llm_usage":
			if err := func() error {
				s.LlmUsage.Reset()
				if err := s.LlmUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_usage\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "multivoice_message":
			if err := func() error {
				s.MultivoiceMessage.Reset()
				if err := s.MultivoiceMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multivoice_message\"")
			}
		case "original_message":
			if err := func() error {
				s.OriginalMessage.Reset()
				if err := s.OriginalMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_message\"")
			}
		case "rag_retrieval_info":
			if err := func() error {
				s.RagRetrievalInfo.Reset()
				if err := s.RagRetrievalInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_retrieval_info\"")
			}
		case "role":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "source_medium":
			if err := func() error {
				s.SourceMedium.Reset()
				if err := s.SourceMedium.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_medium\"")
			}
		case "time_in_call_secs":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.TimeInCallSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_in_call_secs\"")
			}
		case "tool_calls":
			if err := func() error {
				s.ToolCalls = make([]ConversationHistoryTranscriptToolCallCommonModelOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptToolCallCommonModelOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolCalls = append(s.ToolCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_calls\"")
			}
		case "tool_results":
			if err := func() error {
				s.ToolResults = make([]ConversationHistoryTranscriptCommonModelOutputToolResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ToolResults = append(s.ToolResults, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptCommonModelOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00010100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptCommonModelOutput) {
					name = jsonFieldsNameOfConversationHistoryTranscriptCommonModelOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptCommonModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelOutputRole as json.
func (s ConversationHistoryTranscriptCommonModelOutputRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptCommonModelOutputRole from json.
func (s *ConversationHistoryTranscriptCommonModelOutputRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelOutputRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptCommonModelOutputRole(v) {
	case ConversationHistoryTranscriptCommonModelOutputRoleUser:
		*s = ConversationHistoryTranscriptCommonModelOutputRoleUser
	case ConversationHistoryTranscriptCommonModelOutputRoleAgent:
		*s = ConversationHistoryTranscriptCommonModelOutputRoleAgent
	default:
		*s = ConversationHistoryTranscriptCommonModelOutputRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptCommonModelOutputRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelOutputRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelOutputSourceMedium as json.
func (s ConversationHistoryTranscriptCommonModelOutputSourceMedium) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptCommonModelOutputSourceMedium from json.
func (s *ConversationHistoryTranscriptCommonModelOutputSourceMedium) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelOutputSourceMedium to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptCommonModelOutputSourceMedium(v) {
	case ConversationHistoryTranscriptCommonModelOutputSourceMediumAudio:
		*s = ConversationHistoryTranscriptCommonModelOutputSourceMediumAudio
	case ConversationHistoryTranscriptCommonModelOutputSourceMediumText:
		*s = ConversationHistoryTranscriptCommonModelOutputSourceMediumText
	default:
		*s = ConversationHistoryTranscriptCommonModelOutputSourceMedium(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptCommonModelOutputSourceMedium) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelOutputSourceMedium) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelOutputToolResultsItem as json.
func (s ConversationHistoryTranscriptCommonModelOutputToolResultsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput.Encode(e)
	}
}

func (s ConversationHistoryTranscriptCommonModelOutputToolResultsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput.encodeFields(e)
	}
}

// Decode decodes ConversationHistoryTranscriptCommonModelOutputToolResultsItem from json.
func (s *ConversationHistoryTranscriptCommonModelOutputToolResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptCommonModelOutputToolResultsItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "credential_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_connection_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "result":
				// Multiple variants have this field - use type checking to discriminate
				typ := d.Next()
				switch typ {
				case jx.Object:
					match := ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				default:
					// Unknown type for this field
					return d.Skip()
				}
			case "type":
				// Value-based discrimination: check enum value
				if typ := d.Next(); typ != jx.String {
					return d.Skip()
				}
				value, err := d.StrBytes()
				if err != nil {
					return err
				}
				switch string(value) {
				case "api_integration_webhook":
					match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "client":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "mcp":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "system":
					match := ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "webhook":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "workflow":
					match := ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputConversationHistoryTranscriptCommonModelOutputToolResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				default:
					// Unknown enum value, ignore and continue
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		if err := s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptSystemToolResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		if err := s.ConversationHistoryTranscriptSystemToolResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		if err := s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputConversationHistoryTranscriptCommonModelOutputToolResultsItem:
		if err := s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptCommonModelOutputToolResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptCommonModelOutputToolResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.DynamicVariableUpdates != nil {
			e.FieldStart("dynamic_variable_updates")
			e.ArrStart()
			for _, elem := range s.DynamicVariableUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("is_error")
		e.Bool(s.IsError)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		e.FieldStart("result_value")
		e.Str(s.ResultValue)
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		if s.ToolLatencySecs.Set {
			e.FieldStart("tool_latency_secs")
			s.ToolLatencySecs.Encode(e)
		}
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptOtherToolsResultCommonModel = [8]string{
	0: "dynamic_variable_updates",
	1: "is_error",
	2: "request_id",
	3: "result_value",
	4: "tool_has_been_called",
	5: "tool_latency_secs",
	6: "tool_name",
	7: "type",
}

// Decode decodes ConversationHistoryTranscriptOtherToolsResultCommonModel from json.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptOtherToolsResultCommonModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dynamic_variable_updates":
			if err := func() error {
				s.DynamicVariableUpdates = make([]DynamicVariableUpdateCommonModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DynamicVariableUpdateCommonModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DynamicVariableUpdates = append(s.DynamicVariableUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable_updates\"")
			}
		case "is_error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsError = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_error\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "result_value":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ResultValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_value\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_latency_secs":
			if err := func() error {
				s.ToolLatencySecs.Reset()
				if err := s.ToolLatencySecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_latency_secs\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptOtherToolsResultCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptOtherToolsResultCommonModel) {
					name = jsonFieldsNameOfConversationHistoryTranscriptOtherToolsResultCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptOtherToolsResultCommonModelType as json.
func (s ConversationHistoryTranscriptOtherToolsResultCommonModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptOtherToolsResultCommonModelType from json.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptOtherToolsResultCommonModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptOtherToolsResultCommonModelType(v) {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelTypeClient:
		*s = ConversationHistoryTranscriptOtherToolsResultCommonModelTypeClient
	case ConversationHistoryTranscriptOtherToolsResultCommonModelTypeWebhook:
		*s = ConversationHistoryTranscriptOtherToolsResultCommonModelTypeWebhook
	case ConversationHistoryTranscriptOtherToolsResultCommonModelTypeMcp:
		*s = ConversationHistoryTranscriptOtherToolsResultCommonModelTypeMcp
	default:
		*s = ConversationHistoryTranscriptOtherToolsResultCommonModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptOtherToolsResultCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptOtherToolsResultCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.DynamicVariableUpdates != nil {
			e.FieldStart("dynamic_variable_updates")
			e.ArrStart()
			for _, elem := range s.DynamicVariableUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("is_error")
		e.Bool(s.IsError)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("result_value")
		e.Str(s.ResultValue)
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		if s.ToolLatencySecs.Set {
			e.FieldStart("tool_latency_secs")
			s.ToolLatencySecs.Encode(e)
		}
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptSystemToolResultCommonModel = [9]string{
	0: "dynamic_variable_updates",
	1: "is_error",
	2: "request_id",
	3: "result",
	4: "result_value",
	5: "tool_has_been_called",
	6: "tool_latency_secs",
	7: "tool_name",
	8: "type",
}

// Decode decodes ConversationHistoryTranscriptSystemToolResultCommonModel from json.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptSystemToolResultCommonModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dynamic_variable_updates":
			if err := func() error {
				s.DynamicVariableUpdates = make([]DynamicVariableUpdateCommonModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DynamicVariableUpdateCommonModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DynamicVariableUpdates = append(s.DynamicVariableUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable_updates\"")
			}
		case "is_error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsError = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_error\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "result_value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ResultValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_value\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_latency_secs":
			if err := func() error {
				s.ToolLatencySecs.Reset()
				if err := s.ToolLatencySecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_latency_secs\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptSystemToolResultCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10110110,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptSystemToolResultCommonModel) {
					name = jsonFieldsNameOfConversationHistoryTranscriptSystemToolResultCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptSystemToolResultCommonModelResult as json.
func (s ConversationHistoryTranscriptSystemToolResultCommonModelResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConversationHistoryTranscriptSystemToolResultCommonModelResult) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case EndCallToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("end_call_success")
		{
			s := s.EndCallToolResultModel
			{
				if s.Message.Set {
					e.FieldStart("message")
					s.Message.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case LanguageDetectionToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("language_detection_success")
		{
			s := s.LanguageDetectionToolResultModel
			{
				if s.Language.Set {
					e.FieldStart("language")
					s.Language.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case TransferToAgentToolResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("transfer_to_agent_success")
		{
			s := s.TransferToAgentToolResultSuccessModel
			{
				e.FieldStart("condition")
				e.Str(s.Condition)
			}
			{
				if s.DelayMs.Set {
					e.FieldStart("delay_ms")
					s.DelayMs.Encode(e)
				}
			}
			{
				if s.EnableTransferredAgentFirstMessage.Set {
					e.FieldStart("enable_transferred_agent_first_message")
					s.EnableTransferredAgentFirstMessage.Encode(e)
				}
			}
			{
				e.FieldStart("from_agent")
				e.Str(s.FromAgent)
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
			{
				e.FieldStart("to_agent")
				e.Str(s.ToAgent)
			}
			{
				if s.TransferMessage.Set {
					e.FieldStart("transfer_message")
					s.TransferMessage.Encode(e)
				}
			}
		}
	case TransferToAgentToolResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("transfer_to_agent_error")
		{
			s := s.TransferToAgentToolResultErrorModel
			{
				e.FieldStart("error")
				e.Str(s.Error)
			}
			{
				e.FieldStart("from_agent")
				e.Str(s.FromAgent)
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case TransferToNumberResultTwilioSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("transfer_to_number_twilio_success")
		{
			s := s.TransferToNumberResultTwilioSuccessModel
			{
				e.FieldStart("agent_message")
				e.Str(s.AgentMessage)
			}
			{
				if s.ClientMessage.Set {
					e.FieldStart("client_message")
					s.ClientMessage.Encode(e)
				}
			}
			{
				e.FieldStart("conference_name")
				e.Str(s.ConferenceName)
			}
			{
				if s.Note.Set {
					e.FieldStart("note")
					s.Note.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
			{
				e.FieldStart("transfer_number")
				e.Str(s.TransferNumber)
			}
		}
	case TransferToNumberResultSipSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("transfer_to_number_sip_success")
		{
			s := s.TransferToNumberResultSipSuccessModel
			{
				if s.Note.Set {
					e.FieldStart("note")
					s.Note.Encode(e)
				}
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
			{
				e.FieldStart("transfer_number")
				e.Str(s.TransferNumber)
			}
		}
	case TransferToNumberResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("transfer_to_number_error")
		{
			s := s.TransferToNumberResultErrorModel
			{
				if s.Details.Set {
					e.FieldStart("details")
					s.Details.Encode(e)
				}
			}
			{
				e.FieldStart("error")
				e.Str(s.Error)
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case SkipTurnToolResponseModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("skip_turn_success")
		{
			s := s.SkipTurnToolResponseModel
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case PlayDTMFResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("play_dtmf_success")
		{
			s := s.PlayDTMFResultSuccessModel
			{
				e.FieldStart("dtmf_tones")
				e.Str(s.DtmfTones)
			}
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case PlayDTMFResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("play_dtmf_error")
		{
			s := s.PlayDTMFResultErrorModel
			{
				if s.Details.Set {
					e.FieldStart("details")
					s.Details.Encode(e)
				}
			}
			{
				e.FieldStart("error")
				e.Str(s.Error)
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	case VoiceMailDetectionResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("voicemail_detection_success")
		{
			s := s.VoiceMailDetectionResultSuccessModel
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
			{
				if s.VoicemailMessage.Set {
					e.FieldStart("voicemail_message")
					s.VoicemailMessage.Encode(e)
				}
			}
		}
	case TestToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		e.FieldStart("result_type")
		e.Str("testing_tool_result")
		{
			s := s.TestToolResultModel
			{
				if s.Reason.Set {
					e.FieldStart("reason")
					s.Reason.Encode(e)
				}
			}
			{
				if s.Status.Set {
					e.FieldStart("status")
					s.Status.Encode(e)
				}
			}
		}
	}
}

// Decode decodes ConversationHistoryTranscriptSystemToolResultCommonModelResult from json.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModelResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptSystemToolResultCommonModelResult to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "result_type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "end_call_success":
					s.Type = EndCallToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "language_detection_success":
					s.Type = LanguageDetectionToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "transfer_to_agent_success":
					s.Type = TransferToAgentToolResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "transfer_to_agent_error":
					s.Type = TransferToAgentToolResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "transfer_to_number_twilio_success":
					s.Type = TransferToNumberResultTwilioSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "transfer_to_number_sip_success":
					s.Type = TransferToNumberResultSipSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "transfer_to_number_error":
					s.Type = TransferToNumberResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "skip_turn_success":
					s.Type = SkipTurnToolResponseModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "play_dtmf_success":
					s.Type = PlayDTMFResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "play_dtmf_error":
					s.Type = PlayDTMFResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "voicemail_detection_success":
					s.Type = VoiceMailDetectionResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				case "testing_tool_result":
					s.Type = TestToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case EndCallToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.EndCallToolResultModel.Decode(d); err != nil {
			return err
		}
	case LanguageDetectionToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.LanguageDetectionToolResultModel.Decode(d); err != nil {
			return err
		}
	case TransferToAgentToolResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.TransferToAgentToolResultSuccessModel.Decode(d); err != nil {
			return err
		}
	case TransferToAgentToolResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.TransferToAgentToolResultErrorModel.Decode(d); err != nil {
			return err
		}
	case TransferToNumberResultTwilioSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.TransferToNumberResultTwilioSuccessModel.Decode(d); err != nil {
			return err
		}
	case TransferToNumberResultSipSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.TransferToNumberResultSipSuccessModel.Decode(d); err != nil {
			return err
		}
	case TransferToNumberResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.TransferToNumberResultErrorModel.Decode(d); err != nil {
			return err
		}
	case SkipTurnToolResponseModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.SkipTurnToolResponseModel.Decode(d); err != nil {
			return err
		}
	case PlayDTMFResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.PlayDTMFResultSuccessModel.Decode(d); err != nil {
			return err
		}
	case PlayDTMFResultErrorModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.PlayDTMFResultErrorModel.Decode(d); err != nil {
			return err
		}
	case VoiceMailDetectionResultSuccessModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.VoiceMailDetectionResultSuccessModel.Decode(d); err != nil {
			return err
		}
	case TestToolResultModelConversationHistoryTranscriptSystemToolResultCommonModelResult:
		if err := s.TestToolResultModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptSystemToolResultCommonModelResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModelResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptSystemToolResultCommonModelType as json.
func (s ConversationHistoryTranscriptSystemToolResultCommonModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptSystemToolResultCommonModelType from json.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptSystemToolResultCommonModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptSystemToolResultCommonModelType(v) {
	case ConversationHistoryTranscriptSystemToolResultCommonModelTypeSystem:
		*s = ConversationHistoryTranscriptSystemToolResultCommonModelTypeSystem
	default:
		*s = ConversationHistoryTranscriptSystemToolResultCommonModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptSystemToolResultCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptSystemToolResultCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("credential_id")
		e.Str(s.CredentialID)
	}
	{
		e.FieldStart("integration_connection_id")
		e.Str(s.IntegrationConnectionID)
	}
	{
		e.FieldStart("integration_id")
		e.Str(s.IntegrationID)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("webhook_details")
		s.WebhookDetails.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails = [5]string{
	0: "credential_id",
	1: "integration_connection_id",
	2: "integration_id",
	3: "type",
	4: "webhook_details",
}

// Decode decodes ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails from json.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credential_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CredentialID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credential_id\"")
			}
		case "integration_connection_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IntegrationConnectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_connection_id\"")
			}
		case "integration_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.IntegrationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "webhook_details":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.WebhookDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails) {
					name = jsonFieldsNameOfConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType as json.
func (s ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType from json.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType(v) {
	case ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsTypeAPIIntegrationWebhook:
		*s = ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsTypeAPIIntegrationWebhook
	default:
		*s = ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptToolCallClientDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptToolCallClientDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("parameters")
		e.Str(s.Parameters)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptToolCallClientDetails = [2]string{
	0: "parameters",
	1: "type",
}

// Decode decodes ConversationHistoryTranscriptToolCallClientDetails from json.
func (s *ConversationHistoryTranscriptToolCallClientDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallClientDetails to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Parameters = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallClientDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptToolCallClientDetails) {
					name = jsonFieldsNameOfConversationHistoryTranscriptToolCallClientDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptToolCallClientDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallClientDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallClientDetailsType as json.
func (s ConversationHistoryTranscriptToolCallClientDetailsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptToolCallClientDetailsType from json.
func (s *ConversationHistoryTranscriptToolCallClientDetailsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallClientDetailsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptToolCallClientDetailsType(v) {
	case ConversationHistoryTranscriptToolCallClientDetailsTypeClient:
		*s = ConversationHistoryTranscriptToolCallClientDetailsTypeClient
	default:
		*s = ConversationHistoryTranscriptToolCallClientDetailsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallClientDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallClientDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptToolCallCommonModelInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("params_as_json")
		e.Str(s.ParamsAsJSON)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		if s.ToolDetails.Set {
			e.FieldStart("tool_details")
			s.ToolDetails.Encode(e)
		}
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptToolCallCommonModelInput = [6]string{
	0: "params_as_json",
	1: "request_id",
	2: "tool_details",
	3: "tool_has_been_called",
	4: "tool_name",
	5: "type",
}

// Decode decodes ConversationHistoryTranscriptToolCallCommonModelInput from json.
func (s *ConversationHistoryTranscriptToolCallCommonModelInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallCommonModelInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "params_as_json":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ParamsAsJSON = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params_as_json\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "tool_details":
			if err := func() error {
				s.ToolDetails.Reset()
				if err := s.ToolDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_details\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallCommonModelInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptToolCallCommonModelInput) {
					name = jsonFieldsNameOfConversationHistoryTranscriptToolCallCommonModelInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallCommonModelInputToolDetails as json.
func (s ConversationHistoryTranscriptToolCallCommonModelInputToolDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConversationHistoryTranscriptToolCallCommonModelInputToolDetails) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptToolCallWebhookDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		e.FieldStart("type")
		e.Str("webhook")
		{
			s := s.ConversationHistoryTranscriptToolCallWebhookDetails
			{
				if s.Body.Set {
					e.FieldStart("body")
					s.Body.Encode(e)
				}
			}
			{
				if s.Headers.Set {
					e.FieldStart("headers")
					s.Headers.Encode(e)
				}
			}
			{
				e.FieldStart("method")
				e.Str(s.Method)
			}
			{
				if s.PathParams.Set {
					e.FieldStart("path_params")
					s.PathParams.Encode(e)
				}
			}
			{
				if s.QueryParams.Set {
					e.FieldStart("query_params")
					s.QueryParams.Encode(e)
				}
			}
			{
				e.FieldStart("url")
				e.Str(s.URL)
			}
		}
	case ConversationHistoryTranscriptToolCallClientDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		e.FieldStart("type")
		e.Str("client")
		{
			s := s.ConversationHistoryTranscriptToolCallClientDetails
			{
				e.FieldStart("parameters")
				e.Str(s.Parameters)
			}
		}
	case ConversationHistoryTranscriptToolCallMCPDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		e.FieldStart("type")
		e.Str("mcp")
		{
			s := s.ConversationHistoryTranscriptToolCallMCPDetails
			{
				e.FieldStart("approval_policy")
				e.Str(s.ApprovalPolicy)
			}
			{
				e.FieldStart("integration_type")
				e.Str(s.IntegrationType)
			}
			{
				e.FieldStart("mcp_server_id")
				e.Str(s.McpServerID)
			}
			{
				e.FieldStart("mcp_server_name")
				e.Str(s.McpServerName)
			}
			{
				if s.McpToolDescription.Set {
					e.FieldStart("mcp_tool_description")
					s.McpToolDescription.Encode(e)
				}
			}
			{
				if s.McpToolName.Set {
					e.FieldStart("mcp_tool_name")
					s.McpToolName.Encode(e)
				}
			}
			{
				if s.Parameters.Set {
					e.FieldStart("parameters")
					s.Parameters.Encode(e)
				}
			}
			{
				if s.RequiresApproval.Set {
					e.FieldStart("requires_approval")
					s.RequiresApproval.Encode(e)
				}
			}
		}
	case ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		e.FieldStart("type")
		e.Str("api_integration_webhook")
		{
			s := s.ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails
			{
				e.FieldStart("credential_id")
				e.Str(s.CredentialID)
			}
			{
				e.FieldStart("integration_connection_id")
				e.Str(s.IntegrationConnectionID)
			}
			{
				e.FieldStart("integration_id")
				e.Str(s.IntegrationID)
			}
			{
				e.FieldStart("webhook_details")
				s.WebhookDetails.Encode(e)
			}
		}
	}
}

// Decode decodes ConversationHistoryTranscriptToolCallCommonModelInputToolDetails from json.
func (s *ConversationHistoryTranscriptToolCallCommonModelInputToolDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallCommonModelInputToolDetails to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "webhook":
					s.Type = ConversationHistoryTranscriptToolCallWebhookDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails
					found = true
				case "client":
					s.Type = ConversationHistoryTranscriptToolCallClientDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails
					found = true
				case "mcp":
					s.Type = ConversationHistoryTranscriptToolCallMCPDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails
					found = true
				case "api_integration_webhook":
					s.Type = ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ConversationHistoryTranscriptToolCallWebhookDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallWebhookDetails.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptToolCallClientDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallClientDetails.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptToolCallMCPDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallMCPDetails.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsConversationHistoryTranscriptToolCallCommonModelInputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallCommonModelInputToolDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelInputToolDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("params_as_json")
		e.Str(s.ParamsAsJSON)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		if s.ToolDetails.Set {
			e.FieldStart("tool_details")
			s.ToolDetails.Encode(e)
		}
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptToolCallCommonModelOutput = [6]string{
	0: "params_as_json",
	1: "request_id",
	2: "tool_details",
	3: "tool_has_been_called",
	4: "tool_name",
	5: "type",
}

// Decode decodes ConversationHistoryTranscriptToolCallCommonModelOutput from json.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallCommonModelOutput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "params_as_json":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ParamsAsJSON = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params_as_json\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "tool_details":
			if err := func() error {
				s.ToolDetails.Reset()
				if err := s.ToolDetails.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_details\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallCommonModelOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptToolCallCommonModelOutput) {
					name = jsonFieldsNameOfConversationHistoryTranscriptToolCallCommonModelOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails as json.
func (s ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptToolCallWebhookDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		e.FieldStart("type")
		e.Str("webhook")
		{
			s := s.ConversationHistoryTranscriptToolCallWebhookDetails
			{
				if s.Body.Set {
					e.FieldStart("body")
					s.Body.Encode(e)
				}
			}
			{
				if s.Headers.Set {
					e.FieldStart("headers")
					s.Headers.Encode(e)
				}
			}
			{
				e.FieldStart("method")
				e.Str(s.Method)
			}
			{
				if s.PathParams.Set {
					e.FieldStart("path_params")
					s.PathParams.Encode(e)
				}
			}
			{
				if s.QueryParams.Set {
					e.FieldStart("query_params")
					s.QueryParams.Encode(e)
				}
			}
			{
				e.FieldStart("url")
				e.Str(s.URL)
			}
		}
	case ConversationHistoryTranscriptToolCallClientDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		e.FieldStart("type")
		e.Str("client")
		{
			s := s.ConversationHistoryTranscriptToolCallClientDetails
			{
				e.FieldStart("parameters")
				e.Str(s.Parameters)
			}
		}
	case ConversationHistoryTranscriptToolCallMCPDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		e.FieldStart("type")
		e.Str("mcp")
		{
			s := s.ConversationHistoryTranscriptToolCallMCPDetails
			{
				e.FieldStart("approval_policy")
				e.Str(s.ApprovalPolicy)
			}
			{
				e.FieldStart("integration_type")
				e.Str(s.IntegrationType)
			}
			{
				e.FieldStart("mcp_server_id")
				e.Str(s.McpServerID)
			}
			{
				e.FieldStart("mcp_server_name")
				e.Str(s.McpServerName)
			}
			{
				if s.McpToolDescription.Set {
					e.FieldStart("mcp_tool_description")
					s.McpToolDescription.Encode(e)
				}
			}
			{
				if s.McpToolName.Set {
					e.FieldStart("mcp_tool_name")
					s.McpToolName.Encode(e)
				}
			}
			{
				if s.Parameters.Set {
					e.FieldStart("parameters")
					s.Parameters.Encode(e)
				}
			}
			{
				if s.RequiresApproval.Set {
					e.FieldStart("requires_approval")
					s.RequiresApproval.Encode(e)
				}
			}
		}
	case ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		e.FieldStart("type")
		e.Str("api_integration_webhook")
		{
			s := s.ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails
			{
				e.FieldStart("credential_id")
				e.Str(s.CredentialID)
			}
			{
				e.FieldStart("integration_connection_id")
				e.Str(s.IntegrationConnectionID)
			}
			{
				e.FieldStart("integration_id")
				e.Str(s.IntegrationID)
			}
			{
				e.FieldStart("webhook_details")
				s.WebhookDetails.Encode(e)
			}
		}
	}
}

// Decode decodes ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails from json.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "webhook":
					s.Type = ConversationHistoryTranscriptToolCallWebhookDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails
					found = true
				case "client":
					s.Type = ConversationHistoryTranscriptToolCallClientDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails
					found = true
				case "mcp":
					s.Type = ConversationHistoryTranscriptToolCallMCPDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails
					found = true
				case "api_integration_webhook":
					s.Type = ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ConversationHistoryTranscriptToolCallWebhookDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallWebhookDetails.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptToolCallClientDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallClientDetails.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptToolCallMCPDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallMCPDetails.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsConversationHistoryTranscriptToolCallCommonModelOutputToolDetails:
		if err := s.ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetails.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptToolCallMCPDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptToolCallMCPDetails) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("approval_policy")
		e.Str(s.ApprovalPolicy)
	}
	{
		e.FieldStart("integration_type")
		e.Str(s.IntegrationType)
	}
	{
		e.FieldStart("mcp_server_id")
		e.Str(s.McpServerID)
	}
	{
		e.FieldStart("mcp_server_name")
		e.Str(s.McpServerName)
	}
	{
		if s.McpToolDescription.Set {
			e.FieldStart("mcp_tool_description")
			s.McpToolDescription.Encode(e)
		}
	}
	{
		if s.McpToolName.Set {
			e.FieldStart("mcp_tool_name")
			s.McpToolName.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		if s.RequiresApproval.Set {
			e.FieldStart("requires_approval")
			s.RequiresApproval.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptToolCallMCPDetails = [9]string{
	0: "approval_policy",
	1: "integration_type",
	2: "mcp_server_id",
	3: "mcp_server_name",
	4: "mcp_tool_description",
	5: "mcp_tool_name",
	6: "parameters",
	7: "requires_approval",
	8: "type",
}

// Decode decodes ConversationHistoryTranscriptToolCallMCPDetails from json.
func (s *ConversationHistoryTranscriptToolCallMCPDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallMCPDetails to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "approval_policy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApprovalPolicy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approval_policy\"")
			}
		case "integration_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IntegrationType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration_type\"")
			}
		case "mcp_server_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.McpServerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcp_server_id\"")
			}
		case "mcp_server_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.McpServerName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcp_server_name\"")
			}
		case "mcp_tool_description":
			if err := func() error {
				s.McpToolDescription.Reset()
				if err := s.McpToolDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcp_tool_description\"")
			}
		case "mcp_tool_name":
			if err := func() error {
				s.McpToolName.Reset()
				if err := s.McpToolName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcp_tool_name\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "requires_approval":
			if err := func() error {
				s.RequiresApproval.Reset()
				if err := s.RequiresApproval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_approval\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallMCPDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptToolCallMCPDetails) {
					name = jsonFieldsNameOfConversationHistoryTranscriptToolCallMCPDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptToolCallMCPDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallMCPDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallMCPDetailsParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallMCPDetailsParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ConversationHistoryTranscriptToolCallMCPDetailsParameters from json.
func (s *ConversationHistoryTranscriptToolCallMCPDetailsParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallMCPDetailsParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallMCPDetailsParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallMCPDetailsParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallMCPDetailsParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallMCPDetailsType as json.
func (s ConversationHistoryTranscriptToolCallMCPDetailsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptToolCallMCPDetailsType from json.
func (s *ConversationHistoryTranscriptToolCallMCPDetailsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallMCPDetailsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptToolCallMCPDetailsType(v) {
	case ConversationHistoryTranscriptToolCallMCPDetailsTypeMcp:
		*s = ConversationHistoryTranscriptToolCallMCPDetailsTypeMcp
	default:
		*s = ConversationHistoryTranscriptToolCallMCPDetailsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallMCPDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallMCPDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptToolCallWebhookDetails) encodeFields(e *jx.Encoder) {
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		e.FieldStart("method")
		e.Str(s.Method)
	}
	{
		if s.PathParams.Set {
			e.FieldStart("path_params")
			s.PathParams.Encode(e)
		}
	}
	{
		if s.QueryParams.Set {
			e.FieldStart("query_params")
			s.QueryParams.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptToolCallWebhookDetails = [7]string{
	0: "body",
	1: "headers",
	2: "method",
	3: "path_params",
	4: "query_params",
	5: "type",
	6: "url",
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetails from json.
func (s *ConversationHistoryTranscriptToolCallWebhookDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallWebhookDetails to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "method":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Method = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "path_params":
			if err := func() error {
				s.PathParams.Reset()
				if err := s.PathParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path_params\"")
			}
		case "query_params":
			if err := func() error {
				s.QueryParams.Reset()
				if err := s.QueryParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_params\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallWebhookDetails")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptToolCallWebhookDetails) {
					name = jsonFieldsNameOfConversationHistoryTranscriptToolCallWebhookDetails[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsHeaders from json.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallWebhookDetailsHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallWebhookDetailsHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsPathParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsPathParams) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsPathParams from json.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsPathParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallWebhookDetailsPathParams to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallWebhookDetailsPathParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsPathParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsPathParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams from json.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallWebhookDetailsType as json.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsType from json.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptToolCallWebhookDetailsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptToolCallWebhookDetailsType(v) {
	case ConversationHistoryTranscriptToolCallWebhookDetailsTypeWebhook:
		*s = ConversationHistoryTranscriptToolCallWebhookDetailsTypeWebhook
	default:
		*s = ConversationHistoryTranscriptToolCallWebhookDetailsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptToolCallWebhookDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptToolCallWebhookDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput) encodeFields(e *jx.Encoder) {
	{
		if s.DynamicVariableUpdates != nil {
			e.FieldStart("dynamic_variable_updates")
			e.ArrStart()
			for _, elem := range s.DynamicVariableUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("is_error")
		e.Bool(s.IsError)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("result_value")
		e.Str(s.ResultValue)
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		if s.ToolLatencySecs.Set {
			e.FieldStart("tool_latency_secs")
			s.ToolLatencySecs.Encode(e)
		}
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptWorkflowToolsResultCommonModelInput = [9]string{
	0: "dynamic_variable_updates",
	1: "is_error",
	2: "request_id",
	3: "result",
	4: "result_value",
	5: "tool_has_been_called",
	6: "tool_latency_secs",
	7: "tool_name",
	8: "type",
}

// Decode decodes ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput from json.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dynamic_variable_updates":
			if err := func() error {
				s.DynamicVariableUpdates = make([]DynamicVariableUpdateCommonModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DynamicVariableUpdateCommonModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DynamicVariableUpdates = append(s.DynamicVariableUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable_updates\"")
			}
		case "is_error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsError = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_error\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "result_value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ResultValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_value\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_latency_secs":
			if err := func() error {
				s.ToolLatencySecs.Reset()
				if err := s.ToolLatencySecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_latency_secs\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10110110,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptWorkflowToolsResultCommonModelInput) {
					name = jsonFieldsNameOfConversationHistoryTranscriptWorkflowToolsResultCommonModelInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType as json.
func (s ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType from json.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType(v) {
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputTypeWorkflow:
		*s = ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputTypeWorkflow
	default:
		*s = ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput) encodeFields(e *jx.Encoder) {
	{
		if s.DynamicVariableUpdates != nil {
			e.FieldStart("dynamic_variable_updates")
			e.ArrStart()
			for _, elem := range s.DynamicVariableUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("is_error")
		e.Bool(s.IsError)
	}
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		e.FieldStart("result_value")
		e.Str(s.ResultValue)
	}
	{
		e.FieldStart("tool_has_been_called")
		e.Bool(s.ToolHasBeenCalled)
	}
	{
		if s.ToolLatencySecs.Set {
			e.FieldStart("tool_latency_secs")
			s.ToolLatencySecs.Encode(e)
		}
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput = [9]string{
	0: "dynamic_variable_updates",
	1: "is_error",
	2: "request_id",
	3: "result",
	4: "result_value",
	5: "tool_has_been_called",
	6: "tool_latency_secs",
	7: "tool_name",
	8: "type",
}

// Decode decodes ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput from json.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dynamic_variable_updates":
			if err := func() error {
				s.DynamicVariableUpdates = make([]DynamicVariableUpdateCommonModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DynamicVariableUpdateCommonModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DynamicVariableUpdates = append(s.DynamicVariableUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable_updates\"")
			}
		case "is_error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsError = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_error\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "result_value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ResultValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_value\"")
			}
		case "tool_has_been_called":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ToolHasBeenCalled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_has_been_called\"")
			}
		case "tool_latency_secs":
			if err := func() error {
				s.ToolLatencySecs.Reset()
				if err := s.ToolLatencySecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_latency_secs\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10110110,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput) {
					name = jsonFieldsNameOfConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType as json.
func (s ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType from json.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType(v) {
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputTypeWorkflow:
		*s = ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputTypeWorkflow
	default:
		*s = ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationHistoryTwilioPhoneCallModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationHistoryTwilioPhoneCallModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_number")
		e.Str(s.AgentNumber)
	}
	{
		e.FieldStart("call_sid")
		e.Str(s.CallSid)
	}
	{
		e.FieldStart("direction")
		s.Direction.Encode(e)
	}
	{
		e.FieldStart("external_number")
		e.Str(s.ExternalNumber)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		e.FieldStart("stream_sid")
		e.Str(s.StreamSid)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfConversationHistoryTwilioPhoneCallModel = [7]string{
	0: "agent_number",
	1: "call_sid",
	2: "direction",
	3: "external_number",
	4: "phone_number_id",
	5: "stream_sid",
	6: "type",
}

// Decode decodes ConversationHistoryTwilioPhoneCallModel from json.
func (s *ConversationHistoryTwilioPhoneCallModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTwilioPhoneCallModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_number\"")
			}
		case "call_sid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CallSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_sid\"")
			}
		case "direction":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "external_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExternalNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_number\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "stream_sid":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.StreamSid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_sid\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationHistoryTwilioPhoneCallModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationHistoryTwilioPhoneCallModel) {
					name = jsonFieldsNameOfConversationHistoryTwilioPhoneCallModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationHistoryTwilioPhoneCallModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTwilioPhoneCallModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTwilioPhoneCallModelDirection as json.
func (s ConversationHistoryTwilioPhoneCallModelDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTwilioPhoneCallModelDirection from json.
func (s *ConversationHistoryTwilioPhoneCallModelDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTwilioPhoneCallModelDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTwilioPhoneCallModelDirection(v) {
	case ConversationHistoryTwilioPhoneCallModelDirectionInbound:
		*s = ConversationHistoryTwilioPhoneCallModelDirectionInbound
	case ConversationHistoryTwilioPhoneCallModelDirectionOutbound:
		*s = ConversationHistoryTwilioPhoneCallModelDirectionOutbound
	default:
		*s = ConversationHistoryTwilioPhoneCallModelDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTwilioPhoneCallModelDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTwilioPhoneCallModelDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTwilioPhoneCallModelType as json.
func (s ConversationHistoryTwilioPhoneCallModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationHistoryTwilioPhoneCallModelType from json.
func (s *ConversationHistoryTwilioPhoneCallModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationHistoryTwilioPhoneCallModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationHistoryTwilioPhoneCallModelType(v) {
	case ConversationHistoryTwilioPhoneCallModelTypeTwilio:
		*s = ConversationHistoryTwilioPhoneCallModelTypeTwilio
	default:
		*s = ConversationHistoryTwilioPhoneCallModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationHistoryTwilioPhoneCallModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationHistoryTwilioPhoneCallModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataInternal) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataInternal) encodeFields(e *jx.Encoder) {
	{
		if s.ConversationConfigOverride.Set {
			e.FieldStart("conversation_config_override")
			s.ConversationConfigOverride.Encode(e)
		}
	}
	{
		if s.CustomLlmExtraBody != nil {
			e.FieldStart("custom_llm_extra_body")
			s.CustomLlmExtraBody.Encode(e)
		}
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		if s.SourceInfo.Set {
			e.FieldStart("source_info")
			s.SourceInfo.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationInitiationClientDataInternal = [5]string{
	0: "conversation_config_override",
	1: "custom_llm_extra_body",
	2: "dynamic_variables",
	3: "source_info",
	4: "user_id",
}

// Decode decodes ConversationInitiationClientDataInternal from json.
func (s *ConversationInitiationClientDataInternal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataInternal to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_config_override":
			if err := func() error {
				s.ConversationConfigOverride.Reset()
				if err := s.ConversationConfigOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_config_override\"")
			}
		case "custom_llm_extra_body":
			if err := func() error {
				s.CustomLlmExtraBody = nil
				var elem ConversationInitiationClientDataInternalCustomLlmExtraBody
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomLlmExtraBody = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_llm_extra_body\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "source_info":
			if err := func() error {
				s.SourceInfo.Reset()
				if err := s.SourceInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_info\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataInternal")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataInternal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataInternal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataInternalCustomLlmExtraBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataInternalCustomLlmExtraBody) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConversationInitiationClientDataInternalCustomLlmExtraBody = [0]string{}

// Decode decodes ConversationInitiationClientDataInternalCustomLlmExtraBody from json.
func (s *ConversationInitiationClientDataInternalCustomLlmExtraBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataInternalCustomLlmExtraBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataInternalCustomLlmExtraBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataInternalCustomLlmExtraBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataInternalCustomLlmExtraBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationInitiationClientDataInternalDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationInitiationClientDataInternalDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationInitiationClientDataInternalDynamicVariables from json.
func (s *ConversationInitiationClientDataInternalDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataInternalDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilConversationInitiationClientDataInternalDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataInternalDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataInternalDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataInternalDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataInternalDynamicVariablesItem as json.
func (s ConversationInitiationClientDataInternalDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringConversationInitiationClientDataInternalDynamicVariablesItem:
		e.Str(s.String)
	case Float64ConversationInitiationClientDataInternalDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntConversationInitiationClientDataInternalDynamicVariablesItem:
		e.Int(s.Int)
	case BoolConversationInitiationClientDataInternalDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes ConversationInitiationClientDataInternalDynamicVariablesItem from json.
func (s *ConversationInitiationClientDataInternalDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataInternalDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolConversationInitiationClientDataInternalDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntConversationInitiationClientDataInternalDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64ConversationInitiationClientDataInternalDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringConversationInitiationClientDataInternalDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataInternalDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataInternalDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataRequestInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataRequestInput) encodeFields(e *jx.Encoder) {
	{
		if s.ConversationConfigOverride.Set {
			e.FieldStart("conversation_config_override")
			s.ConversationConfigOverride.Encode(e)
		}
	}
	{
		if s.CustomLlmExtraBody != nil {
			e.FieldStart("custom_llm_extra_body")
			s.CustomLlmExtraBody.Encode(e)
		}
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		if s.SourceInfo.Set {
			e.FieldStart("source_info")
			s.SourceInfo.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationInitiationClientDataRequestInput = [5]string{
	0: "conversation_config_override",
	1: "custom_llm_extra_body",
	2: "dynamic_variables",
	3: "source_info",
	4: "user_id",
}

// Decode decodes ConversationInitiationClientDataRequestInput from json.
func (s *ConversationInitiationClientDataRequestInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestInput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_config_override":
			if err := func() error {
				s.ConversationConfigOverride.Reset()
				if err := s.ConversationConfigOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_config_override\"")
			}
		case "custom_llm_extra_body":
			if err := func() error {
				s.CustomLlmExtraBody = nil
				var elem ConversationInitiationClientDataRequestInputCustomLlmExtraBody
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomLlmExtraBody = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_llm_extra_body\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "source_info":
			if err := func() error {
				s.SourceInfo.Reset()
				if err := s.SourceInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_info\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataRequestInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataRequestInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataRequestInputCustomLlmExtraBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataRequestInputCustomLlmExtraBody) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConversationInitiationClientDataRequestInputCustomLlmExtraBody = [0]string{}

// Decode decodes ConversationInitiationClientDataRequestInputCustomLlmExtraBody from json.
func (s *ConversationInitiationClientDataRequestInputCustomLlmExtraBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestInputCustomLlmExtraBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataRequestInputCustomLlmExtraBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataRequestInputCustomLlmExtraBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestInputCustomLlmExtraBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationInitiationClientDataRequestInputDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationInitiationClientDataRequestInputDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationInitiationClientDataRequestInputDynamicVariables from json.
func (s *ConversationInitiationClientDataRequestInputDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestInputDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilConversationInitiationClientDataRequestInputDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataRequestInputDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataRequestInputDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestInputDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestInputDynamicVariablesItem as json.
func (s ConversationInitiationClientDataRequestInputDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringConversationInitiationClientDataRequestInputDynamicVariablesItem:
		e.Str(s.String)
	case Float64ConversationInitiationClientDataRequestInputDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntConversationInitiationClientDataRequestInputDynamicVariablesItem:
		e.Int(s.Int)
	case BoolConversationInitiationClientDataRequestInputDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes ConversationInitiationClientDataRequestInputDynamicVariablesItem from json.
func (s *ConversationInitiationClientDataRequestInputDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestInputDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolConversationInitiationClientDataRequestInputDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntConversationInitiationClientDataRequestInputDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64ConversationInitiationClientDataRequestInputDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringConversationInitiationClientDataRequestInputDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataRequestInputDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestInputDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataRequestOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataRequestOutput) encodeFields(e *jx.Encoder) {
	{
		if s.ConversationConfigOverride.Set {
			e.FieldStart("conversation_config_override")
			s.ConversationConfigOverride.Encode(e)
		}
	}
	{
		if s.CustomLlmExtraBody != nil {
			e.FieldStart("custom_llm_extra_body")
			s.CustomLlmExtraBody.Encode(e)
		}
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		if s.SourceInfo.Set {
			e.FieldStart("source_info")
			s.SourceInfo.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationInitiationClientDataRequestOutput = [5]string{
	0: "conversation_config_override",
	1: "custom_llm_extra_body",
	2: "dynamic_variables",
	3: "source_info",
	4: "user_id",
}

// Decode decodes ConversationInitiationClientDataRequestOutput from json.
func (s *ConversationInitiationClientDataRequestOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestOutput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_config_override":
			if err := func() error {
				s.ConversationConfigOverride.Reset()
				if err := s.ConversationConfigOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_config_override\"")
			}
		case "custom_llm_extra_body":
			if err := func() error {
				s.CustomLlmExtraBody = nil
				var elem ConversationInitiationClientDataRequestOutputCustomLlmExtraBody
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.CustomLlmExtraBody = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_llm_extra_body\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "source_info":
			if err := func() error {
				s.SourceInfo.Reset()
				if err := s.SourceInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_info\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataRequestOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataRequestOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataRequestOutputCustomLlmExtraBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataRequestOutputCustomLlmExtraBody) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConversationInitiationClientDataRequestOutputCustomLlmExtraBody = [0]string{}

// Decode decodes ConversationInitiationClientDataRequestOutputCustomLlmExtraBody from json.
func (s *ConversationInitiationClientDataRequestOutputCustomLlmExtraBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestOutputCustomLlmExtraBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataRequestOutputCustomLlmExtraBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataRequestOutputCustomLlmExtraBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestOutputCustomLlmExtraBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationInitiationClientDataRequestOutputDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationInitiationClientDataRequestOutputDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationInitiationClientDataRequestOutputDynamicVariables from json.
func (s *ConversationInitiationClientDataRequestOutputDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestOutputDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilConversationInitiationClientDataRequestOutputDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataRequestOutputDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataRequestOutputDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestOutputDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestOutputDynamicVariablesItem as json.
func (s ConversationInitiationClientDataRequestOutputDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringConversationInitiationClientDataRequestOutputDynamicVariablesItem:
		e.Str(s.String)
	case Float64ConversationInitiationClientDataRequestOutputDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntConversationInitiationClientDataRequestOutputDynamicVariablesItem:
		e.Int(s.Int)
	case BoolConversationInitiationClientDataRequestOutputDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes ConversationInitiationClientDataRequestOutputDynamicVariablesItem from json.
func (s *ConversationInitiationClientDataRequestOutputDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataRequestOutputDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolConversationInitiationClientDataRequestOutputDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntConversationInitiationClientDataRequestOutputDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64ConversationInitiationClientDataRequestOutputDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringConversationInitiationClientDataRequestOutputDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataRequestOutputDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataRequestOutputDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationClientDataWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationClientDataWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("request_headers")
		s.RequestHeaders.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfConversationInitiationClientDataWebhook = [2]string{
	0: "request_headers",
	1: "url",
}

// Decode decodes ConversationInitiationClientDataWebhook from json.
func (s *ConversationInitiationClientDataWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_headers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.RequestHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_headers\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationInitiationClientDataWebhook) {
					name = jsonFieldsNameOfConversationInitiationClientDataWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationClientDataWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationInitiationClientDataWebhookRequestHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationInitiationClientDataWebhookRequestHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationInitiationClientDataWebhookRequestHeaders from json.
func (s *ConversationInitiationClientDataWebhookRequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataWebhookRequestHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ConversationInitiationClientDataWebhookRequestHeadersItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationClientDataWebhookRequestHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataWebhookRequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataWebhookRequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataWebhookRequestHeadersItem as json.
func (s ConversationInitiationClientDataWebhookRequestHeadersItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringConversationInitiationClientDataWebhookRequestHeadersItem:
		e.Str(s.String)
	case ConvAISecretLocatorConversationInitiationClientDataWebhookRequestHeadersItem:
		s.ConvAISecretLocator.Encode(e)
	}
}

// Decode decodes ConversationInitiationClientDataWebhookRequestHeadersItem from json.
func (s *ConversationInitiationClientDataWebhookRequestHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationClientDataWebhookRequestHeadersItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.ConvAISecretLocator.Decode(d); err != nil {
			return err
		}
		s.Type = ConvAISecretLocatorConversationInitiationClientDataWebhookRequestHeadersItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringConversationInitiationClientDataWebhookRequestHeadersItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationClientDataWebhookRequestHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationClientDataWebhookRequestHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationSource as json.
func (s ConversationInitiationSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationInitiationSource from json.
func (s *ConversationInitiationSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationInitiationSource(v) {
	case ConversationInitiationSourceUnknown:
		*s = ConversationInitiationSourceUnknown
	case ConversationInitiationSourceAndroidSdk:
		*s = ConversationInitiationSourceAndroidSdk
	case ConversationInitiationSourceNodeJsSdk:
		*s = ConversationInitiationSourceNodeJsSdk
	case ConversationInitiationSourceReactNativeSdk:
		*s = ConversationInitiationSourceReactNativeSdk
	case ConversationInitiationSourceReactSdk:
		*s = ConversationInitiationSourceReactSdk
	case ConversationInitiationSourceJsSdk:
		*s = ConversationInitiationSourceJsSdk
	case ConversationInitiationSourcePythonSdk:
		*s = ConversationInitiationSourcePythonSdk
	case ConversationInitiationSourceWidget:
		*s = ConversationInitiationSourceWidget
	case ConversationInitiationSourceSipTrunk:
		*s = ConversationInitiationSourceSipTrunk
	case ConversationInitiationSourceTwilio:
		*s = ConversationInitiationSourceTwilio
	case ConversationInitiationSourceGenesys:
		*s = ConversationInitiationSourceGenesys
	case ConversationInitiationSourceSwiftSdk:
		*s = ConversationInitiationSourceSwiftSdk
	case ConversationInitiationSourceWhatsapp:
		*s = ConversationInitiationSourceWhatsapp
	case ConversationInitiationSourceFlutterSdk:
		*s = ConversationInitiationSourceFlutterSdk
	default:
		*s = ConversationInitiationSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationInitiationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationInitiationSourceInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationInitiationSourceInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationInitiationSourceInfo = [2]string{
	0: "source",
	1: "version",
}

// Decode decodes ConversationInitiationSourceInfo from json.
func (s *ConversationInitiationSourceInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationInitiationSourceInfo to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationInitiationSourceInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationInitiationSourceInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationInitiationSourceInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationSignedUrlResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationSignedUrlResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("signed_url")
		e.Str(s.SignedURL)
	}
}

var jsonFieldsNameOfConversationSignedUrlResponseModel = [1]string{
	0: "signed_url",
}

// Decode decodes ConversationSignedUrlResponseModel from json.
func (s *ConversationSignedUrlResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationSignedUrlResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "signed_url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SignedURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signed_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationSignedUrlResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationSignedUrlResponseModel) {
					name = jsonFieldsNameOfConversationSignedUrlResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationSignedUrlResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationSignedUrlResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationSummaryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationSummaryResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.AgentName.Set {
			e.FieldStart("agent_name")
			s.AgentName.Encode(e)
		}
	}
	{
		if s.BranchID.Set {
			e.FieldStart("branch_id")
			s.BranchID.Encode(e)
		}
	}
	{
		e.FieldStart("call_duration_secs")
		e.Int(s.CallDurationSecs)
	}
	{
		e.FieldStart("call_successful")
		s.CallSuccessful.Encode(e)
	}
	{
		if s.CallSummaryTitle.Set {
			e.FieldStart("call_summary_title")
			s.CallSummaryTitle.Encode(e)
		}
	}
	{
		e.FieldStart("conversation_id")
		e.Str(s.ConversationID)
	}
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		e.FieldStart("message_count")
		e.Int(s.MessageCount)
	}
	{
		if s.Rating.Set {
			e.FieldStart("rating")
			s.Rating.Encode(e)
		}
	}
	{
		e.FieldStart("start_time_unix_secs")
		e.Int(s.StartTimeUnixSecs)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.TranscriptSummary.Set {
			e.FieldStart("transcript_summary")
			s.TranscriptSummary.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationSummaryResponseModel = [13]string{
	0:  "agent_id",
	1:  "agent_name",
	2:  "branch_id",
	3:  "call_duration_secs",
	4:  "call_successful",
	5:  "call_summary_title",
	6:  "conversation_id",
	7:  "direction",
	8:  "message_count",
	9:  "rating",
	10: "start_time_unix_secs",
	11: "status",
	12: "transcript_summary",
}

// Decode decodes ConversationSummaryResponseModel from json.
func (s *ConversationSummaryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationSummaryResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_name":
			if err := func() error {
				s.AgentName.Reset()
				if err := s.AgentName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_name\"")
			}
		case "branch_id":
			if err := func() error {
				s.BranchID.Reset()
				if err := s.BranchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_id\"")
			}
		case "call_duration_secs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CallDurationSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_duration_secs\"")
			}
		case "call_successful":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.CallSuccessful.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_successful\"")
			}
		case "call_summary_title":
			if err := func() error {
				s.CallSummaryTitle.Reset()
				if err := s.CallSummaryTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"call_summary_title\"")
			}
		case "conversation_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ConversationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "message_count":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MessageCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message_count\"")
			}
		case "rating":
			if err := func() error {
				s.Rating.Reset()
				if err := s.Rating.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rating\"")
			}
		case "start_time_unix_secs":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.StartTimeUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time_unix_secs\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "transcript_summary":
			if err := func() error {
				s.TranscriptSummary.Reset()
				if err := s.TranscriptSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcript_summary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationSummaryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011001,
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationSummaryResponseModel) {
					name = jsonFieldsNameOfConversationSummaryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationSummaryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationSummaryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationSummaryResponseModelDirection as json.
func (s ConversationSummaryResponseModelDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationSummaryResponseModelDirection from json.
func (s *ConversationSummaryResponseModelDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationSummaryResponseModelDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationSummaryResponseModelDirection(v) {
	case ConversationSummaryResponseModelDirectionInbound:
		*s = ConversationSummaryResponseModelDirectionInbound
	case ConversationSummaryResponseModelDirectionOutbound:
		*s = ConversationSummaryResponseModelDirectionOutbound
	default:
		*s = ConversationSummaryResponseModelDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationSummaryResponseModelDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationSummaryResponseModelDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationSummaryResponseModelStatus as json.
func (s ConversationSummaryResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationSummaryResponseModelStatus from json.
func (s *ConversationSummaryResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationSummaryResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationSummaryResponseModelStatus(v) {
	case ConversationSummaryResponseModelStatusInitiated:
		*s = ConversationSummaryResponseModelStatusInitiated
	case ConversationSummaryResponseModelStatusInProgress:
		*s = ConversationSummaryResponseModelStatusInProgress
	case ConversationSummaryResponseModelStatusProcessing:
		*s = ConversationSummaryResponseModelStatusProcessing
	case ConversationSummaryResponseModelStatusDone:
		*s = ConversationSummaryResponseModelStatusDone
	case ConversationSummaryResponseModelStatusFailed:
		*s = ConversationSummaryResponseModelStatusFailed
	default:
		*s = ConversationSummaryResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationSummaryResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationSummaryResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationTokenDBModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationTokenDBModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.ConversationID.Set {
			e.FieldStart("conversation_id")
			s.ConversationID.Encode(e)
		}
	}
	{
		e.FieldStart("conversation_token")
		e.Str(s.ConversationToken)
	}
	{
		if s.ExpirationTimeUnixSecs.Set {
			e.FieldStart("expiration_time_unix_secs")
			s.ExpirationTimeUnixSecs.Encode(e)
		}
	}
	{
		if s.Purpose.Set {
			e.FieldStart("purpose")
			s.Purpose.Encode(e)
		}
	}
	{
		if s.TokenRequesterUserID.Set {
			e.FieldStart("token_requester_user_id")
			s.TokenRequesterUserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationTokenDBModel = [6]string{
	0: "agent_id",
	1: "conversation_id",
	2: "conversation_token",
	3: "expiration_time_unix_secs",
	4: "purpose",
	5: "token_requester_user_id",
}

// Decode decodes ConversationTokenDBModel from json.
func (s *ConversationTokenDBModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationTokenDBModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "conversation_id":
			if err := func() error {
				s.ConversationID.Reset()
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "conversation_token":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ConversationToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_token\"")
			}
		case "expiration_time_unix_secs":
			if err := func() error {
				s.ExpirationTimeUnixSecs.Reset()
				if err := s.ExpirationTimeUnixSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration_time_unix_secs\"")
			}
		case "purpose":
			if err := func() error {
				s.Purpose.Reset()
				if err := s.Purpose.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purpose\"")
			}
		case "token_requester_user_id":
			if err := func() error {
				s.TokenRequesterUserID.Reset()
				if err := s.TokenRequesterUserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_requester_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationTokenDBModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConversationTokenDBModel) {
					name = jsonFieldsNameOfConversationTokenDBModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationTokenDBModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationTokenDBModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationTokenPurpose as json.
func (s ConversationTokenPurpose) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConversationTokenPurpose from json.
func (s *ConversationTokenPurpose) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationTokenPurpose to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConversationTokenPurpose(v) {
	case ConversationTokenPurposeSignedURL:
		*s = ConversationTokenPurposeSignedURL
	case ConversationTokenPurposeShareableLink:
		*s = ConversationTokenPurposeShareableLink
	default:
		*s = ConversationTokenPurpose(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationTokenPurpose) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationTokenPurpose) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConversationTurnMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConversationTurnMetrics) encodeFields(e *jx.Encoder) {
	{
		if s.Metrics.Set {
			e.FieldStart("metrics")
			s.Metrics.Encode(e)
		}
	}
}

var jsonFieldsNameOfConversationTurnMetrics = [1]string{
	0: "metrics",
}

// Decode decodes ConversationTurnMetrics from json.
func (s *ConversationTurnMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationTurnMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metrics":
			if err := func() error {
				s.Metrics.Reset()
				if err := s.Metrics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationTurnMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConversationTurnMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationTurnMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConversationTurnMetricsMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConversationTurnMetricsMetrics) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes ConversationTurnMetricsMetrics from json.
func (s *ConversationTurnMetricsMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConversationTurnMetricsMetrics to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem MetricRecord
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConversationTurnMetricsMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConversationTurnMetricsMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConversationTurnMetricsMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConvertChapterResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConvertChapterResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfConvertChapterResponseModel = [1]string{
	0: "status",
}

// Decode decodes ConvertChapterResponseModel from json.
func (s *ConvertChapterResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvertChapterResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConvertChapterResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConvertChapterResponseModel) {
					name = jsonFieldsNameOfConvertChapterResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConvertChapterResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvertChapterResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConvertProjectResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConvertProjectResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfConvertProjectResponseModel = [1]string{
	0: "status",
}

// Decode decodes ConvertProjectResponseModel from json.
func (s *ConvertProjectResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConvertProjectResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConvertProjectResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConvertProjectResponseModel) {
					name = jsonFieldsNameOfConvertProjectResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConvertProjectResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConvertProjectResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAgentResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAgentResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
}

var jsonFieldsNameOfCreateAgentResponseModel = [1]string{
	0: "agent_id",
}

// Decode decodes CreateAgentResponseModel from json.
func (s *CreateAgentResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAgentResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAgentResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAgentResponseModel) {
					name = jsonFieldsNameOfCreateAgentResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAgentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAgentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePronunciationDictionaryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePronunciationDictionaryResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfCreatePronunciationDictionaryResponseModel = [1]string{
	0: "status",
}

// Decode decodes CreatePronunciationDictionaryResponseModel from json.
func (s *CreatePronunciationDictionaryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePronunciationDictionaryResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePronunciationDictionaryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePronunciationDictionaryResponseModel) {
					name = jsonFieldsNameOfCreatePronunciationDictionaryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePronunciationDictionaryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePronunciationDictionaryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUnitTestRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUnitTestRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_history")
		e.ArrStart()
		for _, elem := range s.ChatHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		e.FieldStart("failure_examples")
		e.ArrStart()
		for _, elem := range s.FailureExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FromConversationMetadata.Set {
			e.FieldStart("from_conversation_metadata")
			s.FromConversationMetadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("success_condition")
		e.Str(s.SuccessCondition)
	}
	{
		e.FieldStart("success_examples")
		e.ArrStart()
		for _, elem := range s.SuccessExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ToolCallParameters.Set {
			e.FieldStart("tool_call_parameters")
			s.ToolCallParameters.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUnitTestRequest = [9]string{
	0: "chat_history",
	1: "dynamic_variables",
	2: "failure_examples",
	3: "from_conversation_metadata",
	4: "name",
	5: "success_condition",
	6: "success_examples",
	7: "tool_call_parameters",
	8: "type",
}

// Decode decodes CreateUnitTestRequest from json.
func (s *CreateUnitTestRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUnitTestRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_history":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ChatHistory = make([]ConversationHistoryTranscriptCommonModelInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChatHistory = append(s.ChatHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_history\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "failure_examples":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FailureExamples = make([]AgentFailureResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentFailureResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailureExamples = append(s.FailureExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_examples\"")
			}
		case "from_conversation_metadata":
			if err := func() error {
				s.FromConversationMetadata.Reset()
				if err := s.FromConversationMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_conversation_metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "success_condition":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SuccessCondition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_condition\"")
			}
		case "success_examples":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.SuccessExamples = make([]AgentSuccessfulResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentSuccessfulResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SuccessExamples = append(s.SuccessExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_examples\"")
			}
		case "tool_call_parameters":
			if err := func() error {
				s.ToolCallParameters.Reset()
				if err := s.ToolCallParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_parameters\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUnitTestRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUnitTestRequest) {
					name = jsonFieldsNameOfCreateUnitTestRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUnitTestRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUnitTestRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CreateUnitTestRequestDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CreateUnitTestRequestDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes CreateUnitTestRequestDynamicVariables from json.
func (s *CreateUnitTestRequestDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUnitTestRequestDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilCreateUnitTestRequestDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUnitTestRequestDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUnitTestRequestDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUnitTestRequestDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUnitTestRequestDynamicVariablesItem as json.
func (s CreateUnitTestRequestDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringCreateUnitTestRequestDynamicVariablesItem:
		e.Str(s.String)
	case Float64CreateUnitTestRequestDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntCreateUnitTestRequestDynamicVariablesItem:
		e.Int(s.Int)
	case BoolCreateUnitTestRequestDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes CreateUnitTestRequestDynamicVariablesItem from json.
func (s *CreateUnitTestRequestDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUnitTestRequestDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolCreateUnitTestRequestDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntCreateUnitTestRequestDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64CreateUnitTestRequestDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringCreateUnitTestRequestDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUnitTestRequestDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUnitTestRequestDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUnitTestResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUnitTestResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfCreateUnitTestResponseModel = [1]string{
	0: "id",
}

// Decode decodes CreateUnitTestResponseModel from json.
func (s *CreateUnitTestResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUnitTestResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUnitTestResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUnitTestResponseModel) {
					name = jsonFieldsNameOfCreateUnitTestResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUnitTestResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUnitTestResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardCallSuccessChartModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardCallSuccessChartModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDashboardCallSuccessChartModel = [2]string{
	0: "name",
	1: "type",
}

// Decode decodes DashboardCallSuccessChartModel from json.
func (s *DashboardCallSuccessChartModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardCallSuccessChartModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardCallSuccessChartModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDashboardCallSuccessChartModel) {
					name = jsonFieldsNameOfDashboardCallSuccessChartModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardCallSuccessChartModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardCallSuccessChartModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardCallSuccessChartModelType as json.
func (s DashboardCallSuccessChartModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DashboardCallSuccessChartModelType from json.
func (s *DashboardCallSuccessChartModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardCallSuccessChartModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DashboardCallSuccessChartModelType(v) {
	case DashboardCallSuccessChartModelTypeCallSuccess:
		*s = DashboardCallSuccessChartModelTypeCallSuccess
	default:
		*s = DashboardCallSuccessChartModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DashboardCallSuccessChartModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardCallSuccessChartModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardCriteriaChartModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardCriteriaChartModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("criteria_id")
		e.Str(s.CriteriaID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDashboardCriteriaChartModel = [3]string{
	0: "criteria_id",
	1: "name",
	2: "type",
}

// Decode decodes DashboardCriteriaChartModel from json.
func (s *DashboardCriteriaChartModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardCriteriaChartModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "criteria_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CriteriaID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"criteria_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardCriteriaChartModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDashboardCriteriaChartModel) {
					name = jsonFieldsNameOfDashboardCriteriaChartModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardCriteriaChartModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardCriteriaChartModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardCriteriaChartModelType as json.
func (s DashboardCriteriaChartModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DashboardCriteriaChartModelType from json.
func (s *DashboardCriteriaChartModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardCriteriaChartModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DashboardCriteriaChartModelType(v) {
	case DashboardCriteriaChartModelTypeCriteria:
		*s = DashboardCriteriaChartModelTypeCriteria
	default:
		*s = DashboardCriteriaChartModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DashboardCriteriaChartModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardCriteriaChartModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DashboardDataCollectionChartModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DashboardDataCollectionChartModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data_collection_id")
		e.Str(s.DataCollectionID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDashboardDataCollectionChartModel = [3]string{
	0: "data_collection_id",
	1: "name",
	2: "type",
}

// Decode decodes DashboardDataCollectionChartModel from json.
func (s *DashboardDataCollectionChartModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardDataCollectionChartModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data_collection_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DataCollectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_collection_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DashboardDataCollectionChartModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDashboardDataCollectionChartModel) {
					name = jsonFieldsNameOfDashboardDataCollectionChartModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DashboardDataCollectionChartModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardDataCollectionChartModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardDataCollectionChartModelType as json.
func (s DashboardDataCollectionChartModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DashboardDataCollectionChartModelType from json.
func (s *DashboardDataCollectionChartModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DashboardDataCollectionChartModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DashboardDataCollectionChartModelType(v) {
	case DashboardDataCollectionChartModelTypeDataCollection:
		*s = DashboardDataCollectionChartModelTypeDataCollection
	default:
		*s = DashboardDataCollectionChartModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DashboardDataCollectionChartModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DashboardDataCollectionChartModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DataCollectionResultCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DataCollectionResultCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data_collection_id")
		e.Str(s.DataCollectionID)
	}
	{
		if s.JSONSchema.Set {
			e.FieldStart("json_schema")
			s.JSONSchema.Encode(e)
		}
	}
	{
		e.FieldStart("rationale")
		e.Str(s.Rationale)
	}
	{
		if len(s.Value) != 0 {
			e.FieldStart("value")
			e.Raw(s.Value)
		}
	}
}

var jsonFieldsNameOfDataCollectionResultCommonModel = [4]string{
	0: "data_collection_id",
	1: "json_schema",
	2: "rationale",
	3: "value",
}

// Decode decodes DataCollectionResultCommonModel from json.
func (s *DataCollectionResultCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DataCollectionResultCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data_collection_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DataCollectionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data_collection_id\"")
			}
		case "json_schema":
			if err := func() error {
				s.JSONSchema.Reset()
				if err := s.JSONSchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"json_schema\"")
			}
		case "rationale":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Rationale = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		case "value":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Value = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DataCollectionResultCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDataCollectionResultCommonModel) {
					name = jsonFieldsNameOfDataCollectionResultCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DataCollectionResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DataCollectionResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DefaultConversationInitiationTrigger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DefaultConversationInitiationTrigger) encodeFields(e *jx.Encoder) {
	{
		if s.TriggerType.Set {
			e.FieldStart("trigger_type")
			s.TriggerType.Encode(e)
		}
	}
}

var jsonFieldsNameOfDefaultConversationInitiationTrigger = [1]string{
	0: "trigger_type",
}

// Decode decodes DefaultConversationInitiationTrigger from json.
func (s *DefaultConversationInitiationTrigger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefaultConversationInitiationTrigger to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trigger_type":
			if err := func() error {
				s.TriggerType.Reset()
				if err := s.TriggerType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefaultConversationInitiationTrigger")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DefaultConversationInitiationTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefaultConversationInitiationTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefaultConversationInitiationTriggerTriggerType as json.
func (s DefaultConversationInitiationTriggerTriggerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DefaultConversationInitiationTriggerTriggerType from json.
func (s *DefaultConversationInitiationTriggerTriggerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefaultConversationInitiationTriggerTriggerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DefaultConversationInitiationTriggerTriggerType(v) {
	case DefaultConversationInitiationTriggerTriggerTypeDefault:
		*s = DefaultConversationInitiationTriggerTriggerTypeDefault
	default:
		*s = DefaultConversationInitiationTriggerTriggerType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefaultConversationInitiationTriggerTriggerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefaultConversationInitiationTriggerTriggerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteChapterResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteChapterResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteChapterResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteChapterResponseModel from json.
func (s *DeleteChapterResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteChapterResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteChapterResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteChapterResponseModel) {
					name = jsonFieldsNameOfDeleteChapterResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteChapterResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteChapterResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteChatResponseTestRouteOKApplicationJSON as json.
func (s DeleteChatResponseTestRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteChatResponseTestRouteOKApplicationJSON from json.
func (s *DeleteChatResponseTestRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteChatResponseTestRouteOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteChatResponseTestRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteChatResponseTestRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteChatResponseTestRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteConversationRouteOKApplicationJSON as json.
func (s DeleteConversationRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteConversationRouteOKApplicationJSON from json.
func (s *DeleteConversationRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteConversationRouteOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteConversationRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteConversationRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteConversationRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteDubbingResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteDubbingResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteDubbingResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteDubbingResponseModel from json.
func (s *DeleteDubbingResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDubbingResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteDubbingResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteDubbingResponseModel) {
					name = jsonFieldsNameOfDeleteDubbingResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDubbingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDubbingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHistoryItemResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHistoryItemResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteHistoryItemResponse = [1]string{
	0: "status",
}

// Decode decodes DeleteHistoryItemResponse from json.
func (s *DeleteHistoryItemResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHistoryItemResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHistoryItemResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHistoryItemResponse) {
					name = jsonFieldsNameOfDeleteHistoryItemResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHistoryItemResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHistoryItemResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteKnowledgeBaseDocumentOKApplicationJSON as json.
func (s DeleteKnowledgeBaseDocumentOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteKnowledgeBaseDocumentOKApplicationJSON from json.
func (s *DeleteKnowledgeBaseDocumentOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteKnowledgeBaseDocumentOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteKnowledgeBaseDocumentOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteKnowledgeBaseDocumentOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteKnowledgeBaseDocumentOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteMcpServerRouteOKApplicationJSON as json.
func (s DeleteMcpServerRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteMcpServerRouteOKApplicationJSON from json.
func (s *DeleteMcpServerRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteMcpServerRouteOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteMcpServerRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteMcpServerRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteMcpServerRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeletePhoneNumberRouteOKApplicationJSON as json.
func (s DeletePhoneNumberRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeletePhoneNumberRouteOKApplicationJSON from json.
func (s *DeletePhoneNumberRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeletePhoneNumberRouteOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeletePhoneNumberRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeletePhoneNumberRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeletePhoneNumberRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteProjectResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteProjectResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteProjectResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteProjectResponseModel from json.
func (s *DeleteProjectResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteProjectResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteProjectResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteProjectResponseModel) {
					name = jsonFieldsNameOfDeleteProjectResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteProjectResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteProjectResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSampleResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSampleResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteSampleResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteSampleResponseModel from json.
func (s *DeleteSampleResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSampleResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSampleResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSampleResponseModel) {
					name = jsonFieldsNameOfDeleteSampleResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSampleResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSampleResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceAccountAPIKeyOKApplicationJSON as json.
func (s DeleteServiceAccountAPIKeyOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteServiceAccountAPIKeyOKApplicationJSON from json.
func (s *DeleteServiceAccountAPIKeyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceAccountAPIKeyOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceAccountAPIKeyOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteServiceAccountAPIKeyOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceAccountAPIKeyOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteToolRouteOKApplicationJSON as json.
func (s DeleteToolRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteToolRouteOKApplicationJSON from json.
func (s *DeleteToolRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteToolRouteOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteToolRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteToolRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteToolRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteTranscriptByIDOKApplicationJSON as json.
func (s DeleteTranscriptByIDOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteTranscriptByIDOKApplicationJSON from json.
func (s *DeleteTranscriptByIDOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTranscriptByIDOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteTranscriptByIDOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteTranscriptByIDOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTranscriptByIDOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteTranscriptByIDUnauthorizedApplicationJSON as json.
func (s DeleteTranscriptByIDUnauthorizedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteTranscriptByIDUnauthorizedApplicationJSON from json.
func (s *DeleteTranscriptByIDUnauthorizedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteTranscriptByIDUnauthorizedApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteTranscriptByIDUnauthorizedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteTranscriptByIDUnauthorizedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteTranscriptByIDUnauthorizedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteVoiceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteVoiceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteVoiceResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteVoiceResponseModel from json.
func (s *DeleteVoiceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVoiceResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteVoiceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteVoiceResponseModel) {
					name = jsonFieldsNameOfDeleteVoiceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVoiceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVoiceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteVoiceSampleResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteVoiceSampleResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteVoiceSampleResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteVoiceSampleResponseModel from json.
func (s *DeleteVoiceSampleResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteVoiceSampleResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteVoiceSampleResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteVoiceSampleResponseModel) {
					name = jsonFieldsNameOfDeleteVoiceSampleResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteVoiceSampleResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteVoiceSampleResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteWhatsappAccountOKApplicationJSON as json.
func (s DeleteWhatsappAccountOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes DeleteWhatsappAccountOKApplicationJSON from json.
func (s *DeleteWhatsappAccountOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteWhatsappAccountOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteWhatsappAccountOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeleteWhatsappAccountOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteWhatsappAccountOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteWorkspaceGroupMemberResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteWorkspaceGroupMemberResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteWorkspaceGroupMemberResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteWorkspaceGroupMemberResponseModel from json.
func (s *DeleteWorkspaceGroupMemberResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteWorkspaceGroupMemberResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteWorkspaceGroupMemberResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteWorkspaceGroupMemberResponseModel) {
					name = jsonFieldsNameOfDeleteWorkspaceGroupMemberResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteWorkspaceGroupMemberResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteWorkspaceGroupMemberResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteWorkspaceInviteResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteWorkspaceInviteResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteWorkspaceInviteResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteWorkspaceInviteResponseModel from json.
func (s *DeleteWorkspaceInviteResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteWorkspaceInviteResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteWorkspaceInviteResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteWorkspaceInviteResponseModel) {
					name = jsonFieldsNameOfDeleteWorkspaceInviteResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteWorkspaceInviteResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteWorkspaceInviteResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteWorkspaceWebhookResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteWorkspaceWebhookResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfDeleteWorkspaceWebhookResponseModel = [1]string{
	0: "status",
}

// Decode decodes DeleteWorkspaceWebhookResponseModel from json.
func (s *DeleteWorkspaceWebhookResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteWorkspaceWebhookResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteWorkspaceWebhookResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteWorkspaceWebhookResponseModel) {
					name = jsonFieldsNameOfDeleteWorkspaceWebhookResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteWorkspaceWebhookResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteWorkspaceWebhookResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DependentAvailableAgentIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DependentAvailableAgentIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_level")
		s.AccessLevel.Encode(e)
	}
	{
		e.FieldStart("created_at_unix_secs")
		e.Int(s.CreatedAtUnixSecs)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.ReferencedResourceIds != nil {
			e.FieldStart("referenced_resource_ids")
			e.ArrStart()
			for _, elem := range s.ReferencedResourceIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDependentAvailableAgentIdentifier = [6]string{
	0: "access_level",
	1: "created_at_unix_secs",
	2: "id",
	3: "name",
	4: "referenced_resource_ids",
	5: "type",
}

// Decode decodes DependentAvailableAgentIdentifier from json.
func (s *DependentAvailableAgentIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentAvailableAgentIdentifier to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_level\"")
			}
		case "created_at_unix_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix_secs\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "referenced_resource_ids":
			if err := func() error {
				s.ReferencedResourceIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ReferencedResourceIds = append(s.ReferencedResourceIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenced_resource_ids\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DependentAvailableAgentIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDependentAvailableAgentIdentifier) {
					name = jsonFieldsNameOfDependentAvailableAgentIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DependentAvailableAgentIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentAvailableAgentIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentAvailableAgentIdentifierAccessLevel as json.
func (s DependentAvailableAgentIdentifierAccessLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DependentAvailableAgentIdentifierAccessLevel from json.
func (s *DependentAvailableAgentIdentifierAccessLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentAvailableAgentIdentifierAccessLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DependentAvailableAgentIdentifierAccessLevel(v) {
	case DependentAvailableAgentIdentifierAccessLevelAdmin:
		*s = DependentAvailableAgentIdentifierAccessLevelAdmin
	case DependentAvailableAgentIdentifierAccessLevelEditor:
		*s = DependentAvailableAgentIdentifierAccessLevelEditor
	case DependentAvailableAgentIdentifierAccessLevelCommenter:
		*s = DependentAvailableAgentIdentifierAccessLevelCommenter
	case DependentAvailableAgentIdentifierAccessLevelViewer:
		*s = DependentAvailableAgentIdentifierAccessLevelViewer
	default:
		*s = DependentAvailableAgentIdentifierAccessLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DependentAvailableAgentIdentifierAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentAvailableAgentIdentifierAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentAvailableAgentIdentifierType as json.
func (s DependentAvailableAgentIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DependentAvailableAgentIdentifierType from json.
func (s *DependentAvailableAgentIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentAvailableAgentIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DependentAvailableAgentIdentifierType(v) {
	case DependentAvailableAgentIdentifierTypeAvailable:
		*s = DependentAvailableAgentIdentifierTypeAvailable
	default:
		*s = DependentAvailableAgentIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DependentAvailableAgentIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentAvailableAgentIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DependentAvailableToolIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DependentAvailableToolIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_level")
		s.AccessLevel.Encode(e)
	}
	{
		e.FieldStart("created_at_unix_secs")
		e.Int(s.CreatedAtUnixSecs)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDependentAvailableToolIdentifier = [5]string{
	0: "access_level",
	1: "created_at_unix_secs",
	2: "id",
	3: "name",
	4: "type",
}

// Decode decodes DependentAvailableToolIdentifier from json.
func (s *DependentAvailableToolIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentAvailableToolIdentifier to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_level\"")
			}
		case "created_at_unix_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix_secs\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DependentAvailableToolIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDependentAvailableToolIdentifier) {
					name = jsonFieldsNameOfDependentAvailableToolIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DependentAvailableToolIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentAvailableToolIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentAvailableToolIdentifierAccessLevel as json.
func (s DependentAvailableToolIdentifierAccessLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DependentAvailableToolIdentifierAccessLevel from json.
func (s *DependentAvailableToolIdentifierAccessLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentAvailableToolIdentifierAccessLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DependentAvailableToolIdentifierAccessLevel(v) {
	case DependentAvailableToolIdentifierAccessLevelAdmin:
		*s = DependentAvailableToolIdentifierAccessLevelAdmin
	case DependentAvailableToolIdentifierAccessLevelEditor:
		*s = DependentAvailableToolIdentifierAccessLevelEditor
	case DependentAvailableToolIdentifierAccessLevelCommenter:
		*s = DependentAvailableToolIdentifierAccessLevelCommenter
	case DependentAvailableToolIdentifierAccessLevelViewer:
		*s = DependentAvailableToolIdentifierAccessLevelViewer
	default:
		*s = DependentAvailableToolIdentifierAccessLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DependentAvailableToolIdentifierAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentAvailableToolIdentifierAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentAvailableToolIdentifierType as json.
func (s DependentAvailableToolIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DependentAvailableToolIdentifierType from json.
func (s *DependentAvailableToolIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentAvailableToolIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DependentAvailableToolIdentifierType(v) {
	case DependentAvailableToolIdentifierTypeAvailable:
		*s = DependentAvailableToolIdentifierTypeAvailable
	default:
		*s = DependentAvailableToolIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DependentAvailableToolIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentAvailableToolIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DependentPhoneNumberIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DependentPhoneNumberIdentifier) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfDependentPhoneNumberIdentifier = [4]string{
	0: "label",
	1: "phone_number",
	2: "phone_number_id",
	3: "provider",
}

// Decode decodes DependentPhoneNumberIdentifier from json.
func (s *DependentPhoneNumberIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentPhoneNumberIdentifier to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "label":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DependentPhoneNumberIdentifier")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDependentPhoneNumberIdentifier) {
					name = jsonFieldsNameOfDependentPhoneNumberIdentifier[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DependentPhoneNumberIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentPhoneNumberIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DependentUnknownAgentIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DependentUnknownAgentIdentifier) encodeFields(e *jx.Encoder) {
	{
		if s.ReferencedResourceIds != nil {
			e.FieldStart("referenced_resource_ids")
			e.ArrStart()
			for _, elem := range s.ReferencedResourceIds {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDependentUnknownAgentIdentifier = [2]string{
	0: "referenced_resource_ids",
	1: "type",
}

// Decode decodes DependentUnknownAgentIdentifier from json.
func (s *DependentUnknownAgentIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentUnknownAgentIdentifier to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "referenced_resource_ids":
			if err := func() error {
				s.ReferencedResourceIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ReferencedResourceIds = append(s.ReferencedResourceIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenced_resource_ids\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DependentUnknownAgentIdentifier")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DependentUnknownAgentIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentUnknownAgentIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentUnknownAgentIdentifierType as json.
func (s DependentUnknownAgentIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DependentUnknownAgentIdentifierType from json.
func (s *DependentUnknownAgentIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentUnknownAgentIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DependentUnknownAgentIdentifierType(v) {
	case DependentUnknownAgentIdentifierTypeUnknown:
		*s = DependentUnknownAgentIdentifierTypeUnknown
	default:
		*s = DependentUnknownAgentIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DependentUnknownAgentIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentUnknownAgentIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DependentUnknownToolIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DependentUnknownToolIdentifier) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfDependentUnknownToolIdentifier = [1]string{
	0: "type",
}

// Decode decodes DependentUnknownToolIdentifier from json.
func (s *DependentUnknownToolIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentUnknownToolIdentifier to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DependentUnknownToolIdentifier")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DependentUnknownToolIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentUnknownToolIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentUnknownToolIdentifierType as json.
func (s DependentUnknownToolIdentifierType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DependentUnknownToolIdentifierType from json.
func (s *DependentUnknownToolIdentifierType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DependentUnknownToolIdentifierType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DependentUnknownToolIdentifierType(v) {
	case DependentUnknownToolIdentifierTypeUnknown:
		*s = DependentUnknownToolIdentifierTypeUnknown
	default:
		*s = DependentUnknownToolIdentifierType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DependentUnknownToolIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DependentUnknownToolIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfDialogueInput = [2]string{
	0: "text",
	1: "voice_id",
}

// Decode decodes DialogueInput from json.
func (s *DialogueInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogueInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDialogueInput) {
					name = jsonFieldsNameOfDialogueInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DialogueInputResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DialogueInputResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
	{
		e.FieldStart("voice_name")
		e.Str(s.VoiceName)
	}
}

var jsonFieldsNameOfDialogueInputResponseModel = [3]string{
	0: "text",
	1: "voice_id",
	2: "voice_name",
}

// Decode decodes DialogueInputResponseModel from json.
func (s *DialogueInputResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DialogueInputResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		case "voice_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VoiceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DialogueInputResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDialogueInputResponseModel) {
					name = jsonFieldsNameOfDialogueInputResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DialogueInputResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DialogueInputResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DoDubbingResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DoDubbingResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dubbing_id")
		e.Str(s.DubbingID)
	}
	{
		e.FieldStart("expected_duration_sec")
		e.Float64(s.ExpectedDurationSec)
	}
}

var jsonFieldsNameOfDoDubbingResponseModel = [2]string{
	0: "dubbing_id",
	1: "expected_duration_sec",
}

// Decode decodes DoDubbingResponseModel from json.
func (s *DoDubbingResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DoDubbingResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dubbing_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DubbingID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dubbing_id\"")
			}
		case "expected_duration_sec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.ExpectedDurationSec = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_duration_sec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DoDubbingResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDoDubbingResponseModel) {
					name = jsonFieldsNameOfDoDubbingResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DoDubbingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DoDubbingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DocumentUsageModeEnum as json.
func (s DocumentUsageModeEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DocumentUsageModeEnum from json.
func (s *DocumentUsageModeEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DocumentUsageModeEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DocumentUsageModeEnum(v) {
	case DocumentUsageModeEnumPrompt:
		*s = DocumentUsageModeEnumPrompt
	case DocumentUsageModeEnumAuto:
		*s = DocumentUsageModeEnumAuto
	default:
		*s = DocumentUsageModeEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DocumentUsageModeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DocumentUsageModeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DocxExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DocxExportOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		if s.IncludeSpeakers.Set {
			e.FieldStart("include_speakers")
			s.IncludeSpeakers.Encode(e)
		}
	}
	{
		if s.IncludeTimestamps.Set {
			e.FieldStart("include_timestamps")
			s.IncludeTimestamps.Encode(e)
		}
	}
	{
		if s.MaxSegmentChars.Set {
			e.FieldStart("max_segment_chars")
			s.MaxSegmentChars.Encode(e)
		}
	}
	{
		if s.MaxSegmentDurationS.Set {
			e.FieldStart("max_segment_duration_s")
			s.MaxSegmentDurationS.Encode(e)
		}
	}
	{
		if s.SegmentOnSilenceLongerThanS.Set {
			e.FieldStart("segment_on_silence_longer_than_s")
			s.SegmentOnSilenceLongerThanS.Encode(e)
		}
	}
}

var jsonFieldsNameOfDocxExportOptions = [6]string{
	0: "format",
	1: "include_speakers",
	2: "include_timestamps",
	3: "max_segment_chars",
	4: "max_segment_duration_s",
	5: "segment_on_silence_longer_than_s",
}

// Decode decodes DocxExportOptions from json.
func (s *DocxExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DocxExportOptions to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "include_speakers":
			if err := func() error {
				s.IncludeSpeakers.Reset()
				if err := s.IncludeSpeakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_speakers\"")
			}
		case "include_timestamps":
			if err := func() error {
				s.IncludeTimestamps.Reset()
				if err := s.IncludeTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_timestamps\"")
			}
		case "max_segment_chars":
			if err := func() error {
				s.MaxSegmentChars.Reset()
				if err := s.MaxSegmentChars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_chars\"")
			}
		case "max_segment_duration_s":
			if err := func() error {
				s.MaxSegmentDurationS.Reset()
				if err := s.MaxSegmentDurationS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_duration_s\"")
			}
		case "segment_on_silence_longer_than_s":
			if err := func() error {
				s.SegmentOnSilenceLongerThanS.Reset()
				if err := s.SegmentOnSilenceLongerThanS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_on_silence_longer_than_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DocxExportOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDocxExportOptions) {
					name = jsonFieldsNameOfDocxExportOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DocxExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DocxExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DocxExportOptionsFormat as json.
func (s DocxExportOptionsFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DocxExportOptionsFormat from json.
func (s *DocxExportOptionsFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DocxExportOptionsFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DocxExportOptionsFormat(v) {
	case DocxExportOptionsFormatDocx:
		*s = DocxExportOptionsFormatDocx
	default:
		*s = DocxExportOptionsFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DocxExportOptionsFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DocxExportOptionsFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DownloadSpeechHistoryItemsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DownloadSpeechHistoryItemsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfDownloadSpeechHistoryItemsBadRequest = [2]string{
	0: "error",
	1: "message",
}

// Decode decodes DownloadSpeechHistoryItemsBadRequest from json.
func (s *DownloadSpeechHistoryItemsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DownloadSpeechHistoryItemsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DownloadSpeechHistoryItemsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DownloadSpeechHistoryItemsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DownloadSpeechHistoryItemsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbedSegment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbedSegment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audio_stale")
		e.Bool(s.AudioStale)
	}
	{
		e.FieldStart("end_time")
		e.Float64(s.EndTime)
	}
	{
		e.FieldStart("media_ref")
		s.MediaRef.Encode(e)
	}
	{
		e.FieldStart("start_time")
		e.Float64(s.StartTime)
	}
	{
		e.FieldStart("subtitles")
		e.ArrStart()
		for _, elem := range s.Subtitles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("text")
		s.Text.Encode(e)
	}
}

var jsonFieldsNameOfDubbedSegment = [6]string{
	0: "audio_stale",
	1: "end_time",
	2: "media_ref",
	3: "start_time",
	4: "subtitles",
	5: "text",
}

// Decode decodes DubbedSegment from json.
func (s *DubbedSegment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbedSegment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_stale":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AudioStale = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_stale\"")
			}
		case "end_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.EndTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "media_ref":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.MediaRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_ref\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.StartTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "subtitles":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Subtitles = make([]SegmentSubtitleFrame, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SegmentSubtitleFrame
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subtitles = append(s.Subtitles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtitles\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbedSegment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbedSegment) {
					name = jsonFieldsNameOfDubbedSegment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbedSegment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbedSegment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingMediaMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingMediaMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content_type")
		e.Str(s.ContentType)
	}
	{
		e.FieldStart("duration")
		e.Float64(s.Duration)
	}
}

var jsonFieldsNameOfDubbingMediaMetadata = [2]string{
	0: "content_type",
	1: "duration",
}

// Decode decodes DubbingMediaMetadata from json.
func (s *DubbingMediaMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingMediaMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "duration":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Duration = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingMediaMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbingMediaMetadata) {
					name = jsonFieldsNameOfDubbingMediaMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingMediaMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingMediaMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingMediaReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingMediaReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bucket_name")
		e.Str(s.BucketName)
	}
	{
		e.FieldStart("content_type")
		e.Str(s.ContentType)
	}
	{
		e.FieldStart("duration_secs")
		e.Float64(s.DurationSecs)
	}
	{
		e.FieldStart("is_audio")
		e.Bool(s.IsAudio)
	}
	{
		e.FieldStart("random_path_slug")
		e.Str(s.RandomPathSlug)
	}
	{
		e.FieldStart("src")
		e.Str(s.Src)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfDubbingMediaReference = [7]string{
	0: "bucket_name",
	1: "content_type",
	2: "duration_secs",
	3: "is_audio",
	4: "random_path_slug",
	5: "src",
	6: "url",
}

// Decode decodes DubbingMediaReference from json.
func (s *DubbingMediaReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingMediaReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bucket_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BucketName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucket_name\"")
			}
		case "content_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "duration_secs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.DurationSecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "is_audio":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsAudio = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_audio\"")
			}
		case "random_path_slug":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RandomPathSlug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"random_path_slug\"")
			}
		case "src":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Src = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"src\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingMediaReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbingMediaReference) {
					name = jsonFieldsNameOfDubbingMediaReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingMediaReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingMediaReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingMetadataPageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingMetadataPageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dubs")
		e.ArrStart()
		for _, elem := range s.Dubs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		e.FieldStart("next_cursor")
		s.NextCursor.Encode(e)
	}
}

var jsonFieldsNameOfDubbingMetadataPageResponseModel = [3]string{
	0: "dubs",
	1: "has_more",
	2: "next_cursor",
}

// Decode decodes DubbingMetadataPageResponseModel from json.
func (s *DubbingMetadataPageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingMetadataPageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dubs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Dubs = make([]DubbingMetadataResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DubbingMetadataResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Dubs = append(s.Dubs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dubs\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingMetadataPageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbingMetadataPageResponseModel) {
					name = jsonFieldsNameOfDubbingMetadataPageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingMetadataPageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingMetadataPageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingMetadataResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingMetadataResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("dubbing_id")
		e.Str(s.DubbingID)
	}
	{
		if s.Editable.Set {
			e.FieldStart("editable")
			s.Editable.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.MediaMetadata.Set {
			e.FieldStart("media_metadata")
			s.MediaMetadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("target_languages")
		e.ArrStart()
		for _, elem := range s.TargetLanguages {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDubbingMetadataResponse = [8]string{
	0: "created_at",
	1: "dubbing_id",
	2: "editable",
	3: "error",
	4: "media_metadata",
	5: "name",
	6: "status",
	7: "target_languages",
}

// Decode decodes DubbingMetadataResponse from json.
func (s *DubbingMetadataResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingMetadataResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "dubbing_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DubbingID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dubbing_id\"")
			}
		case "editable":
			if err := func() error {
				s.Editable.Reset()
				if err := s.Editable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"editable\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "media_metadata":
			if err := func() error {
				s.MediaMetadata.Reset()
				if err := s.MediaMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "target_languages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.TargetLanguages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TargetLanguages = append(s.TargetLanguages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_languages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingMetadataResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbingMetadataResponse) {
					name = jsonFieldsNameOfDubbingMetadataResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingMetadataResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingMetadataResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingResource) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("background")
		s.Background.Encode(e)
	}
	{
		e.FieldStart("foreground")
		s.Foreground.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("input")
		s.Input.Encode(e)
	}
	{
		e.FieldStart("renders")
		s.Renders.Encode(e)
	}
	{
		e.FieldStart("source_language")
		e.Str(s.SourceLanguage)
	}
	{
		e.FieldStart("speaker_segments")
		s.SpeakerSegments.Encode(e)
	}
	{
		e.FieldStart("speaker_tracks")
		s.SpeakerTracks.Encode(e)
	}
	{
		e.FieldStart("target_languages")
		e.ArrStart()
		for _, elem := range s.TargetLanguages {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfDubbingResource = [10]string{
	0: "background",
	1: "foreground",
	2: "id",
	3: "input",
	4: "renders",
	5: "source_language",
	6: "speaker_segments",
	7: "speaker_tracks",
	8: "target_languages",
	9: "version",
}

// Decode decodes DubbingResource from json.
func (s *DubbingResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingResource to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "background":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Background.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"background\"")
			}
		case "foreground":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Foreground.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"foreground\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "input":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "renders":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Renders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"renders\"")
			}
		case "source_language":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SourceLanguage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_language\"")
			}
		case "speaker_segments":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.SpeakerSegments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_segments\"")
			}
		case "speaker_tracks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.SpeakerTracks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_tracks\"")
			}
		case "target_languages":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.TargetLanguages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TargetLanguages = append(s.TargetLanguages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_languages\"")
			}
		case "version":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingResource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbingResource) {
					name = jsonFieldsNameOfDubbingResource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DubbingResourceRenders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DubbingResourceRenders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DubbingResourceRenders from json.
func (s *DubbingResourceRenders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingResourceRenders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem Render
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingResourceRenders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DubbingResourceRenders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingResourceRenders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DubbingResourceSpeakerSegments) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DubbingResourceSpeakerSegments) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DubbingResourceSpeakerSegments from json.
func (s *DubbingResourceSpeakerSegments) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingResourceSpeakerSegments to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SpeakerSegment
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingResourceSpeakerSegments")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DubbingResourceSpeakerSegments) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingResourceSpeakerSegments) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DubbingResourceSpeakerTracks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DubbingResourceSpeakerTracks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DubbingResourceSpeakerTracks from json.
func (s *DubbingResourceSpeakerTracks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingResourceSpeakerTracks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SpeakerTrack
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingResourceSpeakerTracks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DubbingResourceSpeakerTracks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingResourceSpeakerTracks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingTranscriptCharacter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingTranscriptCharacter) encodeFields(e *jx.Encoder) {
	{
		if s.EndS.Set {
			e.FieldStart("end_s")
			s.EndS.Encode(e)
		}
	}
	{
		if s.StartS.Set {
			e.FieldStart("start_s")
			s.StartS.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfDubbingTranscriptCharacter = [3]string{
	0: "end_s",
	1: "start_s",
	2: "text",
}

// Decode decodes DubbingTranscriptCharacter from json.
func (s *DubbingTranscriptCharacter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingTranscriptCharacter to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end_s":
			if err := func() error {
				s.EndS.Reset()
				if err := s.EndS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_s\"")
			}
		case "start_s":
			if err := func() error {
				s.StartS.Reset()
				if err := s.StartS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_s\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingTranscriptCharacter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingTranscriptCharacter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingTranscriptCharacter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingTranscriptResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingTranscriptResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("language")
		e.Str(s.Language)
	}
	{
		e.FieldStart("utterances")
		e.ArrStart()
		for _, elem := range s.Utterances {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDubbingTranscriptResponseModel = [2]string{
	0: "language",
	1: "utterances",
}

// Decode decodes DubbingTranscriptResponseModel from json.
func (s *DubbingTranscriptResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingTranscriptResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Language = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "utterances":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Utterances = make([]DubbingTranscriptUtterance, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DubbingTranscriptUtterance
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Utterances = append(s.Utterances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utterances\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingTranscriptResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDubbingTranscriptResponseModel) {
					name = jsonFieldsNameOfDubbingTranscriptResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingTranscriptResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingTranscriptResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingTranscriptUtterance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingTranscriptUtterance) encodeFields(e *jx.Encoder) {
	{
		if s.EndS.Set {
			e.FieldStart("end_s")
			s.EndS.Encode(e)
		}
	}
	{
		if s.SpeakerID.Set {
			e.FieldStart("speaker_id")
			s.SpeakerID.Encode(e)
		}
	}
	{
		if s.StartS.Set {
			e.FieldStart("start_s")
			s.StartS.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Words != nil {
			e.FieldStart("words")
			e.ArrStart()
			for _, elem := range s.Words {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDubbingTranscriptUtterance = [5]string{
	0: "end_s",
	1: "speaker_id",
	2: "start_s",
	3: "text",
	4: "words",
}

// Decode decodes DubbingTranscriptUtterance from json.
func (s *DubbingTranscriptUtterance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingTranscriptUtterance to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end_s":
			if err := func() error {
				s.EndS.Reset()
				if err := s.EndS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_s\"")
			}
		case "speaker_id":
			if err := func() error {
				s.SpeakerID.Reset()
				if err := s.SpeakerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_id\"")
			}
		case "start_s":
			if err := func() error {
				s.StartS.Reset()
				if err := s.StartS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_s\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "words":
			if err := func() error {
				s.Words = make([]DubbingTranscriptWord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DubbingTranscriptWord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Words = append(s.Words, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"words\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingTranscriptUtterance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingTranscriptUtterance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingTranscriptUtterance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DubbingTranscriptWord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DubbingTranscriptWord) encodeFields(e *jx.Encoder) {
	{
		if s.Characters != nil {
			e.FieldStart("characters")
			e.ArrStart()
			for _, elem := range s.Characters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.EndS.Set {
			e.FieldStart("end_s")
			s.EndS.Encode(e)
		}
	}
	{
		if s.StartS.Set {
			e.FieldStart("start_s")
			s.StartS.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.WordType.Set {
			e.FieldStart("word_type")
			s.WordType.Encode(e)
		}
	}
}

var jsonFieldsNameOfDubbingTranscriptWord = [5]string{
	0: "characters",
	1: "end_s",
	2: "start_s",
	3: "text",
	4: "word_type",
}

// Decode decodes DubbingTranscriptWord from json.
func (s *DubbingTranscriptWord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DubbingTranscriptWord to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "characters":
			if err := func() error {
				s.Characters = make([]DubbingTranscriptCharacter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DubbingTranscriptCharacter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Characters = append(s.Characters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		case "end_s":
			if err := func() error {
				s.EndS.Reset()
				if err := s.EndS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_s\"")
			}
		case "start_s":
			if err := func() error {
				s.StartS.Reset()
				if err := s.StartS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_s\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "word_type":
			if err := func() error {
				s.WordType.Reset()
				if err := s.WordType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"word_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DubbingTranscriptWord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DubbingTranscriptWord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DubbingTranscriptWord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DynamicVariableAssignment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DynamicVariableAssignment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dynamic_variable")
		e.Str(s.DynamicVariable)
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		e.FieldStart("value_path")
		e.Str(s.ValuePath)
	}
}

var jsonFieldsNameOfDynamicVariableAssignment = [3]string{
	0: "dynamic_variable",
	1: "source",
	2: "value_path",
}

// Decode decodes DynamicVariableAssignment from json.
func (s *DynamicVariableAssignment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DynamicVariableAssignment to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dynamic_variable":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DynamicVariable = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "value_path":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ValuePath = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DynamicVariableAssignment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDynamicVariableAssignment) {
					name = jsonFieldsNameOfDynamicVariableAssignment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DynamicVariableAssignment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DynamicVariableAssignment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DynamicVariableAssignmentSource as json.
func (s DynamicVariableAssignmentSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DynamicVariableAssignmentSource from json.
func (s *DynamicVariableAssignmentSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DynamicVariableAssignmentSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DynamicVariableAssignmentSource(v) {
	case DynamicVariableAssignmentSourceResponse:
		*s = DynamicVariableAssignmentSourceResponse
	default:
		*s = DynamicVariableAssignmentSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DynamicVariableAssignmentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DynamicVariableAssignmentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DynamicVariableUpdateCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DynamicVariableUpdateCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("new_value")
		e.Str(s.NewValue)
	}
	{
		e.FieldStart("old_value")
		s.OldValue.Encode(e)
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
	{
		e.FieldStart("tool_request_id")
		e.Str(s.ToolRequestID)
	}
	{
		e.FieldStart("updated_at")
		e.Float64(s.UpdatedAt)
	}
	{
		e.FieldStart("variable_name")
		e.Str(s.VariableName)
	}
}

var jsonFieldsNameOfDynamicVariableUpdateCommonModel = [6]string{
	0: "new_value",
	1: "old_value",
	2: "tool_name",
	3: "tool_request_id",
	4: "updated_at",
	5: "variable_name",
}

// Decode decodes DynamicVariableUpdateCommonModel from json.
func (s *DynamicVariableUpdateCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DynamicVariableUpdateCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_value\"")
			}
		case "old_value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.OldValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_value\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		case "tool_request_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ToolRequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_request_id\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UpdatedAt = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		case "variable_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.VariableName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variable_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DynamicVariableUpdateCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDynamicVariableUpdateCommonModel) {
					name = jsonFieldsNameOfDynamicVariableUpdateCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DynamicVariableUpdateCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DynamicVariableUpdateCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditProjectResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditProjectResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("project")
		s.Project.Encode(e)
	}
}

var jsonFieldsNameOfEditProjectResponseModel = [1]string{
	0: "project",
}

// Decode decodes EditProjectResponseModel from json.
func (s *EditProjectResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditProjectResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "project":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Project.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditProjectResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditProjectResponseModel) {
					name = jsonFieldsNameOfEditProjectResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditProjectResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditProjectResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditServiceAccountAPIKeyOKApplicationJSON as json.
func (s EditServiceAccountAPIKeyOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes EditServiceAccountAPIKeyOKApplicationJSON from json.
func (s *EditServiceAccountAPIKeyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditServiceAccountAPIKeyOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EditServiceAccountAPIKeyOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditServiceAccountAPIKeyOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditServiceAccountAPIKeyOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditVoiceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVoiceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfEditVoiceResponseModel = [1]string{
	0: "status",
}

// Decode decodes EditVoiceResponseModel from json.
func (s *EditVoiceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVoiceResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVoiceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditVoiceResponseModel) {
					name = jsonFieldsNameOfEditVoiceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVoiceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVoiceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditVoiceSettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditVoiceSettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfEditVoiceSettingsResponseModel = [1]string{
	0: "status",
}

// Decode decodes EditVoiceSettingsResponseModel from json.
func (s *EditVoiceSettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditVoiceSettingsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditVoiceSettingsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditVoiceSettingsResponseModel) {
					name = jsonFieldsNameOfEditVoiceSettingsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditVoiceSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditVoiceSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EmbeddingModelEnum as json.
func (s EmbeddingModelEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EmbeddingModelEnum from json.
func (s *EmbeddingModelEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EmbeddingModelEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EmbeddingModelEnum(v) {
	case EmbeddingModelEnumE5Mistral7bInstruct:
		*s = EmbeddingModelEnumE5Mistral7bInstruct
	case EmbeddingModelEnumMultilingualE5LargeInstruct:
		*s = EmbeddingModelEnumMultilingualE5LargeInstruct
	default:
		*s = EmbeddingModelEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EmbeddingModelEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EmbeddingModelEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EndCallToolResultModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EndCallToolResultModel) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfEndCallToolResultModel = [4]string{
	0: "message",
	1: "reason",
	2: "result_type",
	3: "status",
}

// Decode decodes EndCallToolResultModel from json.
func (s *EndCallToolResultModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndCallToolResultModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EndCallToolResultModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EndCallToolResultModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndCallToolResultModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndCallToolResultModelResultType as json.
func (s EndCallToolResultModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EndCallToolResultModelResultType from json.
func (s *EndCallToolResultModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndCallToolResultModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EndCallToolResultModelResultType(v) {
	case EndCallToolResultModelResultTypeEndCallSuccess:
		*s = EndCallToolResultModelResultTypeEndCallSuccess
	default:
		*s = EndCallToolResultModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EndCallToolResultModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndCallToolResultModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndCallToolResultModelStatus as json.
func (s EndCallToolResultModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EndCallToolResultModelStatus from json.
func (s *EndCallToolResultModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EndCallToolResultModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EndCallToolResultModelStatus(v) {
	case EndCallToolResultModelStatusSuccess:
		*s = EndCallToolResultModelStatusSuccess
	default:
		*s = EndCallToolResultModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EndCallToolResultModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EndCallToolResultModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationSuccessResult as json.
func (s EvaluationSuccessResult) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EvaluationSuccessResult from json.
func (s *EvaluationSuccessResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationSuccessResult to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EvaluationSuccessResult(v) {
	case EvaluationSuccessResultSuccess:
		*s = EvaluationSuccessResultSuccess
	case EvaluationSuccessResultFailure:
		*s = EvaluationSuccessResultFailure
	case EvaluationSuccessResultUnknown:
		*s = EvaluationSuccessResultUnknown
	default:
		*s = EvaluationSuccessResult(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EvaluationSuccessResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationSuccessResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExactParameterEvaluationStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExactParameterEvaluationStrategy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("expected_value")
		e.Str(s.ExpectedValue)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfExactParameterEvaluationStrategy = [2]string{
	0: "expected_value",
	1: "type",
}

// Decode decodes ExactParameterEvaluationStrategy from json.
func (s *ExactParameterEvaluationStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExactParameterEvaluationStrategy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expected_value":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExpectedValue = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expected_value\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExactParameterEvaluationStrategy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExactParameterEvaluationStrategy) {
					name = jsonFieldsNameOfExactParameterEvaluationStrategy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExactParameterEvaluationStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExactParameterEvaluationStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExactParameterEvaluationStrategyType as json.
func (s ExactParameterEvaluationStrategyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ExactParameterEvaluationStrategyType from json.
func (s *ExactParameterEvaluationStrategyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExactParameterEvaluationStrategyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ExactParameterEvaluationStrategyType(v) {
	case ExactParameterEvaluationStrategyTypeExact:
		*s = ExactParameterEvaluationStrategyTypeExact
	default:
		*s = ExactParameterEvaluationStrategyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExactParameterEvaluationStrategyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExactParameterEvaluationStrategyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExportOptions as json.
func (s ExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ExportOptions) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case SegmentedJsonExportOptionsExportOptions:
		e.FieldStart("format")
		e.Str("segmented_json")
		{
			s := s.SegmentedJsonExportOptions
			{
				if s.IncludeSpeakers.Set {
					e.FieldStart("include_speakers")
					s.IncludeSpeakers.Encode(e)
				}
			}
			{
				if s.IncludeTimestamps.Set {
					e.FieldStart("include_timestamps")
					s.IncludeTimestamps.Encode(e)
				}
			}
			{
				if s.MaxSegmentChars.Set {
					e.FieldStart("max_segment_chars")
					s.MaxSegmentChars.Encode(e)
				}
			}
			{
				if s.MaxSegmentDurationS.Set {
					e.FieldStart("max_segment_duration_s")
					s.MaxSegmentDurationS.Encode(e)
				}
			}
			{
				if s.SegmentOnSilenceLongerThanS.Set {
					e.FieldStart("segment_on_silence_longer_than_s")
					s.SegmentOnSilenceLongerThanS.Encode(e)
				}
			}
		}
	case DocxExportOptionsExportOptions:
		e.FieldStart("format")
		e.Str("docx")
		{
			s := s.DocxExportOptions
			{
				if s.IncludeSpeakers.Set {
					e.FieldStart("include_speakers")
					s.IncludeSpeakers.Encode(e)
				}
			}
			{
				if s.IncludeTimestamps.Set {
					e.FieldStart("include_timestamps")
					s.IncludeTimestamps.Encode(e)
				}
			}
			{
				if s.MaxSegmentChars.Set {
					e.FieldStart("max_segment_chars")
					s.MaxSegmentChars.Encode(e)
				}
			}
			{
				if s.MaxSegmentDurationS.Set {
					e.FieldStart("max_segment_duration_s")
					s.MaxSegmentDurationS.Encode(e)
				}
			}
			{
				if s.SegmentOnSilenceLongerThanS.Set {
					e.FieldStart("segment_on_silence_longer_than_s")
					s.SegmentOnSilenceLongerThanS.Encode(e)
				}
			}
		}
	case PdfExportOptionsExportOptions:
		e.FieldStart("format")
		e.Str("pdf")
		{
			s := s.PdfExportOptions
			{
				if s.IncludeSpeakers.Set {
					e.FieldStart("include_speakers")
					s.IncludeSpeakers.Encode(e)
				}
			}
			{
				if s.IncludeTimestamps.Set {
					e.FieldStart("include_timestamps")
					s.IncludeTimestamps.Encode(e)
				}
			}
			{
				if s.MaxSegmentChars.Set {
					e.FieldStart("max_segment_chars")
					s.MaxSegmentChars.Encode(e)
				}
			}
			{
				if s.MaxSegmentDurationS.Set {
					e.FieldStart("max_segment_duration_s")
					s.MaxSegmentDurationS.Encode(e)
				}
			}
			{
				if s.SegmentOnSilenceLongerThanS.Set {
					e.FieldStart("segment_on_silence_longer_than_s")
					s.SegmentOnSilenceLongerThanS.Encode(e)
				}
			}
		}
	case TxtExportOptionsExportOptions:
		e.FieldStart("format")
		e.Str("txt")
		{
			s := s.TxtExportOptions
			{
				if s.IncludeSpeakers.Set {
					e.FieldStart("include_speakers")
					s.IncludeSpeakers.Encode(e)
				}
			}
			{
				if s.IncludeTimestamps.Set {
					e.FieldStart("include_timestamps")
					s.IncludeTimestamps.Encode(e)
				}
			}
			{
				if s.MaxCharactersPerLine.Set {
					e.FieldStart("max_characters_per_line")
					s.MaxCharactersPerLine.Encode(e)
				}
			}
			{
				if s.MaxSegmentChars.Set {
					e.FieldStart("max_segment_chars")
					s.MaxSegmentChars.Encode(e)
				}
			}
			{
				if s.MaxSegmentDurationS.Set {
					e.FieldStart("max_segment_duration_s")
					s.MaxSegmentDurationS.Encode(e)
				}
			}
			{
				if s.SegmentOnSilenceLongerThanS.Set {
					e.FieldStart("segment_on_silence_longer_than_s")
					s.SegmentOnSilenceLongerThanS.Encode(e)
				}
			}
		}
	case HtmlExportOptionsExportOptions:
		e.FieldStart("format")
		e.Str("html")
		{
			s := s.HtmlExportOptions
			{
				if s.IncludeSpeakers.Set {
					e.FieldStart("include_speakers")
					s.IncludeSpeakers.Encode(e)
				}
			}
			{
				if s.IncludeTimestamps.Set {
					e.FieldStart("include_timestamps")
					s.IncludeTimestamps.Encode(e)
				}
			}
			{
				if s.MaxSegmentChars.Set {
					e.FieldStart("max_segment_chars")
					s.MaxSegmentChars.Encode(e)
				}
			}
			{
				if s.MaxSegmentDurationS.Set {
					e.FieldStart("max_segment_duration_s")
					s.MaxSegmentDurationS.Encode(e)
				}
			}
			{
				if s.SegmentOnSilenceLongerThanS.Set {
					e.FieldStart("segment_on_silence_longer_than_s")
					s.SegmentOnSilenceLongerThanS.Encode(e)
				}
			}
		}
	case SrtExportOptionsExportOptions:
		e.FieldStart("format")
		e.Str("srt")
		{
			s := s.SrtExportOptions
			{
				if s.IncludeSpeakers.Set {
					e.FieldStart("include_speakers")
					s.IncludeSpeakers.Encode(e)
				}
			}
			{
				if s.IncludeTimestamps.Set {
					e.FieldStart("include_timestamps")
					s.IncludeTimestamps.Encode(e)
				}
			}
			{
				if s.MaxCharactersPerLine.Set {
					e.FieldStart("max_characters_per_line")
					s.MaxCharactersPerLine.Encode(e)
				}
			}
			{
				if s.MaxSegmentChars.Set {
					e.FieldStart("max_segment_chars")
					s.MaxSegmentChars.Encode(e)
				}
			}
			{
				if s.MaxSegmentDurationS.Set {
					e.FieldStart("max_segment_duration_s")
					s.MaxSegmentDurationS.Encode(e)
				}
			}
			{
				if s.SegmentOnSilenceLongerThanS.Set {
					e.FieldStart("segment_on_silence_longer_than_s")
					s.SegmentOnSilenceLongerThanS.Encode(e)
				}
			}
		}
	}
}

// Decode decodes ExportOptions from json.
func (s *ExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExportOptions to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "format":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "segmented_json":
					s.Type = SegmentedJsonExportOptionsExportOptions
					found = true
				case "docx":
					s.Type = DocxExportOptionsExportOptions
					found = true
				case "pdf":
					s.Type = PdfExportOptionsExportOptions
					found = true
				case "txt":
					s.Type = TxtExportOptionsExportOptions
					found = true
				case "html":
					s.Type = HtmlExportOptionsExportOptions
					found = true
				case "srt":
					s.Type = SrtExportOptionsExportOptions
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SegmentedJsonExportOptionsExportOptions:
		if err := s.SegmentedJsonExportOptions.Decode(d); err != nil {
			return err
		}
	case DocxExportOptionsExportOptions:
		if err := s.DocxExportOptions.Decode(d); err != nil {
			return err
		}
	case PdfExportOptionsExportOptions:
		if err := s.PdfExportOptions.Decode(d); err != nil {
			return err
		}
	case TxtExportOptionsExportOptions:
		if err := s.TxtExportOptions.Decode(d); err != nil {
			return err
		}
	case HtmlExportOptionsExportOptions:
		if err := s.HtmlExportOptions.Decode(d); err != nil {
			return err
		}
	case SrtExportOptionsExportOptions:
		if err := s.SrtExportOptions.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeatureStatusCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeatureStatusCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
}

var jsonFieldsNameOfFeatureStatusCommonModel = [2]string{
	0: "enabled",
	1: "used",
}

// Decode decodes FeatureStatusCommonModel from json.
func (s *FeatureStatusCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeatureStatusCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeatureStatusCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeatureStatusCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeatureStatusCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeaturesUsageCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeaturesUsageCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.AgentTesting.Set {
			e.FieldStart("agent_testing")
			s.AgentTesting.Encode(e)
		}
	}
	{
		if s.DtmfTones.Set {
			e.FieldStart("dtmf_tones")
			s.DtmfTones.Encode(e)
		}
	}
	{
		if s.ExternalMcpServers.Set {
			e.FieldStart("external_mcp_servers")
			s.ExternalMcpServers.Encode(e)
		}
	}
	{
		if s.IsLivekit.Set {
			e.FieldStart("is_livekit")
			s.IsLivekit.Encode(e)
		}
	}
	{
		if s.LanguageDetection.Set {
			e.FieldStart("language_detection")
			s.LanguageDetection.Encode(e)
		}
	}
	{
		if s.Multivoice.Set {
			e.FieldStart("multivoice")
			s.Multivoice.Encode(e)
		}
	}
	{
		if s.PiiZrmAgent.Set {
			e.FieldStart("pii_zrm_agent")
			s.PiiZrmAgent.Encode(e)
		}
	}
	{
		if s.PiiZrmWorkspace.Set {
			e.FieldStart("pii_zrm_workspace")
			s.PiiZrmWorkspace.Encode(e)
		}
	}
	{
		if s.ToolDynamicVariableUpdates.Set {
			e.FieldStart("tool_dynamic_variable_updates")
			s.ToolDynamicVariableUpdates.Encode(e)
		}
	}
	{
		if s.TransferToAgent.Set {
			e.FieldStart("transfer_to_agent")
			s.TransferToAgent.Encode(e)
		}
	}
	{
		if s.TransferToNumber.Set {
			e.FieldStart("transfer_to_number")
			s.TransferToNumber.Encode(e)
		}
	}
	{
		if s.Versioning.Set {
			e.FieldStart("versioning")
			s.Versioning.Encode(e)
		}
	}
	{
		if s.VoicemailDetection.Set {
			e.FieldStart("voicemail_detection")
			s.VoicemailDetection.Encode(e)
		}
	}
	{
		if s.Workflow.Set {
			e.FieldStart("workflow")
			s.Workflow.Encode(e)
		}
	}
}

var jsonFieldsNameOfFeaturesUsageCommonModel = [14]string{
	0:  "agent_testing",
	1:  "dtmf_tones",
	2:  "external_mcp_servers",
	3:  "is_livekit",
	4:  "language_detection",
	5:  "multivoice",
	6:  "pii_zrm_agent",
	7:  "pii_zrm_workspace",
	8:  "tool_dynamic_variable_updates",
	9:  "transfer_to_agent",
	10: "transfer_to_number",
	11: "versioning",
	12: "voicemail_detection",
	13: "workflow",
}

// Decode decodes FeaturesUsageCommonModel from json.
func (s *FeaturesUsageCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeaturesUsageCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_testing":
			if err := func() error {
				s.AgentTesting.Reset()
				if err := s.AgentTesting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_testing\"")
			}
		case "dtmf_tones":
			if err := func() error {
				s.DtmfTones.Reset()
				if err := s.DtmfTones.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_tones\"")
			}
		case "external_mcp_servers":
			if err := func() error {
				s.ExternalMcpServers.Reset()
				if err := s.ExternalMcpServers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"external_mcp_servers\"")
			}
		case "is_livekit":
			if err := func() error {
				s.IsLivekit.Reset()
				if err := s.IsLivekit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_livekit\"")
			}
		case "language_detection":
			if err := func() error {
				s.LanguageDetection.Reset()
				if err := s.LanguageDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_detection\"")
			}
		case "multivoice":
			if err := func() error {
				s.Multivoice.Reset()
				if err := s.Multivoice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multivoice\"")
			}
		case "pii_zrm_agent":
			if err := func() error {
				s.PiiZrmAgent.Reset()
				if err := s.PiiZrmAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pii_zrm_agent\"")
			}
		case "pii_zrm_workspace":
			if err := func() error {
				s.PiiZrmWorkspace.Reset()
				if err := s.PiiZrmWorkspace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pii_zrm_workspace\"")
			}
		case "tool_dynamic_variable_updates":
			if err := func() error {
				s.ToolDynamicVariableUpdates.Reset()
				if err := s.ToolDynamicVariableUpdates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_dynamic_variable_updates\"")
			}
		case "transfer_to_agent":
			if err := func() error {
				s.TransferToAgent.Reset()
				if err := s.TransferToAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transfer_to_agent\"")
			}
		case "transfer_to_number":
			if err := func() error {
				s.TransferToNumber.Reset()
				if err := s.TransferToNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transfer_to_number\"")
			}
		case "versioning":
			if err := func() error {
				s.Versioning.Reset()
				if err := s.Versioning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versioning\"")
			}
		case "voicemail_detection":
			if err := func() error {
				s.VoicemailDetection.Reset()
				if err := s.VoicemailDetection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voicemail_detection\"")
			}
		case "workflow":
			if err := func() error {
				s.Workflow.Reset()
				if err := s.Workflow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeaturesUsageCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeaturesUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeaturesUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeedbackResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeedbackResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audio_quality")
		e.Bool(s.AudioQuality)
	}
	{
		e.FieldStart("emotions")
		e.Bool(s.Emotions)
	}
	{
		e.FieldStart("feedback")
		e.Str(s.Feedback)
	}
	{
		e.FieldStart("glitches")
		e.Bool(s.Glitches)
	}
	{
		e.FieldStart("inaccurate_clone")
		e.Bool(s.InaccurateClone)
	}
	{
		e.FieldStart("other")
		e.Bool(s.Other)
	}
	{
		if s.ReviewStatus.Set {
			e.FieldStart("review_status")
			s.ReviewStatus.Encode(e)
		}
	}
	{
		e.FieldStart("thumbs_up")
		e.Bool(s.ThumbsUp)
	}
}

var jsonFieldsNameOfFeedbackResponseModel = [8]string{
	0: "audio_quality",
	1: "emotions",
	2: "feedback",
	3: "glitches",
	4: "inaccurate_clone",
	5: "other",
	6: "review_status",
	7: "thumbs_up",
}

// Decode decodes FeedbackResponseModel from json.
func (s *FeedbackResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeedbackResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_quality":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AudioQuality = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_quality\"")
			}
		case "emotions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Emotions = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emotions\"")
			}
		case "feedback":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Feedback = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback\"")
			}
		case "glitches":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Glitches = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"glitches\"")
			}
		case "inaccurate_clone":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.InaccurateClone = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inaccurate_clone\"")
			}
		case "other":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Other = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"other\"")
			}
		case "review_status":
			if err := func() error {
				s.ReviewStatus.Reset()
				if err := s.ReviewStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_status\"")
			}
		case "thumbs_up":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.ThumbsUp = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thumbs_up\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeedbackResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFeedbackResponseModel) {
					name = jsonFieldsNameOfFeedbackResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeedbackResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeedbackResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FineTuningResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FineTuningResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.DatasetDurationSeconds.Set {
			e.FieldStart("dataset_duration_seconds")
			s.DatasetDurationSeconds.Encode(e)
		}
	}
	{
		e.FieldStart("is_allowed_to_fine_tune")
		e.Bool(s.IsAllowedToFineTune)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.ManualVerification.Set {
			e.FieldStart("manual_verification")
			s.ManualVerification.Encode(e)
		}
	}
	{
		e.FieldStart("manual_verification_requested")
		e.Bool(s.ManualVerificationRequested)
	}
	{
		if s.MaxVerificationAttempts.Set {
			e.FieldStart("max_verification_attempts")
			s.MaxVerificationAttempts.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.NextMaxVerificationAttemptsResetUnixMs.Set {
			e.FieldStart("next_max_verification_attempts_reset_unix_ms")
			s.NextMaxVerificationAttemptsResetUnixMs.Encode(e)
		}
	}
	{
		if s.Progress.Set {
			e.FieldStart("progress")
			s.Progress.Encode(e)
		}
	}
	{
		if s.SliceIds.Set {
			e.FieldStart("slice_ids")
			s.SliceIds.Encode(e)
		}
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.VerificationAttempts.Set {
			e.FieldStart("verification_attempts")
			s.VerificationAttempts.Encode(e)
		}
	}
	{
		e.FieldStart("verification_attempts_count")
		e.Int(s.VerificationAttemptsCount)
	}
	{
		e.FieldStart("verification_failures")
		e.ArrStart()
		for _, elem := range s.VerificationFailures {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFineTuningResponseModel = [14]string{
	0:  "dataset_duration_seconds",
	1:  "is_allowed_to_fine_tune",
	2:  "language",
	3:  "manual_verification",
	4:  "manual_verification_requested",
	5:  "max_verification_attempts",
	6:  "message",
	7:  "next_max_verification_attempts_reset_unix_ms",
	8:  "progress",
	9:  "slice_ids",
	10: "state",
	11: "verification_attempts",
	12: "verification_attempts_count",
	13: "verification_failures",
}

// Decode decodes FineTuningResponseModel from json.
func (s *FineTuningResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dataset_duration_seconds":
			if err := func() error {
				s.DatasetDurationSeconds.Reset()
				if err := s.DatasetDurationSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dataset_duration_seconds\"")
			}
		case "is_allowed_to_fine_tune":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsAllowedToFineTune = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_allowed_to_fine_tune\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "manual_verification":
			if err := func() error {
				s.ManualVerification.Reset()
				if err := s.ManualVerification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manual_verification\"")
			}
		case "manual_verification_requested":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.ManualVerificationRequested = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manual_verification_requested\"")
			}
		case "max_verification_attempts":
			if err := func() error {
				s.MaxVerificationAttempts.Reset()
				if err := s.MaxVerificationAttempts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_verification_attempts\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "next_max_verification_attempts_reset_unix_ms":
			if err := func() error {
				s.NextMaxVerificationAttemptsResetUnixMs.Reset()
				if err := s.NextMaxVerificationAttemptsResetUnixMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_max_verification_attempts_reset_unix_ms\"")
			}
		case "progress":
			if err := func() error {
				s.Progress.Reset()
				if err := s.Progress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress\"")
			}
		case "slice_ids":
			if err := func() error {
				s.SliceIds.Reset()
				if err := s.SliceIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slice_ids\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "verification_attempts":
			if err := func() error {
				s.VerificationAttempts.Reset()
				if err := s.VerificationAttempts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_attempts\"")
			}
		case "verification_attempts_count":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.VerificationAttemptsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_attempts_count\"")
			}
		case "verification_failures":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				s.VerificationFailures = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VerificationFailures = append(s.VerificationFailures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_failures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010010,
		0b00110100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFineTuningResponseModel) {
					name = jsonFieldsNameOfFineTuningResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FineTuningResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FineTuningResponseModelMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FineTuningResponseModelMessage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes FineTuningResponseModelMessage from json.
func (s *FineTuningResponseModelMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningResponseModelMessage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningResponseModelMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningResponseModelMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningResponseModelMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FineTuningResponseModelProgress) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FineTuningResponseModelProgress) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes FineTuningResponseModelProgress from json.
func (s *FineTuningResponseModelProgress) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningResponseModelProgress to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningResponseModelProgress")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningResponseModelProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningResponseModelProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FineTuningResponseModelState) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FineTuningResponseModelState) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes FineTuningResponseModelState from json.
func (s *FineTuningResponseModelState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningResponseModelState to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem FineTuningResponseModelStateItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FineTuningResponseModelState")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningResponseModelState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningResponseModelState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningResponseModelStateItem as json.
func (s FineTuningResponseModelStateItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FineTuningResponseModelStateItem from json.
func (s *FineTuningResponseModelStateItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FineTuningResponseModelStateItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FineTuningResponseModelStateItem(v) {
	case FineTuningResponseModelStateItemNotStarted:
		*s = FineTuningResponseModelStateItemNotStarted
	case FineTuningResponseModelStateItemQueued:
		*s = FineTuningResponseModelStateItemQueued
	case FineTuningResponseModelStateItemFineTuning:
		*s = FineTuningResponseModelStateItemFineTuning
	case FineTuningResponseModelStateItemFineTuned:
		*s = FineTuningResponseModelStateItemFineTuned
	case FineTuningResponseModelStateItemFailed:
		*s = FineTuningResponseModelStateItemFailed
	case FineTuningResponseModelStateItemDelayed:
		*s = FineTuningResponseModelStateItemDelayed
	default:
		*s = FineTuningResponseModelStateItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FineTuningResponseModelStateItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FineTuningResponseModelStateItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForcedAlignmentCharacterResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForcedAlignmentCharacterResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("end")
		e.Float64(s.End)
	}
	{
		e.FieldStart("start")
		e.Float64(s.Start)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfForcedAlignmentCharacterResponseModel = [3]string{
	0: "end",
	1: "start",
	2: "text",
}

// Decode decodes ForcedAlignmentCharacterResponseModel from json.
func (s *ForcedAlignmentCharacterResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForcedAlignmentCharacterResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.End = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Start = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForcedAlignmentCharacterResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForcedAlignmentCharacterResponseModel) {
					name = jsonFieldsNameOfForcedAlignmentCharacterResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForcedAlignmentCharacterResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForcedAlignmentCharacterResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForcedAlignmentResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForcedAlignmentResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("characters")
		e.ArrStart()
		for _, elem := range s.Characters {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("loss")
		e.Float64(s.Loss)
	}
	{
		e.FieldStart("words")
		e.ArrStart()
		for _, elem := range s.Words {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfForcedAlignmentResponseModel = [3]string{
	0: "characters",
	1: "loss",
	2: "words",
}

// Decode decodes ForcedAlignmentResponseModel from json.
func (s *ForcedAlignmentResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForcedAlignmentResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "characters":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Characters = make([]ForcedAlignmentCharacterResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ForcedAlignmentCharacterResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Characters = append(s.Characters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		case "loss":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Loss = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loss\"")
			}
		case "words":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Words = make([]ForcedAlignmentWordResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ForcedAlignmentWordResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Words = append(s.Words, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"words\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForcedAlignmentResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForcedAlignmentResponseModel) {
					name = jsonFieldsNameOfForcedAlignmentResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForcedAlignmentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForcedAlignmentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForcedAlignmentWordResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForcedAlignmentWordResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("end")
		e.Float64(s.End)
	}
	{
		e.FieldStart("loss")
		e.Float64(s.Loss)
	}
	{
		e.FieldStart("start")
		e.Float64(s.Start)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfForcedAlignmentWordResponseModel = [4]string{
	0: "end",
	1: "loss",
	2: "start",
	3: "text",
}

// Decode decodes ForcedAlignmentWordResponseModel from json.
func (s *ForcedAlignmentWordResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForcedAlignmentWordResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.End = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "loss":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Loss = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loss\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Start = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForcedAlignmentWordResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfForcedAlignmentWordResponseModel) {
					name = jsonFieldsNameOfForcedAlignmentWordResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForcedAlignmentWordResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForcedAlignmentWordResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetAgentKnowledgeBaseSummariesRouteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetAgentKnowledgeBaseSummariesRouteOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GetAgentKnowledgeBaseSummariesRouteOK from json.
func (s *GetAgentKnowledgeBaseSummariesRouteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAgentKnowledgeBaseSummariesRouteOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem GetAgentKnowledgeBaseSummariesRouteOKItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAgentKnowledgeBaseSummariesRouteOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAgentKnowledgeBaseSummariesRouteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAgentKnowledgeBaseSummariesRouteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAgentKnowledgeBaseSummariesRouteOKItem as json.
func (s GetAgentKnowledgeBaseSummariesRouteOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetAgentKnowledgeBaseSummariesRouteOKItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case KnowledgeBaseSummaryBatchSuccessfulResponseModelGetAgentKnowledgeBaseSummariesRouteOKItem:
		e.FieldStart("status")
		e.Str("success")
		{
			s := s.KnowledgeBaseSummaryBatchSuccessfulResponseModel
			{
				e.FieldStart("data")
				s.Data.Encode(e)
			}
		}
	case BatchFailureResponseModelGetAgentKnowledgeBaseSummariesRouteOKItem:
		e.FieldStart("status")
		e.Str("failure")
		{
			s := s.BatchFailureResponseModel
			{
				e.FieldStart("error_code")
				e.Int(s.ErrorCode)
			}
			{
				e.FieldStart("error_message")
				e.Str(s.ErrorMessage)
			}
			{
				e.FieldStart("error_status")
				e.Str(s.ErrorStatus)
			}
		}
	}
}

// Decode decodes GetAgentKnowledgeBaseSummariesRouteOKItem from json.
func (s *GetAgentKnowledgeBaseSummariesRouteOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAgentKnowledgeBaseSummariesRouteOKItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "status":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "success":
					s.Type = KnowledgeBaseSummaryBatchSuccessfulResponseModelGetAgentKnowledgeBaseSummariesRouteOKItem
					found = true
				case "failure":
					s.Type = BatchFailureResponseModelGetAgentKnowledgeBaseSummariesRouteOKItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case KnowledgeBaseSummaryBatchSuccessfulResponseModelGetAgentKnowledgeBaseSummariesRouteOKItem:
		if err := s.KnowledgeBaseSummaryBatchSuccessfulResponseModel.Decode(d); err != nil {
			return err
		}
	case BatchFailureResponseModelGetAgentKnowledgeBaseSummariesRouteOKItem:
		if err := s.BatchFailureResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAgentKnowledgeBaseSummariesRouteOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAgentKnowledgeBaseSummariesRouteOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAgentKnowledgebaseSizeResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAgentKnowledgebaseSizeResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("number_of_pages")
		e.Float64(s.NumberOfPages)
	}
}

var jsonFieldsNameOfGetAgentKnowledgebaseSizeResponseModel = [1]string{
	0: "number_of_pages",
}

// Decode decodes GetAgentKnowledgebaseSizeResponseModel from json.
func (s *GetAgentKnowledgebaseSizeResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAgentKnowledgebaseSizeResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number_of_pages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.NumberOfPages = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number_of_pages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAgentKnowledgebaseSizeResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAgentKnowledgebaseSizeResponseModel) {
					name = jsonFieldsNameOfGetAgentKnowledgebaseSizeResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAgentKnowledgebaseSizeResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAgentKnowledgebaseSizeResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAgentLinkResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAgentLinkResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAgentLinkResponseModel = [2]string{
	0: "agent_id",
	1: "token",
}

// Decode decodes GetAgentLinkResponseModel from json.
func (s *GetAgentLinkResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAgentLinkResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAgentLinkResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAgentLinkResponseModel) {
					name = jsonFieldsNameOfGetAgentLinkResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAgentLinkResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAgentLinkResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAgentsPageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAgentsPageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agents")
		e.ArrStart()
		for _, elem := range s.Agents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAgentsPageResponseModel = [3]string{
	0: "agents",
	1: "has_more",
	2: "next_cursor",
}

// Decode decodes GetAgentsPageResponseModel from json.
func (s *GetAgentsPageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAgentsPageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agents":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Agents = make([]AgentSummaryResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentSummaryResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Agents = append(s.Agents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agents\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAgentsPageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAgentsPageResponseModel) {
					name = jsonFieldsNameOfGetAgentsPageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAgentsPageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAgentsPageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAudioNativeProjectSettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAudioNativeProjectSettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.SnapshotID.Set {
			e.FieldStart("snapshot_id")
			s.SnapshotID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetAudioNativeProjectSettingsResponseModel = [3]string{
	0: "enabled",
	1: "settings",
	2: "snapshot_id",
}

// Decode decodes GetAudioNativeProjectSettingsResponseModel from json.
func (s *GetAudioNativeProjectSettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAudioNativeProjectSettingsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		case "snapshot_id":
			if err := func() error {
				s.SnapshotID.Reset()
				if err := s.SnapshotID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshot_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAudioNativeProjectSettingsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAudioNativeProjectSettingsResponseModel) {
					name = jsonFieldsNameOfGetAudioNativeProjectSettingsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAudioNativeProjectSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAudioNativeProjectSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetChaptersResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetChaptersResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chapters")
		e.ArrStart()
		for _, elem := range s.Chapters {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetChaptersResponseModel = [1]string{
	0: "chapters",
}

// Decode decodes GetChaptersResponseModel from json.
func (s *GetChaptersResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetChaptersResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chapters":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Chapters = make([]ChapterResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChapterResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Chapters = append(s.Chapters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetChaptersResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetChaptersResponseModel) {
					name = jsonFieldsNameOfGetChaptersResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetChaptersResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetChaptersResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConvAIDashboardSettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConvAIDashboardSettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Charts != nil {
			e.FieldStart("charts")
			e.ArrStart()
			for _, elem := range s.Charts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetConvAIDashboardSettingsResponseModel = [1]string{
	0: "charts",
}

// Decode decodes GetConvAIDashboardSettingsResponseModel from json.
func (s *GetConvAIDashboardSettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConvAIDashboardSettingsResponseModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "charts":
			if err := func() error {
				s.Charts = make([]GetConvAIDashboardSettingsResponseModelChartsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConvAIDashboardSettingsResponseModelChartsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Charts = append(s.Charts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"charts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConvAIDashboardSettingsResponseModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConvAIDashboardSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConvAIDashboardSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConvAIDashboardSettingsResponseModelChartsItem as json.
func (s GetConvAIDashboardSettingsResponseModelChartsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetConvAIDashboardSettingsResponseModelChartsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DashboardCallSuccessChartModelGetConvAIDashboardSettingsResponseModelChartsItem:
		e.FieldStart("type")
		e.Str("call_success")
		{
			s := s.DashboardCallSuccessChartModel
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	case DashboardCriteriaChartModelGetConvAIDashboardSettingsResponseModelChartsItem:
		e.FieldStart("type")
		e.Str("criteria")
		{
			s := s.DashboardCriteriaChartModel
			{
				e.FieldStart("criteria_id")
				e.Str(s.CriteriaID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	case DashboardDataCollectionChartModelGetConvAIDashboardSettingsResponseModelChartsItem:
		e.FieldStart("type")
		e.Str("data_collection")
		{
			s := s.DashboardDataCollectionChartModel
			{
				e.FieldStart("data_collection_id")
				e.Str(s.DataCollectionID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes GetConvAIDashboardSettingsResponseModelChartsItem from json.
func (s *GetConvAIDashboardSettingsResponseModelChartsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConvAIDashboardSettingsResponseModelChartsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "call_success":
					s.Type = DashboardCallSuccessChartModelGetConvAIDashboardSettingsResponseModelChartsItem
					found = true
				case "criteria":
					s.Type = DashboardCriteriaChartModelGetConvAIDashboardSettingsResponseModelChartsItem
					found = true
				case "data_collection":
					s.Type = DashboardDataCollectionChartModelGetConvAIDashboardSettingsResponseModelChartsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DashboardCallSuccessChartModelGetConvAIDashboardSettingsResponseModelChartsItem:
		if err := s.DashboardCallSuccessChartModel.Decode(d); err != nil {
			return err
		}
	case DashboardCriteriaChartModelGetConvAIDashboardSettingsResponseModelChartsItem:
		if err := s.DashboardCriteriaChartModel.Decode(d); err != nil {
			return err
		}
	case DashboardDataCollectionChartModelGetConvAIDashboardSettingsResponseModelChartsItem:
		if err := s.DashboardDataCollectionChartModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetConvAIDashboardSettingsResponseModelChartsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConvAIDashboardSettingsResponseModelChartsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConvAISettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConvAISettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.CanUseMcpServers.Set {
			e.FieldStart("can_use_mcp_servers")
			s.CanUseMcpServers.Encode(e)
		}
	}
	{
		if s.ConversationInitiationClientDataWebhook.Set {
			e.FieldStart("conversation_initiation_client_data_webhook")
			s.ConversationInitiationClientDataWebhook.Encode(e)
		}
	}
	{
		if s.DefaultLivekitStack.Set {
			e.FieldStart("default_livekit_stack")
			s.DefaultLivekitStack.Encode(e)
		}
	}
	{
		if s.RagRetentionPeriodDays.Set {
			e.FieldStart("rag_retention_period_days")
			s.RagRetentionPeriodDays.Encode(e)
		}
	}
	{
		if s.Webhooks.Set {
			e.FieldStart("webhooks")
			s.Webhooks.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConvAISettingsResponseModel = [5]string{
	0: "can_use_mcp_servers",
	1: "conversation_initiation_client_data_webhook",
	2: "default_livekit_stack",
	3: "rag_retention_period_days",
	4: "webhooks",
}

// Decode decodes GetConvAISettingsResponseModel from json.
func (s *GetConvAISettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConvAISettingsResponseModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_use_mcp_servers":
			if err := func() error {
				s.CanUseMcpServers.Reset()
				if err := s.CanUseMcpServers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_mcp_servers\"")
			}
		case "conversation_initiation_client_data_webhook":
			if err := func() error {
				s.ConversationInitiationClientDataWebhook.Reset()
				if err := s.ConversationInitiationClientDataWebhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data_webhook\"")
			}
		case "default_livekit_stack":
			if err := func() error {
				s.DefaultLivekitStack.Reset()
				if err := s.DefaultLivekitStack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_livekit_stack\"")
			}
		case "rag_retention_period_days":
			if err := func() error {
				s.RagRetentionPeriodDays.Reset()
				if err := s.RagRetentionPeriodDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_retention_period_days\"")
			}
		case "webhooks":
			if err := func() error {
				s.Webhooks.Reset()
				if err := s.Webhooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConvAISettingsResponseModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConvAISettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConvAISettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConversationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConversationResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.Analysis.Set {
			e.FieldStart("analysis")
			s.Analysis.Encode(e)
		}
	}
	{
		if s.BranchID.Set {
			e.FieldStart("branch_id")
			s.BranchID.Encode(e)
		}
	}
	{
		e.FieldStart("conversation_id")
		e.Str(s.ConversationID)
	}
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		e.FieldStart("has_audio")
		e.Bool(s.HasAudio)
	}
	{
		e.FieldStart("has_response_audio")
		e.Bool(s.HasResponseAudio)
	}
	{
		e.FieldStart("has_user_audio")
		e.Bool(s.HasUserAudio)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("transcript")
		e.ArrStart()
		for _, elem := range s.Transcript {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConversationResponseModel = [12]string{
	0:  "agent_id",
	1:  "analysis",
	2:  "branch_id",
	3:  "conversation_id",
	4:  "conversation_initiation_client_data",
	5:  "has_audio",
	6:  "has_response_audio",
	7:  "has_user_audio",
	8:  "metadata",
	9:  "status",
	10: "transcript",
	11: "user_id",
}

// Decode decodes GetConversationResponseModel from json.
func (s *GetConversationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConversationResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "analysis":
			if err := func() error {
				s.Analysis.Reset()
				if err := s.Analysis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"analysis\"")
			}
		case "branch_id":
			if err := func() error {
				s.BranchID.Reset()
				if err := s.BranchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_id\"")
			}
		case "conversation_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ConversationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "has_audio":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.HasAudio = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_audio\"")
			}
		case "has_response_audio":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.HasResponseAudio = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_response_audio\"")
			}
		case "has_user_audio":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.HasUserAudio = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_user_audio\"")
			}
		case "metadata":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "transcript":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.Transcript = make([]ConversationHistoryTranscriptCommonModelOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transcript = append(s.Transcript, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcript\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConversationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101001,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConversationResponseModel) {
					name = jsonFieldsNameOfGetConversationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConversationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConversationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConversationResponseModelStatus as json.
func (s GetConversationResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetConversationResponseModelStatus from json.
func (s *GetConversationResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConversationResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetConversationResponseModelStatus(v) {
	case GetConversationResponseModelStatusInitiated:
		*s = GetConversationResponseModelStatusInitiated
	case GetConversationResponseModelStatusInProgress:
		*s = GetConversationResponseModelStatusInProgress
	case GetConversationResponseModelStatusProcessing:
		*s = GetConversationResponseModelStatusProcessing
	case GetConversationResponseModelStatusDone:
		*s = GetConversationResponseModelStatusDone
	case GetConversationResponseModelStatusFailed:
		*s = GetConversationResponseModelStatusFailed
	default:
		*s = GetConversationResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetConversationResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConversationResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConversationsPageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConversationsPageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conversations")
		e.ArrStart()
		for _, elem := range s.Conversations {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConversationsPageResponseModel = [3]string{
	0: "conversations",
	1: "has_more",
	2: "next_cursor",
}

// Decode decodes GetConversationsPageResponseModel from json.
func (s *GetConversationsPageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConversationsPageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Conversations = make([]ConversationSummaryResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationSummaryResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conversations = append(s.Conversations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversations\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConversationsPageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConversationsPageResponseModel) {
					name = jsonFieldsNameOfGetConversationsPageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConversationsPageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConversationsPageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDocumentationFromKnowledgeBaseOK as json.
func (s GetDocumentationFromKnowledgeBaseOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetDocumentationFromKnowledgeBaseOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetKnowledgeBaseURLResponseModelGetDocumentationFromKnowledgeBaseOK:
		e.FieldStart("type")
		e.Str("url")
		{
			s := s.GetKnowledgeBaseURLResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("extracted_inner_html")
				e.Str(s.ExtractedInnerHTML)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("url")
				e.Str(s.URL)
			}
		}
	case GetKnowledgeBaseFileResponseModelGetDocumentationFromKnowledgeBaseOK:
		e.FieldStart("type")
		e.Str("file")
		{
			s := s.GetKnowledgeBaseFileResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("extracted_inner_html")
				e.Str(s.ExtractedInnerHTML)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseTextResponseModelGetDocumentationFromKnowledgeBaseOK:
		e.FieldStart("type")
		e.Str("text")
		{
			s := s.GetKnowledgeBaseTextResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("extracted_inner_html")
				e.Str(s.ExtractedInnerHTML)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseFolderResponseModelGetDocumentationFromKnowledgeBaseOK:
		e.FieldStart("type")
		e.Str("folder")
		{
			s := s.GetKnowledgeBaseFolderResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("children_count")
				e.Int(s.ChildrenCount)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	}
}

// Decode decodes GetDocumentationFromKnowledgeBaseOK from json.
func (s *GetDocumentationFromKnowledgeBaseOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDocumentationFromKnowledgeBaseOK to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "url":
					s.Type = GetKnowledgeBaseURLResponseModelGetDocumentationFromKnowledgeBaseOK
					found = true
				case "file":
					s.Type = GetKnowledgeBaseFileResponseModelGetDocumentationFromKnowledgeBaseOK
					found = true
				case "text":
					s.Type = GetKnowledgeBaseTextResponseModelGetDocumentationFromKnowledgeBaseOK
					found = true
				case "folder":
					s.Type = GetKnowledgeBaseFolderResponseModelGetDocumentationFromKnowledgeBaseOK
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetKnowledgeBaseURLResponseModelGetDocumentationFromKnowledgeBaseOK:
		if err := s.GetKnowledgeBaseURLResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseFileResponseModelGetDocumentationFromKnowledgeBaseOK:
		if err := s.GetKnowledgeBaseFileResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseTextResponseModelGetDocumentationFromKnowledgeBaseOK:
		if err := s.GetKnowledgeBaseTextResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseFolderResponseModelGetDocumentationFromKnowledgeBaseOK:
		if err := s.GetKnowledgeBaseFolderResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDocumentationFromKnowledgeBaseOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDocumentationFromKnowledgeBaseOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedFileForbiddenApplicationJSON as json.
func (s GetDubbedFileForbiddenApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetDubbedFileForbiddenApplicationJSON from json.
func (s *GetDubbedFileForbiddenApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedFileForbiddenApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDubbedFileForbiddenApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedFileForbiddenApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedFileForbiddenApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedFileNotFoundApplicationJSON as json.
func (s GetDubbedFileNotFoundApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetDubbedFileNotFoundApplicationJSON from json.
func (s *GetDubbedFileNotFoundApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedFileNotFoundApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDubbedFileNotFoundApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedFileNotFoundApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedFileNotFoundApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedFileTooEarlyApplicationJSON as json.
func (s GetDubbedFileTooEarlyApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetDubbedFileTooEarlyApplicationJSON from json.
func (s *GetDubbedFileTooEarlyApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedFileTooEarlyApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDubbedFileTooEarlyApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedFileTooEarlyApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedFileTooEarlyApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedTranscriptFileForbiddenApplicationJSON as json.
func (s GetDubbedTranscriptFileForbiddenApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetDubbedTranscriptFileForbiddenApplicationJSON from json.
func (s *GetDubbedTranscriptFileForbiddenApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedTranscriptFileForbiddenApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDubbedTranscriptFileForbiddenApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedTranscriptFileForbiddenApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedTranscriptFileForbiddenApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedTranscriptFileNotFoundApplicationJSON as json.
func (s GetDubbedTranscriptFileNotFoundApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetDubbedTranscriptFileNotFoundApplicationJSON from json.
func (s *GetDubbedTranscriptFileNotFoundApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedTranscriptFileNotFoundApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDubbedTranscriptFileNotFoundApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedTranscriptFileNotFoundApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedTranscriptFileNotFoundApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedTranscriptFileOKApplicationJSON as json.
func (s GetDubbedTranscriptFileOKApplicationJSON) Encode(e *jx.Encoder) {
	switch s.Type {
	case DubbingTranscriptResponseModelGetDubbedTranscriptFileOKApplicationJSON:
		s.DubbingTranscriptResponseModel.Encode(e)
	case StringGetDubbedTranscriptFileOKApplicationJSON:
		e.Str(s.String)
	}
}

// Decode decodes GetDubbedTranscriptFileOKApplicationJSON from json.
func (s *GetDubbedTranscriptFileOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedTranscriptFileOKApplicationJSON to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.DubbingTranscriptResponseModel.Decode(d); err != nil {
			return err
		}
		s.Type = DubbingTranscriptResponseModelGetDubbedTranscriptFileOKApplicationJSON
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringGetDubbedTranscriptFileOKApplicationJSON
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedTranscriptFileOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedTranscriptFileOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDubbedTranscriptFileTooEarlyApplicationJSON as json.
func (s GetDubbedTranscriptFileTooEarlyApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetDubbedTranscriptFileTooEarlyApplicationJSON from json.
func (s *GetDubbedTranscriptFileTooEarlyApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDubbedTranscriptFileTooEarlyApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDubbedTranscriptFileTooEarlyApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDubbedTranscriptFileTooEarlyApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDubbedTranscriptFileTooEarlyApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseDependentAgentsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseDependentAgentsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agents")
		e.ArrStart()
		for _, elem := range s.Agents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetKnowledgeBaseDependentAgentsResponseModel = [3]string{
	0: "agents",
	1: "has_more",
	2: "next_cursor",
}

// Decode decodes GetKnowledgeBaseDependentAgentsResponseModel from json.
func (s *GetKnowledgeBaseDependentAgentsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseDependentAgentsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agents":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Agents = make([]GetKnowledgeBaseDependentAgentsResponseModelAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetKnowledgeBaseDependentAgentsResponseModelAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Agents = append(s.Agents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agents\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseDependentAgentsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseDependentAgentsResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseDependentAgentsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseDependentAgentsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseDependentAgentsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseDependentAgentsResponseModelAgentsItem as json.
func (s GetKnowledgeBaseDependentAgentsResponseModelAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetKnowledgeBaseDependentAgentsResponseModelAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseDependentAgentsResponseModelAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseDependentAgentsResponseModelAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes GetKnowledgeBaseDependentAgentsResponseModelAgentsItem from json.
func (s *GetKnowledgeBaseDependentAgentsResponseModelAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseDependentAgentsResponseModelAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierGetKnowledgeBaseDependentAgentsResponseModelAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierGetKnowledgeBaseDependentAgentsResponseModelAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseDependentAgentsResponseModelAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseDependentAgentsResponseModelAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseDependentAgentsResponseModelAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseDependentAgentsResponseModelAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseFileResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseFileResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("extracted_inner_html")
		e.Str(s.ExtractedInnerHTML)
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		if s.FolderPath != nil {
			e.FieldStart("folder_path")
			e.ArrStart()
			for _, elem := range s.FolderPath {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseFileResponseModel = [9]string{
	0: "access_info",
	1: "extracted_inner_html",
	2: "folder_parent_id",
	3: "folder_path",
	4: "id",
	5: "metadata",
	6: "name",
	7: "supported_usages",
	8: "type",
}

// Decode decodes GetKnowledgeBaseFileResponseModel from json.
func (s *GetKnowledgeBaseFileResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseFileResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "extracted_inner_html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExtractedInnerHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extracted_inner_html\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "folder_path":
			if err := func() error {
				s.FolderPath = make([]KnowledgeBaseFolderPathSegmentResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem KnowledgeBaseFolderPathSegmentResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FolderPath = append(s.FolderPath, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_path\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseFileResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseFileResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseFileResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseFileResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseFileResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseFileResponseModelType as json.
func (s GetKnowledgeBaseFileResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseFileResponseModelType from json.
func (s *GetKnowledgeBaseFileResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseFileResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseFileResponseModelType(v) {
	case GetKnowledgeBaseFileResponseModelTypeFile:
		*s = GetKnowledgeBaseFileResponseModelTypeFile
	default:
		*s = GetKnowledgeBaseFileResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseFileResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseFileResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseFolderResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseFolderResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("children_count")
		e.Int(s.ChildrenCount)
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		if s.FolderPath != nil {
			e.FieldStart("folder_path")
			e.ArrStart()
			for _, elem := range s.FolderPath {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseFolderResponseModel = [9]string{
	0: "access_info",
	1: "children_count",
	2: "folder_parent_id",
	3: "folder_path",
	4: "id",
	5: "metadata",
	6: "name",
	7: "supported_usages",
	8: "type",
}

// Decode decodes GetKnowledgeBaseFolderResponseModel from json.
func (s *GetKnowledgeBaseFolderResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseFolderResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "children_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ChildrenCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"children_count\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "folder_path":
			if err := func() error {
				s.FolderPath = make([]KnowledgeBaseFolderPathSegmentResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem KnowledgeBaseFolderPathSegmentResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FolderPath = append(s.FolderPath, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_path\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseFolderResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseFolderResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseFolderResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseFolderResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseFolderResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseFolderResponseModelType as json.
func (s GetKnowledgeBaseFolderResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseFolderResponseModelType from json.
func (s *GetKnowledgeBaseFolderResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseFolderResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseFolderResponseModelType(v) {
	case GetKnowledgeBaseFolderResponseModelTypeFolder:
		*s = GetKnowledgeBaseFolderResponseModelTypeFolder
	default:
		*s = GetKnowledgeBaseFolderResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseFolderResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseFolderResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseListResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseListResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetKnowledgeBaseListResponseModel = [3]string{
	0: "documents",
	1: "has_more",
	2: "next_cursor",
}

// Decode decodes GetKnowledgeBaseListResponseModel from json.
func (s *GetKnowledgeBaseListResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseListResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "documents":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Documents = make([]GetKnowledgeBaseListResponseModelDocumentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetKnowledgeBaseListResponseModelDocumentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseListResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseListResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseListResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseListResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseListResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseListResponseModelDocumentsItem as json.
func (s GetKnowledgeBaseListResponseModelDocumentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetKnowledgeBaseListResponseModelDocumentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetKnowledgeBaseSummaryURLResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		e.FieldStart("type")
		e.Str("url")
		{
			s := s.GetKnowledgeBaseSummaryURLResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("url")
				e.Str(s.URL)
			}
		}
	case GetKnowledgeBaseSummaryFileResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		e.FieldStart("type")
		e.Str("file")
		{
			s := s.GetKnowledgeBaseSummaryFileResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseSummaryTextResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		e.FieldStart("type")
		e.Str("text")
		{
			s := s.GetKnowledgeBaseSummaryTextResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseSummaryFolderResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		e.FieldStart("type")
		e.Str("folder")
		{
			s := s.GetKnowledgeBaseSummaryFolderResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("children_count")
				e.Int(s.ChildrenCount)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	}
}

// Decode decodes GetKnowledgeBaseListResponseModelDocumentsItem from json.
func (s *GetKnowledgeBaseListResponseModelDocumentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseListResponseModelDocumentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "url":
					s.Type = GetKnowledgeBaseSummaryURLResponseModelGetKnowledgeBaseListResponseModelDocumentsItem
					found = true
				case "file":
					s.Type = GetKnowledgeBaseSummaryFileResponseModelGetKnowledgeBaseListResponseModelDocumentsItem
					found = true
				case "text":
					s.Type = GetKnowledgeBaseSummaryTextResponseModelGetKnowledgeBaseListResponseModelDocumentsItem
					found = true
				case "folder":
					s.Type = GetKnowledgeBaseSummaryFolderResponseModelGetKnowledgeBaseListResponseModelDocumentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetKnowledgeBaseSummaryURLResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		if err := s.GetKnowledgeBaseSummaryURLResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseSummaryFileResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		if err := s.GetKnowledgeBaseSummaryFileResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseSummaryTextResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		if err := s.GetKnowledgeBaseSummaryTextResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseSummaryFolderResponseModelGetKnowledgeBaseListResponseModelDocumentsItem:
		if err := s.GetKnowledgeBaseSummaryFolderResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseListResponseModelDocumentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseListResponseModelDocumentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseSummaryFileResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseSummaryFileResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("dependent_agents")
		e.ArrStart()
		for _, elem := range s.DependentAgents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseSummaryFileResponseModel = [8]string{
	0: "access_info",
	1: "dependent_agents",
	2: "folder_parent_id",
	3: "id",
	4: "metadata",
	5: "name",
	6: "supported_usages",
	7: "type",
}

// Decode decodes GetKnowledgeBaseSummaryFileResponseModel from json.
func (s *GetKnowledgeBaseSummaryFileResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryFileResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "dependent_agents":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.DependentAgents = make([]GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DependentAgents = append(s.DependentAgents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependent_agents\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseSummaryFileResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseSummaryFileResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseSummaryFileResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseSummaryFileResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryFileResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem as json.
func (s GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem from json.
func (s *GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryFileResponseModelDependentAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryFileResponseModelType as json.
func (s GetKnowledgeBaseSummaryFileResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseSummaryFileResponseModelType from json.
func (s *GetKnowledgeBaseSummaryFileResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryFileResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseSummaryFileResponseModelType(v) {
	case GetKnowledgeBaseSummaryFileResponseModelTypeFile:
		*s = GetKnowledgeBaseSummaryFileResponseModelTypeFile
	default:
		*s = GetKnowledgeBaseSummaryFileResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryFileResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryFileResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseSummaryFolderResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseSummaryFolderResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("children_count")
		e.Int(s.ChildrenCount)
	}
	{
		e.FieldStart("dependent_agents")
		e.ArrStart()
		for _, elem := range s.DependentAgents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseSummaryFolderResponseModel = [9]string{
	0: "access_info",
	1: "children_count",
	2: "dependent_agents",
	3: "folder_parent_id",
	4: "id",
	5: "metadata",
	6: "name",
	7: "supported_usages",
	8: "type",
}

// Decode decodes GetKnowledgeBaseSummaryFolderResponseModel from json.
func (s *GetKnowledgeBaseSummaryFolderResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryFolderResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "children_count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ChildrenCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"children_count\"")
			}
		case "dependent_agents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.DependentAgents = make([]GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DependentAgents = append(s.DependentAgents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependent_agents\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseSummaryFolderResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseSummaryFolderResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseSummaryFolderResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseSummaryFolderResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryFolderResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem as json.
func (s GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem from json.
func (s *GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryFolderResponseModelDependentAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryFolderResponseModelType as json.
func (s GetKnowledgeBaseSummaryFolderResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseSummaryFolderResponseModelType from json.
func (s *GetKnowledgeBaseSummaryFolderResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryFolderResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseSummaryFolderResponseModelType(v) {
	case GetKnowledgeBaseSummaryFolderResponseModelTypeFolder:
		*s = GetKnowledgeBaseSummaryFolderResponseModelTypeFolder
	default:
		*s = GetKnowledgeBaseSummaryFolderResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryFolderResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryFolderResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseSummaryTextResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseSummaryTextResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("dependent_agents")
		e.ArrStart()
		for _, elem := range s.DependentAgents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseSummaryTextResponseModel = [8]string{
	0: "access_info",
	1: "dependent_agents",
	2: "folder_parent_id",
	3: "id",
	4: "metadata",
	5: "name",
	6: "supported_usages",
	7: "type",
}

// Decode decodes GetKnowledgeBaseSummaryTextResponseModel from json.
func (s *GetKnowledgeBaseSummaryTextResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryTextResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "dependent_agents":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.DependentAgents = make([]GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DependentAgents = append(s.DependentAgents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependent_agents\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseSummaryTextResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseSummaryTextResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseSummaryTextResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseSummaryTextResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryTextResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem as json.
func (s GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem from json.
func (s *GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryTextResponseModelDependentAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryTextResponseModelType as json.
func (s GetKnowledgeBaseSummaryTextResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseSummaryTextResponseModelType from json.
func (s *GetKnowledgeBaseSummaryTextResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryTextResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseSummaryTextResponseModelType(v) {
	case GetKnowledgeBaseSummaryTextResponseModelTypeText:
		*s = GetKnowledgeBaseSummaryTextResponseModelTypeText
	default:
		*s = GetKnowledgeBaseSummaryTextResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryTextResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryTextResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseSummaryURLResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseSummaryURLResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("dependent_agents")
		e.ArrStart()
		for _, elem := range s.DependentAgents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseSummaryURLResponseModel = [9]string{
	0: "access_info",
	1: "dependent_agents",
	2: "folder_parent_id",
	3: "id",
	4: "metadata",
	5: "name",
	6: "supported_usages",
	7: "type",
	8: "url",
}

// Decode decodes GetKnowledgeBaseSummaryURLResponseModel from json.
func (s *GetKnowledgeBaseSummaryURLResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryURLResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "dependent_agents":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.DependentAgents = make([]GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DependentAgents = append(s.DependentAgents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependent_agents\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseSummaryURLResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseSummaryURLResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseSummaryURLResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseSummaryURLResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryURLResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem as json.
func (s GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem from json.
func (s *GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierGetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierGetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryURLResponseModelDependentAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseSummaryURLResponseModelType as json.
func (s GetKnowledgeBaseSummaryURLResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseSummaryURLResponseModelType from json.
func (s *GetKnowledgeBaseSummaryURLResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseSummaryURLResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseSummaryURLResponseModelType(v) {
	case GetKnowledgeBaseSummaryURLResponseModelTypeURL:
		*s = GetKnowledgeBaseSummaryURLResponseModelTypeURL
	default:
		*s = GetKnowledgeBaseSummaryURLResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseSummaryURLResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseSummaryURLResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseTextResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseTextResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("extracted_inner_html")
		e.Str(s.ExtractedInnerHTML)
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		if s.FolderPath != nil {
			e.FieldStart("folder_path")
			e.ArrStart()
			for _, elem := range s.FolderPath {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseTextResponseModel = [9]string{
	0: "access_info",
	1: "extracted_inner_html",
	2: "folder_parent_id",
	3: "folder_path",
	4: "id",
	5: "metadata",
	6: "name",
	7: "supported_usages",
	8: "type",
}

// Decode decodes GetKnowledgeBaseTextResponseModel from json.
func (s *GetKnowledgeBaseTextResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseTextResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "extracted_inner_html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExtractedInnerHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extracted_inner_html\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "folder_path":
			if err := func() error {
				s.FolderPath = make([]KnowledgeBaseFolderPathSegmentResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem KnowledgeBaseFolderPathSegmentResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FolderPath = append(s.FolderPath, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_path\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseTextResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseTextResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseTextResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseTextResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseTextResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseTextResponseModelType as json.
func (s GetKnowledgeBaseTextResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseTextResponseModelType from json.
func (s *GetKnowledgeBaseTextResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseTextResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseTextResponseModelType(v) {
	case GetKnowledgeBaseTextResponseModelTypeText:
		*s = GetKnowledgeBaseTextResponseModelTypeText
	default:
		*s = GetKnowledgeBaseTextResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseTextResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseTextResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetKnowledgeBaseURLResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetKnowledgeBaseURLResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_info")
		s.AccessInfo.Encode(e)
	}
	{
		e.FieldStart("extracted_inner_html")
		e.Str(s.ExtractedInnerHTML)
	}
	{
		if s.FolderParentID.Set {
			e.FieldStart("folder_parent_id")
			s.FolderParentID.Encode(e)
		}
	}
	{
		if s.FolderPath != nil {
			e.FieldStart("folder_path")
			e.ArrStart()
			for _, elem := range s.FolderPath {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_usages")
		e.ArrStart()
		for _, elem := range s.SupportedUsages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
}

var jsonFieldsNameOfGetKnowledgeBaseURLResponseModel = [10]string{
	0: "access_info",
	1: "extracted_inner_html",
	2: "folder_parent_id",
	3: "folder_path",
	4: "id",
	5: "metadata",
	6: "name",
	7: "supported_usages",
	8: "type",
	9: "url",
}

// Decode decodes GetKnowledgeBaseURLResponseModel from json.
func (s *GetKnowledgeBaseURLResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseURLResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "extracted_inner_html":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ExtractedInnerHTML = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extracted_inner_html\"")
			}
		case "folder_parent_id":
			if err := func() error {
				s.FolderParentID.Reset()
				if err := s.FolderParentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_parent_id\"")
			}
		case "folder_path":
			if err := func() error {
				s.FolderPath = make([]KnowledgeBaseFolderPathSegmentResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem KnowledgeBaseFolderPathSegmentResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FolderPath = append(s.FolderPath, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folder_path\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_usages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.SupportedUsages = make([]DocumentUsageModeEnum, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DocumentUsageModeEnum
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedUsages = append(s.SupportedUsages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_usages\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetKnowledgeBaseURLResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetKnowledgeBaseURLResponseModel) {
					name = jsonFieldsNameOfGetKnowledgeBaseURLResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetKnowledgeBaseURLResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseURLResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetKnowledgeBaseURLResponseModelType as json.
func (s GetKnowledgeBaseURLResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetKnowledgeBaseURLResponseModelType from json.
func (s *GetKnowledgeBaseURLResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetKnowledgeBaseURLResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetKnowledgeBaseURLResponseModelType(v) {
	case GetKnowledgeBaseURLResponseModelTypeURL:
		*s = GetKnowledgeBaseURLResponseModelTypeURL
	default:
		*s = GetKnowledgeBaseURLResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetKnowledgeBaseURLResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetKnowledgeBaseURLResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetLibraryVoicesResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetLibraryVoicesResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.LastSortID.Set {
			e.FieldStart("last_sort_id")
			s.LastSortID.Encode(e)
		}
	}
	{
		e.FieldStart("voices")
		e.ArrStart()
		for _, elem := range s.Voices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetLibraryVoicesResponseModel = [3]string{
	0: "has_more",
	1: "last_sort_id",
	2: "voices",
}

// Decode decodes GetLibraryVoicesResponseModel from json.
func (s *GetLibraryVoicesResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLibraryVoicesResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "last_sort_id":
			if err := func() error {
				s.LastSortID.Reset()
				if err := s.LastSortID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_sort_id\"")
			}
		case "voices":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Voices = make([]LibraryVoiceResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LibraryVoiceResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Voices = append(s.Voices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetLibraryVoicesResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetLibraryVoicesResponseModel) {
					name = jsonFieldsNameOfGetLibraryVoicesResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLibraryVoicesResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLibraryVoicesResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetLiveCountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetLiveCountResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
}

var jsonFieldsNameOfGetLiveCountResponse = [1]string{
	0: "count",
}

// Decode decodes GetLiveCountResponse from json.
func (s *GetLiveCountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLiveCountResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetLiveCountResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetLiveCountResponse) {
					name = jsonFieldsNameOfGetLiveCountResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLiveCountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLiveCountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetModelsOKApplicationJSON as json.
func (s GetModelsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ModelResponseModel(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetModelsOKApplicationJSON from json.
func (s *GetModelsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetModelsOKApplicationJSON to nil")
	}
	var unwrapped []ModelResponseModel
	if err := func() error {
		unwrapped = make([]ModelResponseModel, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ModelResponseModel
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetModelsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetModelsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetModelsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOrCreateRAGIndexRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOrCreateRAGIndexRequestModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("create_if_missing")
		e.Bool(s.CreateIfMissing)
	}
	{
		e.FieldStart("document_id")
		e.Str(s.DocumentID)
	}
	{
		e.FieldStart("model")
		s.Model.Encode(e)
	}
}

var jsonFieldsNameOfGetOrCreateRAGIndexRequestModel = [3]string{
	0: "create_if_missing",
	1: "document_id",
	2: "model",
}

// Decode decodes GetOrCreateRAGIndexRequestModel from json.
func (s *GetOrCreateRAGIndexRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOrCreateRAGIndexRequestModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_if_missing":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CreateIfMissing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_if_missing\"")
			}
		case "document_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_id\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOrCreateRAGIndexRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOrCreateRAGIndexRequestModel) {
					name = jsonFieldsNameOfGetOrCreateRAGIndexRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOrCreateRAGIndexRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOrCreateRAGIndexRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetOrCreateRagIndexesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetOrCreateRagIndexesOK) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GetOrCreateRagIndexesOK from json.
func (s *GetOrCreateRagIndexesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOrCreateRagIndexesOK to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem GetOrCreateRagIndexesOKItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOrCreateRagIndexesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOrCreateRagIndexesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOrCreateRagIndexesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOrCreateRagIndexesOKItem as json.
func (s GetOrCreateRagIndexesOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetOrCreateRagIndexesOKItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RAGIndexBatchSuccessfulResponseModelGetOrCreateRagIndexesOKItem:
		e.FieldStart("status")
		e.Str("success")
		{
			s := s.RAGIndexBatchSuccessfulResponseModel
			{
				e.FieldStart("data")
				s.Data.Encode(e)
			}
		}
	case BatchFailureResponseModelGetOrCreateRagIndexesOKItem:
		e.FieldStart("status")
		e.Str("failure")
		{
			s := s.BatchFailureResponseModel
			{
				e.FieldStart("error_code")
				e.Int(s.ErrorCode)
			}
			{
				e.FieldStart("error_message")
				e.Str(s.ErrorMessage)
			}
			{
				e.FieldStart("error_status")
				e.Str(s.ErrorStatus)
			}
		}
	}
}

// Decode decodes GetOrCreateRagIndexesOKItem from json.
func (s *GetOrCreateRagIndexesOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOrCreateRagIndexesOKItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "status":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "success":
					s.Type = RAGIndexBatchSuccessfulResponseModelGetOrCreateRagIndexesOKItem
					found = true
				case "failure":
					s.Type = BatchFailureResponseModelGetOrCreateRagIndexesOKItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RAGIndexBatchSuccessfulResponseModelGetOrCreateRagIndexesOKItem:
		if err := s.RAGIndexBatchSuccessfulResponseModel.Decode(d); err != nil {
			return err
		}
	case BatchFailureResponseModelGetOrCreateRagIndexesOKItem:
		if err := s.BatchFailureResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOrCreateRagIndexesOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOrCreateRagIndexesOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPhoneNumberInboundSIPTrunkConfigResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPhoneNumberInboundSIPTrunkConfigResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("allowed_addresses")
		e.ArrStart()
		for _, elem := range s.AllowedAddresses {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("allowed_numbers")
		if s.AllowedNumbers == nil {
			e.Null()
		} else {
			e.ArrStart()
			for _, elem := range s.AllowedNumbers {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("has_auth_credentials")
		e.Bool(s.HasAuthCredentials)
	}
	{
		e.FieldStart("media_encryption")
		s.MediaEncryption.Encode(e)
	}
	{
		if s.RemoteDomains.Set {
			e.FieldStart("remote_domains")
			s.RemoteDomains.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPhoneNumberInboundSIPTrunkConfigResponseModel = [6]string{
	0: "allowed_addresses",
	1: "allowed_numbers",
	2: "has_auth_credentials",
	3: "media_encryption",
	4: "remote_domains",
	5: "username",
}

// Decode decodes GetPhoneNumberInboundSIPTrunkConfigResponseModel from json.
func (s *GetPhoneNumberInboundSIPTrunkConfigResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberInboundSIPTrunkConfigResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowed_addresses":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AllowedAddresses = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedAddresses = append(s.AllowedAddresses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_addresses\"")
			}
		case "allowed_numbers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				switch tt := d.Next(); tt {
				case jx.Null:
					if err := d.Skip(); err != nil {
						return err
					}
				default:
					s.AllowedNumbers = make([]string, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elem string
						v, err := d.Str()
						elem = string(v)
						if err != nil {
							return err
						}
						s.AllowedNumbers = append(s.AllowedNumbers, elem)
						return nil
					}); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_numbers\"")
			}
		case "has_auth_credentials":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.HasAuthCredentials = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_auth_credentials\"")
			}
		case "media_encryption":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "remote_domains":
			if err := func() error {
				s.RemoteDomains.Reset()
				if err := s.RemoteDomains.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_domains\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPhoneNumberInboundSIPTrunkConfigResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPhoneNumberInboundSIPTrunkConfigResponseModel) {
					name = jsonFieldsNameOfGetPhoneNumberInboundSIPTrunkConfigResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPhoneNumberInboundSIPTrunkConfigResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberInboundSIPTrunkConfigResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("has_auth_credentials")
		e.Bool(s.HasAuthCredentials)
	}
	{
		if s.HasOutboundTrunk.Set {
			e.FieldStart("has_outbound_trunk")
			s.HasOutboundTrunk.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		e.FieldStart("media_encryption")
		s.MediaEncryption.Encode(e)
	}
	{
		e.FieldStart("transport")
		s.Transport.Encode(e)
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPhoneNumberOutboundSIPTrunkConfigResponseModel = [7]string{
	0: "address",
	1: "has_auth_credentials",
	2: "has_outbound_trunk",
	3: "headers",
	4: "media_encryption",
	5: "transport",
	6: "username",
}

// Decode decodes GetPhoneNumberOutboundSIPTrunkConfigResponseModel from json.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberOutboundSIPTrunkConfigResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "has_auth_credentials":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasAuthCredentials = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_auth_credentials\"")
			}
		case "has_outbound_trunk":
			if err := func() error {
				s.HasOutboundTrunk.Reset()
				if err := s.HasOutboundTrunk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_outbound_trunk\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "media_encryption":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "transport":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Transport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPhoneNumberOutboundSIPTrunkConfigResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPhoneNumberOutboundSIPTrunkConfigResponseModel) {
					name = jsonFieldsNameOfGetPhoneNumberOutboundSIPTrunkConfigResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders from json.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberRouteOK as json.
func (s GetPhoneNumberRouteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetPhoneNumberRouteOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetPhoneNumberTwilioResponseModelGetPhoneNumberRouteOK:
		e.FieldStart("provider")
		e.Str("twilio")
		{
			s := s.GetPhoneNumberTwilioResponseModel
			{
				if s.AssignedAgent.Set {
					e.FieldStart("assigned_agent")
					s.AssignedAgent.Encode(e)
				}
			}
			{
				e.FieldStart("label")
				e.Str(s.Label)
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				if s.SupportsInbound.Set {
					e.FieldStart("supports_inbound")
					s.SupportsInbound.Encode(e)
				}
			}
			{
				if s.SupportsOutbound.Set {
					e.FieldStart("supports_outbound")
					s.SupportsOutbound.Encode(e)
				}
			}
		}
	case GetPhoneNumberSIPTrunkResponseModelGetPhoneNumberRouteOK:
		e.FieldStart("provider")
		e.Str("sip_trunk")
		{
			s := s.GetPhoneNumberSIPTrunkResponseModel
			{
				if s.AssignedAgent.Set {
					e.FieldStart("assigned_agent")
					s.AssignedAgent.Encode(e)
				}
			}
			{
				if s.InboundTrunk.Set {
					e.FieldStart("inbound_trunk")
					s.InboundTrunk.Encode(e)
				}
			}
			{
				e.FieldStart("label")
				e.Str(s.Label)
			}
			{
				e.FieldStart("livekit_stack")
				s.LivekitStack.Encode(e)
			}
			{
				if s.OutboundTrunk.Set {
					e.FieldStart("outbound_trunk")
					s.OutboundTrunk.Encode(e)
				}
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				if s.ProviderConfig.Set {
					e.FieldStart("provider_config")
					s.ProviderConfig.Encode(e)
				}
			}
			{
				if s.SupportsInbound.Set {
					e.FieldStart("supports_inbound")
					s.SupportsInbound.Encode(e)
				}
			}
			{
				if s.SupportsOutbound.Set {
					e.FieldStart("supports_outbound")
					s.SupportsOutbound.Encode(e)
				}
			}
		}
	}
}

// Decode decodes GetPhoneNumberRouteOK from json.
func (s *GetPhoneNumberRouteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberRouteOK to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "provider":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "twilio":
					s.Type = GetPhoneNumberTwilioResponseModelGetPhoneNumberRouteOK
					found = true
				case "sip_trunk":
					s.Type = GetPhoneNumberSIPTrunkResponseModelGetPhoneNumberRouteOK
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetPhoneNumberTwilioResponseModelGetPhoneNumberRouteOK:
		if err := s.GetPhoneNumberTwilioResponseModel.Decode(d); err != nil {
			return err
		}
	case GetPhoneNumberSIPTrunkResponseModelGetPhoneNumberRouteOK:
		if err := s.GetPhoneNumberSIPTrunkResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetPhoneNumberRouteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberRouteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPhoneNumberSIPTrunkResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPhoneNumberSIPTrunkResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AssignedAgent.Set {
			e.FieldStart("assigned_agent")
			s.AssignedAgent.Encode(e)
		}
	}
	{
		if s.InboundTrunk.Set {
			e.FieldStart("inbound_trunk")
			s.InboundTrunk.Encode(e)
		}
	}
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("livekit_stack")
		s.LivekitStack.Encode(e)
	}
	{
		if s.OutboundTrunk.Set {
			e.FieldStart("outbound_trunk")
			s.OutboundTrunk.Encode(e)
		}
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.ProviderConfig.Set {
			e.FieldStart("provider_config")
			s.ProviderConfig.Encode(e)
		}
	}
	{
		if s.SupportsInbound.Set {
			e.FieldStart("supports_inbound")
			s.SupportsInbound.Encode(e)
		}
	}
	{
		if s.SupportsOutbound.Set {
			e.FieldStart("supports_outbound")
			s.SupportsOutbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPhoneNumberSIPTrunkResponseModel = [11]string{
	0:  "assigned_agent",
	1:  "inbound_trunk",
	2:  "label",
	3:  "livekit_stack",
	4:  "outbound_trunk",
	5:  "phone_number",
	6:  "phone_number_id",
	7:  "provider",
	8:  "provider_config",
	9:  "supports_inbound",
	10: "supports_outbound",
}

// Decode decodes GetPhoneNumberSIPTrunkResponseModel from json.
func (s *GetPhoneNumberSIPTrunkResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberSIPTrunkResponseModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assigned_agent":
			if err := func() error {
				s.AssignedAgent.Reset()
				if err := s.AssignedAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned_agent\"")
			}
		case "inbound_trunk":
			if err := func() error {
				s.InboundTrunk.Reset()
				if err := s.InboundTrunk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_trunk\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "livekit_stack":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LivekitStack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livekit_stack\"")
			}
		case "outbound_trunk":
			if err := func() error {
				s.OutboundTrunk.Reset()
				if err := s.OutboundTrunk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound_trunk\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "provider_config":
			if err := func() error {
				s.ProviderConfig.Reset()
				if err := s.ProviderConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider_config\"")
			}
		case "supports_inbound":
			if err := func() error {
				s.SupportsInbound.Reset()
				if err := s.SupportsInbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_inbound\"")
			}
		case "supports_outbound":
			if err := func() error {
				s.SupportsOutbound.Reset()
				if err := s.SupportsOutbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPhoneNumberSIPTrunkResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPhoneNumberSIPTrunkResponseModel) {
					name = jsonFieldsNameOfGetPhoneNumberSIPTrunkResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPhoneNumberSIPTrunkResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberSIPTrunkResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberSIPTrunkResponseModelProvider as json.
func (s GetPhoneNumberSIPTrunkResponseModelProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetPhoneNumberSIPTrunkResponseModelProvider from json.
func (s *GetPhoneNumberSIPTrunkResponseModelProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberSIPTrunkResponseModelProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetPhoneNumberSIPTrunkResponseModelProvider(v) {
	case GetPhoneNumberSIPTrunkResponseModelProviderSipTrunk:
		*s = GetPhoneNumberSIPTrunkResponseModelProviderSipTrunk
	default:
		*s = GetPhoneNumberSIPTrunkResponseModelProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetPhoneNumberSIPTrunkResponseModelProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberSIPTrunkResponseModelProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPhoneNumberTwilioResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPhoneNumberTwilioResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AssignedAgent.Set {
			e.FieldStart("assigned_agent")
			s.AssignedAgent.Encode(e)
		}
	}
	{
		e.FieldStart("label")
		e.Str(s.Label)
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.SupportsInbound.Set {
			e.FieldStart("supports_inbound")
			s.SupportsInbound.Encode(e)
		}
	}
	{
		if s.SupportsOutbound.Set {
			e.FieldStart("supports_outbound")
			s.SupportsOutbound.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetPhoneNumberTwilioResponseModel = [7]string{
	0: "assigned_agent",
	1: "label",
	2: "phone_number",
	3: "phone_number_id",
	4: "provider",
	5: "supports_inbound",
	6: "supports_outbound",
}

// Decode decodes GetPhoneNumberTwilioResponseModel from json.
func (s *GetPhoneNumberTwilioResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberTwilioResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assigned_agent":
			if err := func() error {
				s.AssignedAgent.Reset()
				if err := s.AssignedAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned_agent\"")
			}
		case "label":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Label = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"label\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "supports_inbound":
			if err := func() error {
				s.SupportsInbound.Reset()
				if err := s.SupportsInbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_inbound\"")
			}
		case "supports_outbound":
			if err := func() error {
				s.SupportsOutbound.Reset()
				if err := s.SupportsOutbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supports_outbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPhoneNumberTwilioResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPhoneNumberTwilioResponseModel) {
					name = jsonFieldsNameOfGetPhoneNumberTwilioResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPhoneNumberTwilioResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberTwilioResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberTwilioResponseModelProvider as json.
func (s GetPhoneNumberTwilioResponseModelProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetPhoneNumberTwilioResponseModelProvider from json.
func (s *GetPhoneNumberTwilioResponseModelProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPhoneNumberTwilioResponseModelProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetPhoneNumberTwilioResponseModelProvider(v) {
	case GetPhoneNumberTwilioResponseModelProviderTwilio:
		*s = GetPhoneNumberTwilioResponseModelProviderTwilio
	default:
		*s = GetPhoneNumberTwilioResponseModelProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetPhoneNumberTwilioResponseModelProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPhoneNumberTwilioResponseModelProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetProjectsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetProjectsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("projects")
		e.ArrStart()
		for _, elem := range s.Projects {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetProjectsResponseModel = [1]string{
	0: "projects",
}

// Decode decodes GetProjectsResponseModel from json.
func (s *GetProjectsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projects":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Projects = make([]ProjectResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Projects = append(s.Projects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projects\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetProjectsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetProjectsResponseModel) {
					name = jsonFieldsNameOfGetProjectsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetProjectsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPronunciationDictionariesMetadataResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPronunciationDictionariesMetadataResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
	{
		e.FieldStart("pronunciation_dictionaries")
		e.ArrStart()
		for _, elem := range s.PronunciationDictionaries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetPronunciationDictionariesMetadataResponseModel = [3]string{
	0: "has_more",
	1: "next_cursor",
	2: "pronunciation_dictionaries",
}

// Decode decodes GetPronunciationDictionariesMetadataResponseModel from json.
func (s *GetPronunciationDictionariesMetadataResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPronunciationDictionariesMetadataResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		case "pronunciation_dictionaries":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.PronunciationDictionaries = make([]GetPronunciationDictionaryMetadataResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetPronunciationDictionaryMetadataResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PronunciationDictionaries = append(s.PronunciationDictionaries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionaries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPronunciationDictionariesMetadataResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPronunciationDictionariesMetadataResponseModel) {
					name = jsonFieldsNameOfGetPronunciationDictionariesMetadataResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPronunciationDictionariesMetadataResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPronunciationDictionariesMetadataResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPronunciationDictionaryMetadataResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPronunciationDictionaryMetadataResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.ArchivedTimeUnix.Set {
			e.FieldStart("archived_time_unix")
			s.ArchivedTimeUnix.Encode(e)
		}
	}
	{
		e.FieldStart("created_by")
		e.Str(s.CreatedBy)
	}
	{
		e.FieldStart("creation_time_unix")
		e.Int(s.CreationTimeUnix)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("latest_version_id")
		e.Str(s.LatestVersionID)
	}
	{
		e.FieldStart("latest_version_rules_num")
		e.Int(s.LatestVersionRulesNum)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("permission_on_resource")
		s.PermissionOnResource.Encode(e)
	}
}

var jsonFieldsNameOfGetPronunciationDictionaryMetadataResponseModel = [9]string{
	0: "archived_time_unix",
	1: "created_by",
	2: "creation_time_unix",
	3: "description",
	4: "id",
	5: "latest_version_id",
	6: "latest_version_rules_num",
	7: "name",
	8: "permission_on_resource",
}

// Decode decodes GetPronunciationDictionaryMetadataResponseModel from json.
func (s *GetPronunciationDictionaryMetadataResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPronunciationDictionaryMetadataResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archived_time_unix":
			if err := func() error {
				s.ArchivedTimeUnix.Reset()
				if err := s.ArchivedTimeUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archived_time_unix\"")
			}
		case "created_by":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CreatedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "creation_time_unix":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreationTimeUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creation_time_unix\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "latest_version_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.LatestVersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_version_id\"")
			}
		case "latest_version_rules_num":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.LatestVersionRulesNum = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_version_rules_num\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permission_on_resource":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.PermissionOnResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission_on_resource\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPronunciationDictionaryMetadataResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110110,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPronunciationDictionaryMetadataResponseModel) {
					name = jsonFieldsNameOfGetPronunciationDictionaryMetadataResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPronunciationDictionaryMetadataResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPronunciationDictionaryMetadataResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPronunciationDictionaryMetadataResponseModelPermissionOnResource as json.
func (s GetPronunciationDictionaryMetadataResponseModelPermissionOnResource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetPronunciationDictionaryMetadataResponseModelPermissionOnResource from json.
func (s *GetPronunciationDictionaryMetadataResponseModelPermissionOnResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPronunciationDictionaryMetadataResponseModelPermissionOnResource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetPronunciationDictionaryMetadataResponseModelPermissionOnResource(v) {
	case GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceAdmin:
		*s = GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceAdmin
	case GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceEditor:
		*s = GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceEditor
	case GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceCommenter:
		*s = GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceCommenter
	case GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceViewer:
		*s = GetPronunciationDictionaryMetadataResponseModelPermissionOnResourceViewer
	default:
		*s = GetPronunciationDictionaryMetadataResponseModelPermissionOnResource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetPronunciationDictionaryMetadataResponseModelPermissionOnResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPronunciationDictionaryMetadataResponseModelPermissionOnResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSpeechHistoryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSpeechHistoryResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		e.FieldStart("history")
		e.ArrStart()
		for _, elem := range s.History {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.LastHistoryItemID.Set {
			e.FieldStart("last_history_item_id")
			s.LastHistoryItemID.Encode(e)
		}
	}
	{
		if s.ScannedUntil.Set {
			e.FieldStart("scanned_until")
			s.ScannedUntil.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSpeechHistoryResponseModel = [4]string{
	0: "has_more",
	1: "history",
	2: "last_history_item_id",
	3: "scanned_until",
}

// Decode decodes GetSpeechHistoryResponseModel from json.
func (s *GetSpeechHistoryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSpeechHistoryResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "history":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.History = make([]SpeechHistoryItemResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpeechHistoryItemResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.History = append(s.History, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history\"")
			}
		case "last_history_item_id":
			if err := func() error {
				s.LastHistoryItemID.Reset()
				if err := s.LastHistoryItemID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_history_item_id\"")
			}
		case "scanned_until":
			if err := func() error {
				s.ScannedUntil.Reset()
				if err := s.ScannedUntil.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scanned_until\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSpeechHistoryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSpeechHistoryResponseModel) {
					name = jsonFieldsNameOfGetSpeechHistoryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSpeechHistoryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSpeechHistoryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTestInvocationsPageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTestInvocationsPageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetTestInvocationsPageResponseModel = [4]string{
	0: "has_more",
	1: "meta",
	2: "next_cursor",
	3: "results",
}

// Decode decodes GetTestInvocationsPageResponseModel from json.
func (s *GetTestInvocationsPageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTestInvocationsPageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]TestInvocationSummaryResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TestInvocationSummaryResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTestInvocationsPageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTestInvocationsPageResponseModel) {
					name = jsonFieldsNameOfGetTestInvocationsPageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTestInvocationsPageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTestInvocationsPageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTestSuiteInvocationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTestSuiteInvocationResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AgentID.Set {
			e.FieldStart("agent_id")
			s.AgentID.Encode(e)
		}
	}
	{
		if s.BranchID.Set {
			e.FieldStart("branch_id")
			s.BranchID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("test_runs")
		e.ArrStart()
		for _, elem := range s.TestRuns {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetTestSuiteInvocationResponseModel = [5]string{
	0: "agent_id",
	1: "branch_id",
	2: "created_at",
	3: "id",
	4: "test_runs",
}

// Decode decodes GetTestSuiteInvocationResponseModel from json.
func (s *GetTestSuiteInvocationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTestSuiteInvocationResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			if err := func() error {
				s.AgentID.Reset()
				if err := s.AgentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "branch_id":
			if err := func() error {
				s.BranchID.Reset()
				if err := s.BranchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_id\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "test_runs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.TestRuns = make([]UnitTestRunResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UnitTestRunResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TestRuns = append(s.TestRuns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_runs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTestSuiteInvocationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTestSuiteInvocationResponseModel) {
					name = jsonFieldsNameOfGetTestSuiteInvocationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTestSuiteInvocationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTestSuiteInvocationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTestsPageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTestsPageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
	{
		e.FieldStart("tests")
		e.ArrStart()
		for _, elem := range s.Tests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetTestsPageResponseModel = [3]string{
	0: "has_more",
	1: "next_cursor",
	2: "tests",
}

// Decode decodes GetTestsPageResponseModel from json.
func (s *GetTestsPageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTestsPageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		case "tests":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Tests = make([]UnitTestSummaryResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UnitTestSummaryResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tests = append(s.Tests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTestsPageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTestsPageResponseModel) {
					name = jsonFieldsNameOfGetTestsPageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTestsPageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTestsPageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTestsSummariesByIdsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTestsSummariesByIdsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tests")
		s.Tests.Encode(e)
	}
}

var jsonFieldsNameOfGetTestsSummariesByIdsResponseModel = [1]string{
	0: "tests",
}

// Decode decodes GetTestsSummariesByIdsResponseModel from json.
func (s *GetTestsSummariesByIdsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTestsSummariesByIdsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tests":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Tests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTestsSummariesByIdsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTestsSummariesByIdsResponseModel) {
					name = jsonFieldsNameOfGetTestsSummariesByIdsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTestsSummariesByIdsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTestsSummariesByIdsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetTestsSummariesByIdsResponseModelTests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetTestsSummariesByIdsResponseModelTests) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GetTestsSummariesByIdsResponseModelTests from json.
func (s *GetTestsSummariesByIdsResponseModelTests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTestsSummariesByIdsResponseModelTests to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem UnitTestSummaryResponseModel
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTestsSummariesByIdsResponseModelTests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTestsSummariesByIdsResponseModelTests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTestsSummariesByIdsResponseModelTests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetToolDependentAgentsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetToolDependentAgentsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agents")
		e.ArrStart()
		for _, elem := range s.Agents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextCursor.Set {
			e.FieldStart("next_cursor")
			s.NextCursor.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetToolDependentAgentsResponseModel = [3]string{
	0: "agents",
	1: "has_more",
	2: "next_cursor",
}

// Decode decodes GetToolDependentAgentsResponseModel from json.
func (s *GetToolDependentAgentsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetToolDependentAgentsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agents":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Agents = make([]GetToolDependentAgentsResponseModelAgentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetToolDependentAgentsResponseModelAgentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Agents = append(s.Agents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agents\"")
			}
		case "has_more":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_cursor":
			if err := func() error {
				s.NextCursor.Reset()
				if err := s.NextCursor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_cursor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetToolDependentAgentsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetToolDependentAgentsResponseModel) {
					name = jsonFieldsNameOfGetToolDependentAgentsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetToolDependentAgentsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetToolDependentAgentsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetToolDependentAgentsResponseModelAgentsItem as json.
func (s GetToolDependentAgentsResponseModelAgentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s GetToolDependentAgentsResponseModelAgentsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DependentAvailableAgentIdentifierGetToolDependentAgentsResponseModelAgentsItem:
		e.FieldStart("type")
		e.Str("available")
		{
			s := s.DependentAvailableAgentIdentifier
			{
				e.FieldStart("access_level")
				s.AccessLevel.Encode(e)
			}
			{
				e.FieldStart("created_at_unix_secs")
				e.Int(s.CreatedAtUnixSecs)
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	case DependentUnknownAgentIdentifierGetToolDependentAgentsResponseModelAgentsItem:
		e.FieldStart("type")
		e.Str("unknown")
		{
			s := s.DependentUnknownAgentIdentifier
			{
				if s.ReferencedResourceIds != nil {
					e.FieldStart("referenced_resource_ids")
					e.ArrStart()
					for _, elem := range s.ReferencedResourceIds {
						e.Str(elem)
					}
					e.ArrEnd()
				}
			}
		}
	}
}

// Decode decodes GetToolDependentAgentsResponseModelAgentsItem from json.
func (s *GetToolDependentAgentsResponseModelAgentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetToolDependentAgentsResponseModelAgentsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "available":
					s.Type = DependentAvailableAgentIdentifierGetToolDependentAgentsResponseModelAgentsItem
					found = true
				case "unknown":
					s.Type = DependentUnknownAgentIdentifierGetToolDependentAgentsResponseModelAgentsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DependentAvailableAgentIdentifierGetToolDependentAgentsResponseModelAgentsItem:
		if err := s.DependentAvailableAgentIdentifier.Decode(d); err != nil {
			return err
		}
	case DependentUnknownAgentIdentifierGetToolDependentAgentsResponseModelAgentsItem:
		if err := s.DependentUnknownAgentIdentifier.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetToolDependentAgentsResponseModelAgentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetToolDependentAgentsResponseModelAgentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTranscriptByIDNotFoundApplicationJSON as json.
func (s GetTranscriptByIDNotFoundApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetTranscriptByIDNotFoundApplicationJSON from json.
func (s *GetTranscriptByIDNotFoundApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTranscriptByIDNotFoundApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTranscriptByIDNotFoundApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTranscriptByIDNotFoundApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTranscriptByIDNotFoundApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTranscriptByIDOK as json.
func (s GetTranscriptByIDOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case SpeechToTextChunkResponseModelGetTranscriptByIDOK:
		s.SpeechToTextChunkResponseModel.Encode(e)
	case MultichannelSpeechToTextResponseModelGetTranscriptByIDOK:
		s.MultichannelSpeechToTextResponseModel.Encode(e)
	}
}

func (s GetTranscriptByIDOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case SpeechToTextChunkResponseModelGetTranscriptByIDOK:
		s.SpeechToTextChunkResponseModel.encodeFields(e)
	case MultichannelSpeechToTextResponseModelGetTranscriptByIDOK:
		s.MultichannelSpeechToTextResponseModel.encodeFields(e)
	}
}

// Decode decodes GetTranscriptByIDOK from json.
func (s *GetTranscriptByIDOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTranscriptByIDOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "additional_formats":
				// Type-based discrimination: check if field has expected JSON type (nullable)
				typ := d.Next()
				if typ != jx.Array && typ != jx.Null {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "channel_index":
				// Type-based discrimination: check if field has expected JSON type (nullable)
				typ := d.Next()
				if typ != jx.Number && typ != jx.Null {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "language_code":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "language_probability":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Number {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "text":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "transcripts":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := MultichannelSpeechToTextResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "words":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelGetTranscriptByIDOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SpeechToTextChunkResponseModelGetTranscriptByIDOK:
		if err := s.SpeechToTextChunkResponseModel.Decode(d); err != nil {
			return err
		}
	case MultichannelSpeechToTextResponseModelGetTranscriptByIDOK:
		if err := s.MultichannelSpeechToTextResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTranscriptByIDOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTranscriptByIDOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTranscriptByIDUnauthorizedApplicationJSON as json.
func (s GetTranscriptByIDUnauthorizedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes GetTranscriptByIDUnauthorizedApplicationJSON from json.
func (s *GetTranscriptByIDUnauthorizedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTranscriptByIDUnauthorizedApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetTranscriptByIDUnauthorizedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTranscriptByIDUnauthorizedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTranscriptByIDUnauthorizedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUnitTestResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUnitTestResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_history")
		e.ArrStart()
		for _, elem := range s.ChatHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		e.FieldStart("failure_examples")
		e.ArrStart()
		for _, elem := range s.FailureExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FromConversationMetadata.Set {
			e.FieldStart("from_conversation_metadata")
			s.FromConversationMetadata.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("success_condition")
		e.Str(s.SuccessCondition)
	}
	{
		e.FieldStart("success_examples")
		e.ArrStart()
		for _, elem := range s.SuccessExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ToolCallParameters.Set {
			e.FieldStart("tool_call_parameters")
			s.ToolCallParameters.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUnitTestResponseModel = [10]string{
	0: "chat_history",
	1: "dynamic_variables",
	2: "failure_examples",
	3: "from_conversation_metadata",
	4: "id",
	5: "name",
	6: "success_condition",
	7: "success_examples",
	8: "tool_call_parameters",
	9: "type",
}

// Decode decodes GetUnitTestResponseModel from json.
func (s *GetUnitTestResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUnitTestResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_history":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ChatHistory = make([]ConversationHistoryTranscriptCommonModelOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChatHistory = append(s.ChatHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_history\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "failure_examples":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FailureExamples = make([]AgentFailureResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentFailureResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailureExamples = append(s.FailureExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_examples\"")
			}
		case "from_conversation_metadata":
			if err := func() error {
				s.FromConversationMetadata.Reset()
				if err := s.FromConversationMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_conversation_metadata\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "success_condition":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.SuccessCondition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_condition\"")
			}
		case "success_examples":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.SuccessExamples = make([]AgentSuccessfulResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentSuccessfulResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SuccessExamples = append(s.SuccessExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_examples\"")
			}
		case "tool_call_parameters":
			if err := func() error {
				s.ToolCallParameters.Reset()
				if err := s.ToolCallParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_parameters\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUnitTestResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUnitTestResponseModel) {
					name = jsonFieldsNameOfGetUnitTestResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUnitTestResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUnitTestResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetUnitTestResponseModelDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetUnitTestResponseModelDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes GetUnitTestResponseModelDynamicVariables from json.
func (s *GetUnitTestResponseModelDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUnitTestResponseModelDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilGetUnitTestResponseModelDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUnitTestResponseModelDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUnitTestResponseModelDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUnitTestResponseModelDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUnitTestResponseModelDynamicVariablesItem as json.
func (s GetUnitTestResponseModelDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringGetUnitTestResponseModelDynamicVariablesItem:
		e.Str(s.String)
	case Float64GetUnitTestResponseModelDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntGetUnitTestResponseModelDynamicVariablesItem:
		e.Int(s.Int)
	case BoolGetUnitTestResponseModelDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes GetUnitTestResponseModelDynamicVariablesItem from json.
func (s *GetUnitTestResponseModelDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUnitTestResponseModelDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolGetUnitTestResponseModelDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntGetUnitTestResponseModelDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64GetUnitTestResponseModelDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringGetUnitTestResponseModelDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUnitTestResponseModelDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUnitTestResponseModelDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetVoicesResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetVoicesResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("voices")
		e.ArrStart()
		for _, elem := range s.Voices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetVoicesResponseModel = [1]string{
	0: "voices",
}

// Decode decodes GetVoicesResponseModel from json.
func (s *GetVoicesResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVoicesResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "voices":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Voices = make([]VoiceResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Voices = append(s.Voices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetVoicesResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetVoicesResponseModel) {
					name = jsonFieldsNameOfGetVoicesResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVoicesResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVoicesResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetVoicesV2ResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetVoicesV2ResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("has_more")
		e.Bool(s.HasMore)
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("next_page_token")
			s.NextPageToken.Encode(e)
		}
	}
	{
		e.FieldStart("total_count")
		e.Int(s.TotalCount)
	}
	{
		e.FieldStart("voices")
		e.ArrStart()
		for _, elem := range s.Voices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetVoicesV2ResponseModel = [4]string{
	0: "has_more",
	1: "next_page_token",
	2: "total_count",
	3: "voices",
}

// Decode decodes GetVoicesV2ResponseModel from json.
func (s *GetVoicesV2ResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetVoicesV2ResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "has_more":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.HasMore = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_page_token":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_page_token\"")
			}
		case "total_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "voices":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Voices = make([]VoiceResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Voices = append(s.Voices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetVoicesV2ResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetVoicesV2ResponseModel) {
					name = jsonFieldsNameOfGetVoicesV2ResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetVoicesV2ResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetVoicesV2ResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetWhatsAppAccountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetWhatsAppAccountResponse) encodeFields(e *jx.Encoder) {
	{
		if s.AssignedAgentID.Set {
			e.FieldStart("assigned_agent_id")
			s.AssignedAgentID.Encode(e)
		}
	}
	{
		e.FieldStart("assigned_agent_name")
		s.AssignedAgentName.Encode(e)
	}
	{
		e.FieldStart("business_account_id")
		e.Str(s.BusinessAccountID)
	}
	{
		e.FieldStart("business_account_name")
		e.Str(s.BusinessAccountName)
	}
	{
		e.FieldStart("phone_number")
		e.Str(s.PhoneNumber)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		e.FieldStart("phone_number_name")
		e.Str(s.PhoneNumberName)
	}
}

var jsonFieldsNameOfGetWhatsAppAccountResponse = [7]string{
	0: "assigned_agent_id",
	1: "assigned_agent_name",
	2: "business_account_id",
	3: "business_account_name",
	4: "phone_number",
	5: "phone_number_id",
	6: "phone_number_name",
}

// Decode decodes GetWhatsAppAccountResponse from json.
func (s *GetWhatsAppAccountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWhatsAppAccountResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assigned_agent_id":
			if err := func() error {
				s.AssignedAgentID.Reset()
				if err := s.AssignedAgentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned_agent_id\"")
			}
		case "assigned_agent_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.AssignedAgentName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned_agent_name\"")
			}
		case "business_account_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.BusinessAccountID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_account_id\"")
			}
		case "business_account_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.BusinessAccountName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_account_name\"")
			}
		case "phone_number":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "phone_number_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetWhatsAppAccountResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetWhatsAppAccountResponse) {
					name = jsonFieldsNameOfGetWhatsAppAccountResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWhatsAppAccountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWhatsAppAccountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetWorkspaceSecretsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetWorkspaceSecretsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("secrets")
		e.ArrStart()
		for _, elem := range s.Secrets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetWorkspaceSecretsResponseModel = [1]string{
	0: "secrets",
}

// Decode decodes GetWorkspaceSecretsResponseModel from json.
func (s *GetWorkspaceSecretsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetWorkspaceSecretsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "secrets":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Secrets = make([]ConvAIWorkspaceStoredSecretConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConvAIWorkspaceStoredSecretConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Secrets = append(s.Secrets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetWorkspaceSecretsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetWorkspaceSecretsResponseModel) {
					name = jsonFieldsNameOfGetWorkspaceSecretsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetWorkspaceSecretsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetWorkspaceSecretsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTTPValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTTPValidationError) encodeFields(e *jx.Encoder) {
	{
		if s.Detail != nil {
			e.FieldStart("detail")
			e.ArrStart()
			for _, elem := range s.Detail {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTTPValidationError = [1]string{
	0: "detail",
}

// Decode decodes HTTPValidationError from json.
func (s *HTTPValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPValidationError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "detail":
			if err := func() error {
				s.Detail = make([]ValidationError, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationError
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Detail = append(s.Detail, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTTPValidationError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTTPValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HistoryAlignmentResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HistoryAlignmentResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_end_times_seconds")
		e.ArrStart()
		for _, elem := range s.CharacterEndTimesSeconds {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("character_start_times_seconds")
		e.ArrStart()
		for _, elem := range s.CharacterStartTimesSeconds {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("characters")
		e.ArrStart()
		for _, elem := range s.Characters {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfHistoryAlignmentResponseModel = [3]string{
	0: "character_end_times_seconds",
	1: "character_start_times_seconds",
	2: "characters",
}

// Decode decodes HistoryAlignmentResponseModel from json.
func (s *HistoryAlignmentResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HistoryAlignmentResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_end_times_seconds":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.CharacterEndTimesSeconds = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.CharacterEndTimesSeconds = append(s.CharacterEndTimesSeconds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_end_times_seconds\"")
			}
		case "character_start_times_seconds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.CharacterStartTimesSeconds = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.CharacterStartTimesSeconds = append(s.CharacterStartTimesSeconds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_start_times_seconds\"")
			}
		case "characters":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Characters = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Characters = append(s.Characters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HistoryAlignmentResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHistoryAlignmentResponseModel) {
					name = jsonFieldsNameOfHistoryAlignmentResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HistoryAlignmentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HistoryAlignmentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HistoryAlignmentsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HistoryAlignmentsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("alignment")
		s.Alignment.Encode(e)
	}
	{
		e.FieldStart("normalized_alignment")
		s.NormalizedAlignment.Encode(e)
	}
}

var jsonFieldsNameOfHistoryAlignmentsResponseModel = [2]string{
	0: "alignment",
	1: "normalized_alignment",
}

// Decode decodes HistoryAlignmentsResponseModel from json.
func (s *HistoryAlignmentsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HistoryAlignmentsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alignment":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Alignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alignment\"")
			}
		case "normalized_alignment":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NormalizedAlignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normalized_alignment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HistoryAlignmentsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHistoryAlignmentsResponseModel) {
					name = jsonFieldsNameOfHistoryAlignmentsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HistoryAlignmentsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HistoryAlignmentsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HtmlExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HtmlExportOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		if s.IncludeSpeakers.Set {
			e.FieldStart("include_speakers")
			s.IncludeSpeakers.Encode(e)
		}
	}
	{
		if s.IncludeTimestamps.Set {
			e.FieldStart("include_timestamps")
			s.IncludeTimestamps.Encode(e)
		}
	}
	{
		if s.MaxSegmentChars.Set {
			e.FieldStart("max_segment_chars")
			s.MaxSegmentChars.Encode(e)
		}
	}
	{
		if s.MaxSegmentDurationS.Set {
			e.FieldStart("max_segment_duration_s")
			s.MaxSegmentDurationS.Encode(e)
		}
	}
	{
		if s.SegmentOnSilenceLongerThanS.Set {
			e.FieldStart("segment_on_silence_longer_than_s")
			s.SegmentOnSilenceLongerThanS.Encode(e)
		}
	}
}

var jsonFieldsNameOfHtmlExportOptions = [6]string{
	0: "format",
	1: "include_speakers",
	2: "include_timestamps",
	3: "max_segment_chars",
	4: "max_segment_duration_s",
	5: "segment_on_silence_longer_than_s",
}

// Decode decodes HtmlExportOptions from json.
func (s *HtmlExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtmlExportOptions to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "include_speakers":
			if err := func() error {
				s.IncludeSpeakers.Reset()
				if err := s.IncludeSpeakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_speakers\"")
			}
		case "include_timestamps":
			if err := func() error {
				s.IncludeTimestamps.Reset()
				if err := s.IncludeTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_timestamps\"")
			}
		case "max_segment_chars":
			if err := func() error {
				s.MaxSegmentChars.Reset()
				if err := s.MaxSegmentChars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_chars\"")
			}
		case "max_segment_duration_s":
			if err := func() error {
				s.MaxSegmentDurationS.Reset()
				if err := s.MaxSegmentDurationS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_duration_s\"")
			}
		case "segment_on_silence_longer_than_s":
			if err := func() error {
				s.SegmentOnSilenceLongerThanS.Reset()
				if err := s.SegmentOnSilenceLongerThanS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_on_silence_longer_than_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HtmlExportOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHtmlExportOptions) {
					name = jsonFieldsNameOfHtmlExportOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HtmlExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtmlExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtmlExportOptionsFormat as json.
func (s HtmlExportOptionsFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HtmlExportOptionsFormat from json.
func (s *HtmlExportOptionsFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtmlExportOptionsFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HtmlExportOptionsFormat(v) {
	case HtmlExportOptionsFormatHTML:
		*s = HtmlExportOptionsFormatHTML
	default:
		*s = HtmlExportOptionsFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtmlExportOptionsFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtmlExportOptionsFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ImportWhatsAppAccountRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ImportWhatsAppAccountRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("business_account_id")
		e.Str(s.BusinessAccountID)
	}
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
	{
		e.FieldStart("token_code")
		e.Str(s.TokenCode)
	}
}

var jsonFieldsNameOfImportWhatsAppAccountRequest = [3]string{
	0: "business_account_id",
	1: "phone_number_id",
	2: "token_code",
}

// Decode decodes ImportWhatsAppAccountRequest from json.
func (s *ImportWhatsAppAccountRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportWhatsAppAccountRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "business_account_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BusinessAccountID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"business_account_id\"")
			}
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		case "token_code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TokenCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ImportWhatsAppAccountRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImportWhatsAppAccountRequest) {
					name = jsonFieldsNameOfImportWhatsAppAccountRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportWhatsAppAccountRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportWhatsAppAccountRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ImportWhatsAppAccountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ImportWhatsAppAccountResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("phone_number_id")
		e.Str(s.PhoneNumberID)
	}
}

var jsonFieldsNameOfImportWhatsAppAccountResponse = [1]string{
	0: "phone_number_id",
}

// Decode decodes ImportWhatsAppAccountResponse from json.
func (s *ImportWhatsAppAccountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ImportWhatsAppAccountResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "phone_number_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PhoneNumberID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ImportWhatsAppAccountResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfImportWhatsAppAccountResponse) {
					name = jsonFieldsNameOfImportWhatsAppAccountResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ImportWhatsAppAccountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ImportWhatsAppAccountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InboundSIPTrunkConfigRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InboundSIPTrunkConfigRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.AllowedAddresses.Set {
			e.FieldStart("allowed_addresses")
			s.AllowedAddresses.Encode(e)
		}
	}
	{
		if s.AllowedNumbers.Set {
			e.FieldStart("allowed_numbers")
			s.AllowedNumbers.Encode(e)
		}
	}
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.MediaEncryption.Set {
			e.FieldStart("media_encryption")
			s.MediaEncryption.Encode(e)
		}
	}
	{
		if s.RemoteDomains.Set {
			e.FieldStart("remote_domains")
			s.RemoteDomains.Encode(e)
		}
	}
}

var jsonFieldsNameOfInboundSIPTrunkConfigRequestModel = [5]string{
	0: "allowed_addresses",
	1: "allowed_numbers",
	2: "credentials",
	3: "media_encryption",
	4: "remote_domains",
}

// Decode decodes InboundSIPTrunkConfigRequestModel from json.
func (s *InboundSIPTrunkConfigRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InboundSIPTrunkConfigRequestModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowed_addresses":
			if err := func() error {
				s.AllowedAddresses.Reset()
				if err := s.AllowedAddresses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_addresses\"")
			}
		case "allowed_numbers":
			if err := func() error {
				s.AllowedNumbers.Reset()
				if err := s.AllowedNumbers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_numbers\"")
			}
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "media_encryption":
			if err := func() error {
				s.MediaEncryption.Reset()
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "remote_domains":
			if err := func() error {
				s.RemoteDomains.Reset()
				if err := s.RemoteDomains.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote_domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InboundSIPTrunkConfigRequestModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InboundSIPTrunkConfigRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InboundSIPTrunkConfigRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KnowledgeBaseDocumentChunkResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KnowledgeBaseDocumentChunkResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfKnowledgeBaseDocumentChunkResponseModel = [3]string{
	0: "content",
	1: "id",
	2: "name",
}

// Decode decodes KnowledgeBaseDocumentChunkResponseModel from json.
func (s *KnowledgeBaseDocumentChunkResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KnowledgeBaseDocumentChunkResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KnowledgeBaseDocumentChunkResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKnowledgeBaseDocumentChunkResponseModel) {
					name = jsonFieldsNameOfKnowledgeBaseDocumentChunkResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KnowledgeBaseDocumentChunkResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KnowledgeBaseDocumentChunkResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KnowledgeBaseDocumentMetadataResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KnowledgeBaseDocumentMetadataResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("created_at_unix_secs")
		e.Int(s.CreatedAtUnixSecs)
	}
	{
		e.FieldStart("last_updated_at_unix_secs")
		e.Int(s.LastUpdatedAtUnixSecs)
	}
	{
		e.FieldStart("size_bytes")
		e.Int(s.SizeBytes)
	}
}

var jsonFieldsNameOfKnowledgeBaseDocumentMetadataResponseModel = [3]string{
	0: "created_at_unix_secs",
	1: "last_updated_at_unix_secs",
	2: "size_bytes",
}

// Decode decodes KnowledgeBaseDocumentMetadataResponseModel from json.
func (s *KnowledgeBaseDocumentMetadataResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KnowledgeBaseDocumentMetadataResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created_at_unix_secs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix_secs\"")
			}
		case "last_updated_at_unix_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.LastUpdatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at_unix_secs\"")
			}
		case "size_bytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.SizeBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KnowledgeBaseDocumentMetadataResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKnowledgeBaseDocumentMetadataResponseModel) {
					name = jsonFieldsNameOfKnowledgeBaseDocumentMetadataResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KnowledgeBaseDocumentMetadataResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KnowledgeBaseDocumentMetadataResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KnowledgeBaseFolderPathSegmentResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KnowledgeBaseFolderPathSegmentResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
}

var jsonFieldsNameOfKnowledgeBaseFolderPathSegmentResponseModel = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes KnowledgeBaseFolderPathSegmentResponseModel from json.
func (s *KnowledgeBaseFolderPathSegmentResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KnowledgeBaseFolderPathSegmentResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KnowledgeBaseFolderPathSegmentResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKnowledgeBaseFolderPathSegmentResponseModel) {
					name = jsonFieldsNameOfKnowledgeBaseFolderPathSegmentResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KnowledgeBaseFolderPathSegmentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KnowledgeBaseFolderPathSegmentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfKnowledgeBaseSummaryBatchSuccessfulResponseModel = [2]string{
	0: "data",
	1: "status",
}

// Decode decodes KnowledgeBaseSummaryBatchSuccessfulResponseModel from json.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KnowledgeBaseSummaryBatchSuccessfulResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KnowledgeBaseSummaryBatchSuccessfulResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfKnowledgeBaseSummaryBatchSuccessfulResponseModel) {
					name = jsonFieldsNameOfKnowledgeBaseSummaryBatchSuccessfulResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KnowledgeBaseSummaryBatchSuccessfulResponseModelData as json.
func (s KnowledgeBaseSummaryBatchSuccessfulResponseModelData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s KnowledgeBaseSummaryBatchSuccessfulResponseModelData) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetKnowledgeBaseSummaryURLResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		e.FieldStart("type")
		e.Str("url")
		{
			s := s.GetKnowledgeBaseSummaryURLResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("url")
				e.Str(s.URL)
			}
		}
	case GetKnowledgeBaseSummaryFileResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		e.FieldStart("type")
		e.Str("file")
		{
			s := s.GetKnowledgeBaseSummaryFileResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseSummaryTextResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		e.FieldStart("type")
		e.Str("text")
		{
			s := s.GetKnowledgeBaseSummaryTextResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseSummaryFolderResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		e.FieldStart("type")
		e.Str("folder")
		{
			s := s.GetKnowledgeBaseSummaryFolderResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("children_count")
				e.Int(s.ChildrenCount)
			}
			{
				e.FieldStart("dependent_agents")
				e.ArrStart()
				for _, elem := range s.DependentAgents {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	}
}

// Decode decodes KnowledgeBaseSummaryBatchSuccessfulResponseModelData from json.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModelData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KnowledgeBaseSummaryBatchSuccessfulResponseModelData to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "url":
					s.Type = GetKnowledgeBaseSummaryURLResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData
					found = true
				case "file":
					s.Type = GetKnowledgeBaseSummaryFileResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData
					found = true
				case "text":
					s.Type = GetKnowledgeBaseSummaryTextResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData
					found = true
				case "folder":
					s.Type = GetKnowledgeBaseSummaryFolderResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetKnowledgeBaseSummaryURLResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		if err := s.GetKnowledgeBaseSummaryURLResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseSummaryFileResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		if err := s.GetKnowledgeBaseSummaryFileResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseSummaryTextResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		if err := s.GetKnowledgeBaseSummaryTextResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseSummaryFolderResponseModelKnowledgeBaseSummaryBatchSuccessfulResponseModelData:
		if err := s.GetKnowledgeBaseSummaryFolderResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KnowledgeBaseSummaryBatchSuccessfulResponseModelData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModelData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus as json.
func (s KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus from json.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus(v) {
	case KnowledgeBaseSummaryBatchSuccessfulResponseModelStatusSuccess:
		*s = KnowledgeBaseSummaryBatchSuccessfulResponseModelStatusSuccess
	default:
		*s = KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KnowledgeBaseSummaryBatchSuccessfulResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLM as json.
func (s LLM) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LLM from json.
func (s *LLM) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLM to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LLM(v) {
	case LLMGpt4oMini:
		*s = LLMGpt4oMini
	case LLMGpt4o:
		*s = LLMGpt4o
	case LLMGpt4:
		*s = LLMGpt4
	case LLMGpt4Turbo:
		*s = LLMGpt4Turbo
	case LLMGpt41:
		*s = LLMGpt41
	case LLMGpt41Mini:
		*s = LLMGpt41Mini
	case LLMGpt41Nano:
		*s = LLMGpt41Nano
	case LLMGpt5:
		*s = LLMGpt5
	case LLMGpt51:
		*s = LLMGpt51
	case LLMGpt52:
		*s = LLMGpt52
	case LLMGpt52ChatLatest:
		*s = LLMGpt52ChatLatest
	case LLMGpt5Mini:
		*s = LLMGpt5Mini
	case LLMGpt5Nano:
		*s = LLMGpt5Nano
	case LLMGpt35Turbo:
		*s = LLMGpt35Turbo
	case LLMGemini15Pro:
		*s = LLMGemini15Pro
	case LLMGemini15Flash:
		*s = LLMGemini15Flash
	case LLMGemini20Flash:
		*s = LLMGemini20Flash
	case LLMGemini20FlashLite:
		*s = LLMGemini20FlashLite
	case LLMGemini25FlashLite:
		*s = LLMGemini25FlashLite
	case LLMGemini25Flash:
		*s = LLMGemini25Flash
	case LLMGemini3ProPreview:
		*s = LLMGemini3ProPreview
	case LLMGemini3FlashPreview:
		*s = LLMGemini3FlashPreview
	case LLMClaudeSonnet45:
		*s = LLMClaudeSonnet45
	case LLMClaudeSonnet4:
		*s = LLMClaudeSonnet4
	case LLMClaudeHaiku45:
		*s = LLMClaudeHaiku45
	case LLMClaude37Sonnet:
		*s = LLMClaude37Sonnet
	case LLMClaude35Sonnet:
		*s = LLMClaude35Sonnet
	case LLMClaude35SonnetV1:
		*s = LLMClaude35SonnetV1
	case LLMClaude3Haiku:
		*s = LLMClaude3Haiku
	case LLMGrokBeta:
		*s = LLMGrokBeta
	case LLMCustomLlm:
		*s = LLMCustomLlm
	case LLMQwen34b:
		*s = LLMQwen34b
	case LLMQwen330bA3b:
		*s = LLMQwen330bA3b
	case LLMGptOss20b:
		*s = LLMGptOss20b
	case LLMGptOss120b:
		*s = LLMGptOss120b
	case LLMGlm45AirFp8:
		*s = LLMGlm45AirFp8
	case LLMGemini25FlashPreview092025:
		*s = LLMGemini25FlashPreview092025
	case LLMGemini25FlashLitePreview092025:
		*s = LLMGemini25FlashLitePreview092025
	case LLMGemini25FlashPreview0520:
		*s = LLMGemini25FlashPreview0520
	case LLMGemini25FlashPreview0417:
		*s = LLMGemini25FlashPreview0417
	case LLMGemini25FlashLitePreview0617:
		*s = LLMGemini25FlashLitePreview0617
	case LLMGemini20FlashLite001:
		*s = LLMGemini20FlashLite001
	case LLMGemini20Flash001:
		*s = LLMGemini20Flash001
	case LLMGemini15Flash002:
		*s = LLMGemini15Flash002
	case LLMGemini15Flash001:
		*s = LLMGemini15Flash001
	case LLMGemini15Pro002:
		*s = LLMGemini15Pro002
	case LLMGemini15Pro001:
		*s = LLMGemini15Pro001
	case LLMClaudeSonnet420250514:
		*s = LLMClaudeSonnet420250514
	case LLMClaudeSonnet4520250929:
		*s = LLMClaudeSonnet4520250929
	case LLMClaudeHaiku4520251001:
		*s = LLMClaudeHaiku4520251001
	case LLMClaude37Sonnet20250219:
		*s = LLMClaude37Sonnet20250219
	case LLMClaude35Sonnet20240620:
		*s = LLMClaude35Sonnet20240620
	case LLMClaude35SonnetV220241022:
		*s = LLMClaude35SonnetV220241022
	case LLMClaude3Haiku20240307:
		*s = LLMClaude3Haiku20240307
	case LLMGpt520250807:
		*s = LLMGpt520250807
	case LLMGpt5120251113:
		*s = LLMGpt5120251113
	case LLMGpt5220251211:
		*s = LLMGpt5220251211
	case LLMGpt5Mini20250807:
		*s = LLMGpt5Mini20250807
	case LLMGpt5Nano20250807:
		*s = LLMGpt5Nano20250807
	case LLMGpt4120250414:
		*s = LLMGpt4120250414
	case LLMGpt41Mini20250414:
		*s = LLMGpt41Mini20250414
	case LLMGpt41Nano20250414:
		*s = LLMGpt41Nano20250414
	case LLMGpt4oMini20240718:
		*s = LLMGpt4oMini20240718
	case LLMGpt4o20241120:
		*s = LLMGpt4o20241120
	case LLMGpt4o20240806:
		*s = LLMGpt4o20240806
	case LLMGpt4o20240513:
		*s = LLMGpt4o20240513
	case LLMGpt40613:
		*s = LLMGpt40613
	case LLMGpt40314:
		*s = LLMGpt40314
	case LLMGpt4Turbo20240409:
		*s = LLMGpt4Turbo20240409
	case LLMGpt35Turbo0125:
		*s = LLMGpt35Turbo0125
	case LLMGpt35Turbo1106:
		*s = LLMGpt35Turbo1106
	case LLMWattTool8b:
		*s = LLMWattTool8b
	case LLMWattTool70b:
		*s = LLMWattTool70b
	default:
		*s = LLM(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMCategoryUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMCategoryUsage) encodeFields(e *jx.Encoder) {
	{
		if s.InitiatedGeneration.Set {
			e.FieldStart("initiated_generation")
			s.InitiatedGeneration.Encode(e)
		}
	}
	{
		if s.IrreversibleGeneration.Set {
			e.FieldStart("irreversible_generation")
			s.IrreversibleGeneration.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMCategoryUsage = [2]string{
	0: "initiated_generation",
	1: "irreversible_generation",
}

// Decode decodes LLMCategoryUsage from json.
func (s *LLMCategoryUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMCategoryUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "initiated_generation":
			if err := func() error {
				s.InitiatedGeneration.Reset()
				if err := s.InitiatedGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiated_generation\"")
			}
		case "irreversible_generation":
			if err := func() error {
				s.IrreversibleGeneration.Reset()
				if err := s.IrreversibleGeneration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"irreversible_generation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMCategoryUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMCategoryUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMCategoryUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMInputOutputTokensUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMInputOutputTokensUsage) encodeFields(e *jx.Encoder) {
	{
		if s.Input.Set {
			e.FieldStart("input")
			s.Input.Encode(e)
		}
	}
	{
		if s.InputCacheRead.Set {
			e.FieldStart("input_cache_read")
			s.InputCacheRead.Encode(e)
		}
	}
	{
		if s.InputCacheWrite.Set {
			e.FieldStart("input_cache_write")
			s.InputCacheWrite.Encode(e)
		}
	}
	{
		if s.OutputTotal.Set {
			e.FieldStart("output_total")
			s.OutputTotal.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMInputOutputTokensUsage = [4]string{
	0: "input",
	1: "input_cache_read",
	2: "input_cache_write",
	3: "output_total",
}

// Decode decodes LLMInputOutputTokensUsage from json.
func (s *LLMInputOutputTokensUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMInputOutputTokensUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "input":
			if err := func() error {
				s.Input.Reset()
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "input_cache_read":
			if err := func() error {
				s.InputCacheRead.Reset()
				if err := s.InputCacheRead.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_cache_read\"")
			}
		case "input_cache_write":
			if err := func() error {
				s.InputCacheWrite.Reset()
				if err := s.InputCacheWrite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input_cache_write\"")
			}
		case "output_total":
			if err := func() error {
				s.OutputTotal.Reset()
				if err := s.OutputTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output_total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMInputOutputTokensUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMInputOutputTokensUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMInputOutputTokensUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMParameterEvaluationStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMParameterEvaluationStrategy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfLLMParameterEvaluationStrategy = [2]string{
	0: "description",
	1: "type",
}

// Decode decodes LLMParameterEvaluationStrategy from json.
func (s *LLMParameterEvaluationStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMParameterEvaluationStrategy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMParameterEvaluationStrategy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMParameterEvaluationStrategy) {
					name = jsonFieldsNameOfLLMParameterEvaluationStrategy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMParameterEvaluationStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMParameterEvaluationStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMParameterEvaluationStrategyType as json.
func (s LLMParameterEvaluationStrategyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LLMParameterEvaluationStrategyType from json.
func (s *LLMParameterEvaluationStrategyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMParameterEvaluationStrategyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LLMParameterEvaluationStrategyType(v) {
	case LLMParameterEvaluationStrategyTypeLlm:
		*s = LLMParameterEvaluationStrategyTypeLlm
	default:
		*s = LLMParameterEvaluationStrategyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMParameterEvaluationStrategyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMParameterEvaluationStrategyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMTokensCategoryUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMTokensCategoryUsage) encodeFields(e *jx.Encoder) {
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Tokens.Set {
			e.FieldStart("tokens")
			s.Tokens.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMTokensCategoryUsage = [2]string{
	0: "price",
	1: "tokens",
}

// Decode decodes LLMTokensCategoryUsage from json.
func (s *LLMTokensCategoryUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMTokensCategoryUsage to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "tokens":
			if err := func() error {
				s.Tokens.Reset()
				if err := s.Tokens.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMTokensCategoryUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMTokensCategoryUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMTokensCategoryUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMUsageCalculatorLLMResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMUsageCalculatorLLMResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("llm")
		s.Llm.Encode(e)
	}
	{
		e.FieldStart("price_per_minute")
		e.Float64(s.PricePerMinute)
	}
}

var jsonFieldsNameOfLLMUsageCalculatorLLMResponseModel = [2]string{
	0: "llm",
	1: "price_per_minute",
}

// Decode decodes LLMUsageCalculatorLLMResponseModel from json.
func (s *LLMUsageCalculatorLLMResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageCalculatorLLMResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "llm":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Llm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm\"")
			}
		case "price_per_minute":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.PricePerMinute = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price_per_minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageCalculatorLLMResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMUsageCalculatorLLMResponseModel) {
					name = jsonFieldsNameOfLLMUsageCalculatorLLMResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMUsageCalculatorLLMResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageCalculatorLLMResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMUsageCalculatorPublicRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMUsageCalculatorPublicRequestModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("number_of_pages")
		e.Int(s.NumberOfPages)
	}
	{
		e.FieldStart("prompt_length")
		e.Int(s.PromptLength)
	}
	{
		e.FieldStart("rag_enabled")
		e.Bool(s.RagEnabled)
	}
}

var jsonFieldsNameOfLLMUsageCalculatorPublicRequestModel = [3]string{
	0: "number_of_pages",
	1: "prompt_length",
	2: "rag_enabled",
}

// Decode decodes LLMUsageCalculatorPublicRequestModel from json.
func (s *LLMUsageCalculatorPublicRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageCalculatorPublicRequestModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number_of_pages":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.NumberOfPages = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number_of_pages\"")
			}
		case "prompt_length":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PromptLength = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_length\"")
			}
		case "rag_enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.RagEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageCalculatorPublicRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMUsageCalculatorPublicRequestModel) {
					name = jsonFieldsNameOfLLMUsageCalculatorPublicRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMUsageCalculatorPublicRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageCalculatorPublicRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMUsageCalculatorRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMUsageCalculatorRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.NumberOfPages.Set {
			e.FieldStart("number_of_pages")
			s.NumberOfPages.Encode(e)
		}
	}
	{
		if s.PromptLength.Set {
			e.FieldStart("prompt_length")
			s.PromptLength.Encode(e)
		}
	}
	{
		if s.RagEnabled.Set {
			e.FieldStart("rag_enabled")
			s.RagEnabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMUsageCalculatorRequestModel = [3]string{
	0: "number_of_pages",
	1: "prompt_length",
	2: "rag_enabled",
}

// Decode decodes LLMUsageCalculatorRequestModel from json.
func (s *LLMUsageCalculatorRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageCalculatorRequestModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number_of_pages":
			if err := func() error {
				s.NumberOfPages.Reset()
				if err := s.NumberOfPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number_of_pages\"")
			}
		case "prompt_length":
			if err := func() error {
				s.PromptLength.Reset()
				if err := s.PromptLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_length\"")
			}
		case "rag_enabled":
			if err := func() error {
				s.RagEnabled.Reset()
				if err := s.RagEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageCalculatorRequestModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMUsageCalculatorRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageCalculatorRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMUsageCalculatorResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMUsageCalculatorResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("llm_prices")
		e.ArrStart()
		for _, elem := range s.LlmPrices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLLMUsageCalculatorResponseModel = [1]string{
	0: "llm_prices",
}

// Decode decodes LLMUsageCalculatorResponseModel from json.
func (s *LLMUsageCalculatorResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageCalculatorResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "llm_prices":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.LlmPrices = make([]LLMUsageCalculatorLLMResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LLMUsageCalculatorLLMResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LlmPrices = append(s.LlmPrices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm_prices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageCalculatorResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLLMUsageCalculatorResponseModel) {
					name = jsonFieldsNameOfLLMUsageCalculatorResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMUsageCalculatorResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageCalculatorResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMUsageInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMUsageInput) encodeFields(e *jx.Encoder) {
	{
		if s.ModelUsage.Set {
			e.FieldStart("model_usage")
			s.ModelUsage.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMUsageInput = [1]string{
	0: "model_usage",
}

// Decode decodes LLMUsageInput from json.
func (s *LLMUsageInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageInput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_usage":
			if err := func() error {
				s.ModelUsage.Reset()
				if err := s.ModelUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMUsageInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LLMUsageInputModelUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LLMUsageInputModelUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes LLMUsageInputModelUsage from json.
func (s *LLMUsageInputModelUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageInputModelUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem LLMInputOutputTokensUsage
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageInputModelUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMUsageInputModelUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageInputModelUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LLMUsageOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LLMUsageOutput) encodeFields(e *jx.Encoder) {
	{
		if s.ModelUsage.Set {
			e.FieldStart("model_usage")
			s.ModelUsage.Encode(e)
		}
	}
}

var jsonFieldsNameOfLLMUsageOutput = [1]string{
	0: "model_usage",
}

// Decode decodes LLMUsageOutput from json.
func (s *LLMUsageOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageOutput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model_usage":
			if err := func() error {
				s.ModelUsage.Reset()
				if err := s.ModelUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LLMUsageOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LLMUsageOutputModelUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LLMUsageOutputModelUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes LLMUsageOutputModelUsage from json.
func (s *LLMUsageOutputModelUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LLMUsageOutputModelUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem LLMInputOutputTokensUsage
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LLMUsageOutputModelUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LLMUsageOutputModelUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LLMUsageOutputModelUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LanguageAddedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LanguageAddedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfLanguageAddedResponse = [1]string{
	0: "version",
}

// Decode decodes LanguageAddedResponse from json.
func (s *LanguageAddedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageAddedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LanguageAddedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLanguageAddedResponse) {
					name = jsonFieldsNameOfLanguageAddedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LanguageAddedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageAddedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LanguageDetectionToolResultModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LanguageDetectionToolResultModel) encodeFields(e *jx.Encoder) {
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfLanguageDetectionToolResultModel = [4]string{
	0: "language",
	1: "reason",
	2: "result_type",
	3: "status",
}

// Decode decodes LanguageDetectionToolResultModel from json.
func (s *LanguageDetectionToolResultModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageDetectionToolResultModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LanguageDetectionToolResultModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LanguageDetectionToolResultModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageDetectionToolResultModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LanguageDetectionToolResultModelResultType as json.
func (s LanguageDetectionToolResultModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LanguageDetectionToolResultModelResultType from json.
func (s *LanguageDetectionToolResultModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageDetectionToolResultModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LanguageDetectionToolResultModelResultType(v) {
	case LanguageDetectionToolResultModelResultTypeLanguageDetectionSuccess:
		*s = LanguageDetectionToolResultModelResultTypeLanguageDetectionSuccess
	default:
		*s = LanguageDetectionToolResultModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LanguageDetectionToolResultModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageDetectionToolResultModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LanguageDetectionToolResultModelStatus as json.
func (s LanguageDetectionToolResultModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LanguageDetectionToolResultModelStatus from json.
func (s *LanguageDetectionToolResultModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageDetectionToolResultModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LanguageDetectionToolResultModelStatus(v) {
	case LanguageDetectionToolResultModelStatusSuccess:
		*s = LanguageDetectionToolResultModelStatusSuccess
	default:
		*s = LanguageDetectionToolResultModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LanguageDetectionToolResultModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageDetectionToolResultModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LanguageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LanguageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("language_id")
		e.Str(s.LanguageID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfLanguageResponseModel = [2]string{
	0: "language_id",
	1: "name",
}

// Decode decodes LanguageResponseModel from json.
func (s *LanguageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LanguageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.LanguageID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LanguageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLanguageResponseModel) {
					name = jsonFieldsNameOfLanguageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LanguageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LanguageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LibraryVoiceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LibraryVoiceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accent")
		e.Str(s.Accent)
	}
	{
		e.FieldStart("age")
		e.Str(s.Age)
	}
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		e.FieldStart("cloned_by_count")
		e.Int(s.ClonedByCount)
	}
	{
		e.FieldStart("date_unix")
		e.Int(s.DateUnix)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("descriptive")
		e.Str(s.Descriptive)
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
	{
		if s.FiatRate.Set {
			e.FieldStart("fiat_rate")
			s.FiatRate.Encode(e)
		}
	}
	{
		e.FieldStart("free_users_allowed")
		e.Bool(s.FreeUsersAllowed)
	}
	{
		e.FieldStart("gender")
		e.Str(s.Gender)
	}
	{
		if s.ImageURL.Set {
			e.FieldStart("image_url")
			s.ImageURL.Encode(e)
		}
	}
	{
		if s.InstagramUsername.Set {
			e.FieldStart("instagram_username")
			s.InstagramUsername.Encode(e)
		}
	}
	{
		if s.IsAddedByUser.Set {
			e.FieldStart("is_added_by_user")
			s.IsAddedByUser.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		e.FieldStart("live_moderation_enabled")
		e.Bool(s.LiveModerationEnabled)
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.NoticePeriod.Set {
			e.FieldStart("notice_period")
			s.NoticePeriod.Encode(e)
		}
	}
	{
		e.FieldStart("play_api_usage_character_count_1y")
		e.Int(s.PlayAPIUsageCharacterCount1y)
	}
	{
		if s.PreviewURL.Set {
			e.FieldStart("preview_url")
			s.PreviewURL.Encode(e)
		}
	}
	{
		e.FieldStart("public_owner_id")
		e.Str(s.PublicOwnerID)
	}
	{
		if s.Rate.Set {
			e.FieldStart("rate")
			s.Rate.Encode(e)
		}
	}
	{
		if s.TiktokUsername.Set {
			e.FieldStart("tiktok_username")
			s.TiktokUsername.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			e.FieldStart("twitter_username")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.FieldStart("usage_character_count_1y")
		e.Int(s.UsageCharacterCount1y)
	}
	{
		e.FieldStart("usage_character_count_7d")
		e.Int(s.UsageCharacterCount7d)
	}
	{
		e.FieldStart("use_case")
		e.Str(s.UseCase)
	}
	{
		if s.VerifiedLanguages.Set {
			e.FieldStart("verified_languages")
			s.VerifiedLanguages.Encode(e)
		}
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
	{
		if s.YoutubeUsername.Set {
			e.FieldStart("youtube_username")
			s.YoutubeUsername.Encode(e)
		}
	}
}

var jsonFieldsNameOfLibraryVoiceResponseModel = [31]string{
	0:  "accent",
	1:  "age",
	2:  "category",
	3:  "cloned_by_count",
	4:  "date_unix",
	5:  "description",
	6:  "descriptive",
	7:  "featured",
	8:  "fiat_rate",
	9:  "free_users_allowed",
	10: "gender",
	11: "image_url",
	12: "instagram_username",
	13: "is_added_by_user",
	14: "language",
	15: "live_moderation_enabled",
	16: "locale",
	17: "name",
	18: "notice_period",
	19: "play_api_usage_character_count_1y",
	20: "preview_url",
	21: "public_owner_id",
	22: "rate",
	23: "tiktok_username",
	24: "twitter_username",
	25: "usage_character_count_1y",
	26: "usage_character_count_7d",
	27: "use_case",
	28: "verified_languages",
	29: "voice_id",
	30: "youtube_username",
}

// Decode decodes LibraryVoiceResponseModel from json.
func (s *LibraryVoiceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LibraryVoiceResponseModel to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Accent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accent\"")
			}
		case "age":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Age = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"age\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "cloned_by_count":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ClonedByCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cloned_by_count\"")
			}
		case "date_unix":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_unix\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "descriptive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Descriptive = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"descriptive\"")
			}
		case "featured":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "fiat_rate":
			if err := func() error {
				s.FiatRate.Reset()
				if err := s.FiatRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fiat_rate\"")
			}
		case "free_users_allowed":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.FreeUsersAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_users_allowed\"")
			}
		case "gender":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Gender = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gender\"")
			}
		case "image_url":
			if err := func() error {
				s.ImageURL.Reset()
				if err := s.ImageURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_url\"")
			}
		case "instagram_username":
			if err := func() error {
				s.InstagramUsername.Reset()
				if err := s.InstagramUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instagram_username\"")
			}
		case "is_added_by_user":
			if err := func() error {
				s.IsAddedByUser.Reset()
				if err := s.IsAddedByUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_added_by_user\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "live_moderation_enabled":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.LiveModerationEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_moderation_enabled\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notice_period":
			if err := func() error {
				s.NoticePeriod.Reset()
				if err := s.NoticePeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notice_period\"")
			}
		case "play_api_usage_character_count_1y":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PlayAPIUsageCharacterCount1y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"play_api_usage_character_count_1y\"")
			}
		case "preview_url":
			if err := func() error {
				s.PreviewURL.Reset()
				if err := s.PreviewURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preview_url\"")
			}
		case "public_owner_id":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PublicOwnerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_owner_id\"")
			}
		case "rate":
			if err := func() error {
				s.Rate.Reset()
				if err := s.Rate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "tiktok_username":
			if err := func() error {
				s.TiktokUsername.Reset()
				if err := s.TiktokUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tiktok_username\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "usage_character_count_1y":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UsageCharacterCount1y = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_character_count_1y\"")
			}
		case "usage_character_count_7d":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.UsageCharacterCount7d = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_character_count_7d\"")
			}
		case "use_case":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UseCase = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_case\"")
			}
		case "verified_languages":
			if err := func() error {
				s.VerifiedLanguages.Reset()
				if err := s.VerifiedLanguages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified_languages\"")
			}
		case "voice_id":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		case "youtube_username":
			if err := func() error {
				s.YoutubeUsername.Reset()
				if err := s.YoutubeUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"youtube_username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LibraryVoiceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11011111,
		0b10000110,
		0b00101010,
		0b00101110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLibraryVoiceResponseModel) {
					name = jsonFieldsNameOfLibraryVoiceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LibraryVoiceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LibraryVoiceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LibraryVoiceResponseModelCategory as json.
func (s LibraryVoiceResponseModelCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LibraryVoiceResponseModelCategory from json.
func (s *LibraryVoiceResponseModelCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LibraryVoiceResponseModelCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LibraryVoiceResponseModelCategory(v) {
	case LibraryVoiceResponseModelCategoryGenerated:
		*s = LibraryVoiceResponseModelCategoryGenerated
	case LibraryVoiceResponseModelCategoryCloned:
		*s = LibraryVoiceResponseModelCategoryCloned
	case LibraryVoiceResponseModelCategoryPremade:
		*s = LibraryVoiceResponseModelCategoryPremade
	case LibraryVoiceResponseModelCategoryProfessional:
		*s = LibraryVoiceResponseModelCategoryProfessional
	case LibraryVoiceResponseModelCategoryFamous:
		*s = LibraryVoiceResponseModelCategoryFamous
	case LibraryVoiceResponseModelCategoryHighQuality:
		*s = LibraryVoiceResponseModelCategoryHighQuality
	default:
		*s = LibraryVoiceResponseModelCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LibraryVoiceResponseModelCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LibraryVoiceResponseModelCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListMCPToolsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListMCPToolsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorMessage.Set {
			e.FieldStart("error_message")
			s.ErrorMessage.Encode(e)
		}
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
	{
		e.FieldStart("tools")
		e.ArrStart()
		for _, elem := range s.Tools {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListMCPToolsResponseModel = [3]string{
	0: "error_message",
	1: "success",
	2: "tools",
}

// Decode decodes ListMCPToolsResponseModel from json.
func (s *ListMCPToolsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListMCPToolsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_message":
			if err := func() error {
				s.ErrorMessage.Reset()
				if err := s.ErrorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "tools":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Tools = make([]Tool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tools = append(s.Tools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tools\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListMCPToolsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListMCPToolsResponseModel) {
					name = jsonFieldsNameOfListMCPToolsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListMCPToolsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListMCPToolsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPhoneNumbersRouteOKApplicationJSON as json.
func (s ListPhoneNumbersRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ListPhoneNumbersRouteOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPhoneNumbersRouteOKApplicationJSON from json.
func (s *ListPhoneNumbersRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPhoneNumbersRouteOKApplicationJSON to nil")
	}
	var unwrapped []ListPhoneNumbersRouteOKItem
	if err := func() error {
		unwrapped = make([]ListPhoneNumbersRouteOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ListPhoneNumbersRouteOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPhoneNumbersRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPhoneNumbersRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPhoneNumbersRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPhoneNumbersRouteOKItem as json.
func (s ListPhoneNumbersRouteOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ListPhoneNumbersRouteOKItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetPhoneNumberTwilioResponseModelListPhoneNumbersRouteOKItem:
		e.FieldStart("provider")
		e.Str("twilio")
		{
			s := s.GetPhoneNumberTwilioResponseModel
			{
				if s.AssignedAgent.Set {
					e.FieldStart("assigned_agent")
					s.AssignedAgent.Encode(e)
				}
			}
			{
				e.FieldStart("label")
				e.Str(s.Label)
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				if s.SupportsInbound.Set {
					e.FieldStart("supports_inbound")
					s.SupportsInbound.Encode(e)
				}
			}
			{
				if s.SupportsOutbound.Set {
					e.FieldStart("supports_outbound")
					s.SupportsOutbound.Encode(e)
				}
			}
		}
	case GetPhoneNumberSIPTrunkResponseModelListPhoneNumbersRouteOKItem:
		e.FieldStart("provider")
		e.Str("sip_trunk")
		{
			s := s.GetPhoneNumberSIPTrunkResponseModel
			{
				if s.AssignedAgent.Set {
					e.FieldStart("assigned_agent")
					s.AssignedAgent.Encode(e)
				}
			}
			{
				if s.InboundTrunk.Set {
					e.FieldStart("inbound_trunk")
					s.InboundTrunk.Encode(e)
				}
			}
			{
				e.FieldStart("label")
				e.Str(s.Label)
			}
			{
				e.FieldStart("livekit_stack")
				s.LivekitStack.Encode(e)
			}
			{
				if s.OutboundTrunk.Set {
					e.FieldStart("outbound_trunk")
					s.OutboundTrunk.Encode(e)
				}
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				if s.ProviderConfig.Set {
					e.FieldStart("provider_config")
					s.ProviderConfig.Encode(e)
				}
			}
			{
				if s.SupportsInbound.Set {
					e.FieldStart("supports_inbound")
					s.SupportsInbound.Encode(e)
				}
			}
			{
				if s.SupportsOutbound.Set {
					e.FieldStart("supports_outbound")
					s.SupportsOutbound.Encode(e)
				}
			}
		}
	}
}

// Decode decodes ListPhoneNumbersRouteOKItem from json.
func (s *ListPhoneNumbersRouteOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPhoneNumbersRouteOKItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "provider":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "twilio":
					s.Type = GetPhoneNumberTwilioResponseModelListPhoneNumbersRouteOKItem
					found = true
				case "sip_trunk":
					s.Type = GetPhoneNumberSIPTrunkResponseModelListPhoneNumbersRouteOKItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetPhoneNumberTwilioResponseModelListPhoneNumbersRouteOKItem:
		if err := s.GetPhoneNumberTwilioResponseModel.Decode(d); err != nil {
			return err
		}
	case GetPhoneNumberSIPTrunkResponseModelListPhoneNumbersRouteOKItem:
		if err := s.GetPhoneNumberSIPTrunkResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPhoneNumbersRouteOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPhoneNumbersRouteOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListResponseMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListResponseMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfListResponseMeta = [3]string{
	0: "page",
	1: "page_size",
	2: "total",
}

// Decode decodes ListResponseMeta from json.
func (s *ListResponseMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListResponseMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListResponseMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTestsByIdsRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTestsByIdsRequestModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("test_ids")
		e.ArrStart()
		for _, elem := range s.TestIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListTestsByIdsRequestModel = [1]string{
	0: "test_ids",
}

// Decode decodes ListTestsByIdsRequestModel from json.
func (s *ListTestsByIdsRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTestsByIdsRequestModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "test_ids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.TestIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TestIds = append(s.TestIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTestsByIdsRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListTestsByIdsRequestModel) {
					name = jsonFieldsNameOfListTestsByIdsRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTestsByIdsRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTestsByIdsRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListWhatsAppAccountsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListWhatsAppAccountsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListWhatsAppAccountsResponse = [1]string{
	0: "items",
}

// Decode decodes ListWhatsAppAccountsResponse from json.
func (s *ListWhatsAppAccountsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListWhatsAppAccountsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]GetWhatsAppAccountResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetWhatsAppAccountResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListWhatsAppAccountsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListWhatsAppAccountsResponse) {
					name = jsonFieldsNameOfListWhatsAppAccountsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListWhatsAppAccountsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListWhatsAppAccountsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LiteralJsonSchemaProperty) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LiteralJsonSchemaProperty) encodeFields(e *jx.Encoder) {
	{
		if s.ConstantValue.Set {
			e.FieldStart("constant_value")
			s.ConstantValue.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DynamicVariable.Set {
			e.FieldStart("dynamic_variable")
			s.DynamicVariable.Encode(e)
		}
	}
	{
		if s.Enum.Set {
			e.FieldStart("enum")
			s.Enum.Encode(e)
		}
	}
	{
		if s.IsSystemProvided.Set {
			e.FieldStart("is_system_provided")
			s.IsSystemProvided.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfLiteralJsonSchemaProperty = [6]string{
	0: "constant_value",
	1: "description",
	2: "dynamic_variable",
	3: "enum",
	4: "is_system_provided",
	5: "type",
}

// Decode decodes LiteralJsonSchemaProperty from json.
func (s *LiteralJsonSchemaProperty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LiteralJsonSchemaProperty to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "constant_value":
			if err := func() error {
				s.ConstantValue.Reset()
				if err := s.ConstantValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"constant_value\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "dynamic_variable":
			if err := func() error {
				s.DynamicVariable.Reset()
				if err := s.DynamicVariable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variable\"")
			}
		case "enum":
			if err := func() error {
				s.Enum.Reset()
				if err := s.Enum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "is_system_provided":
			if err := func() error {
				s.IsSystemProvided.Reset()
				if err := s.IsSystemProvided.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_system_provided\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LiteralJsonSchemaProperty")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLiteralJsonSchemaProperty) {
					name = jsonFieldsNameOfLiteralJsonSchemaProperty[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LiteralJsonSchemaProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LiteralJsonSchemaProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiteralJsonSchemaPropertyConstantValue as json.
func (s LiteralJsonSchemaPropertyConstantValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringLiteralJsonSchemaPropertyConstantValue:
		e.Str(s.String)
	case IntLiteralJsonSchemaPropertyConstantValue:
		e.Int(s.Int)
	case Float64LiteralJsonSchemaPropertyConstantValue:
		e.Float64(s.Float64)
	case BoolLiteralJsonSchemaPropertyConstantValue:
		e.Bool(s.Bool)
	}
}

// Decode decodes LiteralJsonSchemaPropertyConstantValue from json.
func (s *LiteralJsonSchemaPropertyConstantValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LiteralJsonSchemaPropertyConstantValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolLiteralJsonSchemaPropertyConstantValue
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntLiteralJsonSchemaPropertyConstantValue
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64LiteralJsonSchemaPropertyConstantValue
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringLiteralJsonSchemaPropertyConstantValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LiteralJsonSchemaPropertyConstantValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LiteralJsonSchemaPropertyConstantValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiteralJsonSchemaPropertyType as json.
func (s LiteralJsonSchemaPropertyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LiteralJsonSchemaPropertyType from json.
func (s *LiteralJsonSchemaPropertyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LiteralJsonSchemaPropertyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LiteralJsonSchemaPropertyType(v) {
	case LiteralJsonSchemaPropertyTypeBoolean:
		*s = LiteralJsonSchemaPropertyTypeBoolean
	case LiteralJsonSchemaPropertyTypeString:
		*s = LiteralJsonSchemaPropertyTypeString
	case LiteralJsonSchemaPropertyTypeInteger:
		*s = LiteralJsonSchemaPropertyTypeInteger
	case LiteralJsonSchemaPropertyTypeNumber:
		*s = LiteralJsonSchemaPropertyTypeNumber
	default:
		*s = LiteralJsonSchemaPropertyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LiteralJsonSchemaPropertyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LiteralJsonSchemaPropertyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LivekitStackType as json.
func (s LivekitStackType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LivekitStackType from json.
func (s *LivekitStackType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LivekitStackType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LivekitStackType(v) {
	case LivekitStackTypeStandard:
		*s = LivekitStackTypeStandard
	case LivekitStackTypeStatic:
		*s = LivekitStackTypeStatic
	default:
		*s = LivekitStackType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LivekitStackType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LivekitStackType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MCPToolConfigOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MCPToolConfigOverride) encodeFields(e *jx.Encoder) {
	{
		if s.Assignments != nil {
			e.FieldStart("assignments")
			e.ArrStart()
			for _, elem := range s.Assignments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisableInterruptions.Set {
			e.FieldStart("disable_interruptions")
			s.DisableInterruptions.Encode(e)
		}
	}
	{
		if s.ExecutionMode.Set {
			e.FieldStart("execution_mode")
			s.ExecutionMode.Encode(e)
		}
	}
	{
		if s.ForcePreToolSpeech.Set {
			e.FieldStart("force_pre_tool_speech")
			s.ForcePreToolSpeech.Encode(e)
		}
	}
	{
		if s.ToolCallSound.Set {
			e.FieldStart("tool_call_sound")
			s.ToolCallSound.Encode(e)
		}
	}
	{
		if s.ToolCallSoundBehavior.Set {
			e.FieldStart("tool_call_sound_behavior")
			s.ToolCallSoundBehavior.Encode(e)
		}
	}
	{
		e.FieldStart("tool_name")
		e.Str(s.ToolName)
	}
}

var jsonFieldsNameOfMCPToolConfigOverride = [7]string{
	0: "assignments",
	1: "disable_interruptions",
	2: "execution_mode",
	3: "force_pre_tool_speech",
	4: "tool_call_sound",
	5: "tool_call_sound_behavior",
	6: "tool_name",
}

// Decode decodes MCPToolConfigOverride from json.
func (s *MCPToolConfigOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MCPToolConfigOverride to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assignments":
			if err := func() error {
				s.Assignments = make([]DynamicVariableAssignment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DynamicVariableAssignment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assignments = append(s.Assignments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignments\"")
			}
		case "disable_interruptions":
			if err := func() error {
				s.DisableInterruptions.Reset()
				if err := s.DisableInterruptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_interruptions\"")
			}
		case "execution_mode":
			if err := func() error {
				s.ExecutionMode.Reset()
				if err := s.ExecutionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execution_mode\"")
			}
		case "force_pre_tool_speech":
			if err := func() error {
				s.ForcePreToolSpeech.Reset()
				if err := s.ForcePreToolSpeech.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force_pre_tool_speech\"")
			}
		case "tool_call_sound":
			if err := func() error {
				s.ToolCallSound.Reset()
				if err := s.ToolCallSound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_sound\"")
			}
		case "tool_call_sound_behavior":
			if err := func() error {
				s.ToolCallSoundBehavior.Reset()
				if err := s.ToolCallSoundBehavior.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_sound_behavior\"")
			}
		case "tool_name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ToolName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MCPToolConfigOverride")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMCPToolConfigOverride) {
					name = jsonFieldsNameOfMCPToolConfigOverride[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MCPToolConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MCPToolConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManualVerificationFileResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManualVerificationFileResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("file_id")
		e.Str(s.FileID)
	}
	{
		e.FieldStart("file_name")
		e.Str(s.FileName)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		e.FieldStart("size_bytes")
		e.Int(s.SizeBytes)
	}
	{
		e.FieldStart("upload_date_unix")
		e.Int(s.UploadDateUnix)
	}
}

var jsonFieldsNameOfManualVerificationFileResponseModel = [5]string{
	0: "file_id",
	1: "file_name",
	2: "mime_type",
	3: "size_bytes",
	4: "upload_date_unix",
}

// Decode decodes ManualVerificationFileResponseModel from json.
func (s *ManualVerificationFileResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManualVerificationFileResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "file_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FileID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_id\"")
			}
		case "file_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "size_bytes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.SizeBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_bytes\"")
			}
		case "upload_date_unix":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.UploadDateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_date_unix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManualVerificationFileResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfManualVerificationFileResponseModel) {
					name = jsonFieldsNameOfManualVerificationFileResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManualVerificationFileResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManualVerificationFileResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ManualVerificationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ManualVerificationResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("extra_text")
		e.Str(s.ExtraText)
	}
	{
		e.FieldStart("files")
		e.ArrStart()
		for _, elem := range s.Files {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("request_time_unix")
		e.Int(s.RequestTimeUnix)
	}
}

var jsonFieldsNameOfManualVerificationResponseModel = [3]string{
	0: "extra_text",
	1: "files",
	2: "request_time_unix",
}

// Decode decodes ManualVerificationResponseModel from json.
func (s *ManualVerificationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ManualVerificationResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "extra_text":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ExtraText = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extra_text\"")
			}
		case "files":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Files = make([]ManualVerificationFileResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ManualVerificationFileResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "request_time_unix":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RequestTimeUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_time_unix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ManualVerificationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfManualVerificationResponseModel) {
					name = jsonFieldsNameOfManualVerificationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ManualVerificationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ManualVerificationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MatchAnythingParameterEvaluationStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MatchAnythingParameterEvaluationStrategy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfMatchAnythingParameterEvaluationStrategy = [1]string{
	0: "type",
}

// Decode decodes MatchAnythingParameterEvaluationStrategy from json.
func (s *MatchAnythingParameterEvaluationStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchAnythingParameterEvaluationStrategy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MatchAnythingParameterEvaluationStrategy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMatchAnythingParameterEvaluationStrategy) {
					name = jsonFieldsNameOfMatchAnythingParameterEvaluationStrategy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MatchAnythingParameterEvaluationStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchAnythingParameterEvaluationStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MatchAnythingParameterEvaluationStrategyType as json.
func (s MatchAnythingParameterEvaluationStrategyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MatchAnythingParameterEvaluationStrategyType from json.
func (s *MatchAnythingParameterEvaluationStrategyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MatchAnythingParameterEvaluationStrategyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MatchAnythingParameterEvaluationStrategyType(v) {
	case MatchAnythingParameterEvaluationStrategyTypeAnything:
		*s = MatchAnythingParameterEvaluationStrategyTypeAnything
	default:
		*s = MatchAnythingParameterEvaluationStrategyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MatchAnythingParameterEvaluationStrategyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MatchAnythingParameterEvaluationStrategyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetricRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetricRecord) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("elapsed_time")
		e.Float64(s.ElapsedTime)
	}
}

var jsonFieldsNameOfMetricRecord = [1]string{
	0: "elapsed_time",
}

// Decode decodes MetricRecord from json.
func (s *MetricRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetricRecord to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elapsed_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ElapsedTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elapsed_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetricRecord")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMetricRecord) {
					name = jsonFieldsNameOfMetricRecord[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetricRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetricRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelRatesResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelRatesResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_cost_multiplier")
		e.Float64(s.CharacterCostMultiplier)
	}
}

var jsonFieldsNameOfModelRatesResponseModel = [1]string{
	0: "character_cost_multiplier",
}

// Decode decodes ModelRatesResponseModel from json.
func (s *ModelRatesResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelRatesResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_cost_multiplier":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.CharacterCostMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_cost_multiplier\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelRatesResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfModelRatesResponseModel) {
					name = jsonFieldsNameOfModelRatesResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelRatesResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelRatesResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("can_be_finetuned")
		e.Bool(s.CanBeFinetuned)
	}
	{
		e.FieldStart("can_do_text_to_speech")
		e.Bool(s.CanDoTextToSpeech)
	}
	{
		e.FieldStart("can_do_voice_conversion")
		e.Bool(s.CanDoVoiceConversion)
	}
	{
		e.FieldStart("can_use_speaker_boost")
		e.Bool(s.CanUseSpeakerBoost)
	}
	{
		e.FieldStart("can_use_style")
		e.Bool(s.CanUseStyle)
	}
	{
		e.FieldStart("concurrency_group")
		e.Str(s.ConcurrencyGroup)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("languages")
		e.ArrStart()
		for _, elem := range s.Languages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("max_characters_request_free_user")
		e.Int(s.MaxCharactersRequestFreeUser)
	}
	{
		e.FieldStart("max_characters_request_subscribed_user")
		e.Int(s.MaxCharactersRequestSubscribedUser)
	}
	{
		e.FieldStart("maximum_text_length_per_request")
		e.Int(s.MaximumTextLengthPerRequest)
	}
	{
		e.FieldStart("model_id")
		e.Str(s.ModelID)
	}
	{
		e.FieldStart("model_rates")
		s.ModelRates.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("requires_alpha_access")
		e.Bool(s.RequiresAlphaAccess)
	}
	{
		e.FieldStart("serves_pro_voices")
		e.Bool(s.ServesProVoices)
	}
	{
		e.FieldStart("token_cost_factor")
		e.Float64(s.TokenCostFactor)
	}
}

var jsonFieldsNameOfModelResponseModel = [17]string{
	0:  "can_be_finetuned",
	1:  "can_do_text_to_speech",
	2:  "can_do_voice_conversion",
	3:  "can_use_speaker_boost",
	4:  "can_use_style",
	5:  "concurrency_group",
	6:  "description",
	7:  "languages",
	8:  "max_characters_request_free_user",
	9:  "max_characters_request_subscribed_user",
	10: "maximum_text_length_per_request",
	11: "model_id",
	12: "model_rates",
	13: "name",
	14: "requires_alpha_access",
	15: "serves_pro_voices",
	16: "token_cost_factor",
}

// Decode decodes ModelResponseModel from json.
func (s *ModelResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelResponseModel to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_be_finetuned":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanBeFinetuned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_be_finetuned\"")
			}
		case "can_do_text_to_speech":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.CanDoTextToSpeech = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_do_text_to_speech\"")
			}
		case "can_do_voice_conversion":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanDoVoiceConversion = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_do_voice_conversion\"")
			}
		case "can_use_speaker_boost":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanUseSpeakerBoost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_speaker_boost\"")
			}
		case "can_use_style":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanUseStyle = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_style\"")
			}
		case "concurrency_group":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ConcurrencyGroup = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"concurrency_group\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "languages":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Languages = make([]LanguageResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LanguageResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Languages = append(s.Languages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"languages\"")
			}
		case "max_characters_request_free_user":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MaxCharactersRequestFreeUser = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_characters_request_free_user\"")
			}
		case "max_characters_request_subscribed_user":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.MaxCharactersRequestSubscribedUser = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_characters_request_subscribed_user\"")
			}
		case "maximum_text_length_per_request":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.MaximumTextLengthPerRequest = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_text_length_per_request\"")
			}
		case "model_id":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ModelID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "model_rates":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.ModelRates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_rates\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "requires_alpha_access":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.RequiresAlphaAccess = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_alpha_access\"")
			}
		case "serves_pro_voices":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.ServesProVoices = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serves_pro_voices\"")
			}
		case "token_cost_factor":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TokenCostFactor = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_cost_factor\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfModelResponseModel) {
					name = jsonFieldsNameOfModelResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModelSettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModelSettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Stability.Set {
			e.FieldStart("stability")
			s.Stability.Encode(e)
		}
	}
}

var jsonFieldsNameOfModelSettingsResponseModel = [1]string{
	0: "stability",
}

// Decode decodes ModelSettingsResponseModel from json.
func (s *ModelSettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModelSettingsResponseModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "stability":
			if err := func() error {
				s.Stability.Reset()
				if err := s.Stability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModelSettingsResponseModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModelSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModelSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MultichannelSpeechToTextResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MultichannelSpeechToTextResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.TranscriptionID.Set {
			e.FieldStart("transcription_id")
			s.TranscriptionID.Encode(e)
		}
	}
	{
		e.FieldStart("transcripts")
		e.ArrStart()
		for _, elem := range s.Transcripts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMultichannelSpeechToTextResponseModel = [2]string{
	0: "transcription_id",
	1: "transcripts",
}

// Decode decodes MultichannelSpeechToTextResponseModel from json.
func (s *MultichannelSpeechToTextResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MultichannelSpeechToTextResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "transcription_id":
			if err := func() error {
				s.TranscriptionID.Reset()
				if err := s.TranscriptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_id\"")
			}
		case "transcripts":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Transcripts = make([]SpeechToTextChunkResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpeechToTextChunkResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Transcripts = append(s.Transcripts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcripts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MultichannelSpeechToTextResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMultichannelSpeechToTextResponseModel) {
					name = jsonFieldsNameOfMultichannelSpeechToTextResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MultichannelSpeechToTextResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MultichannelSpeechToTextResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MusicPrompt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MusicPrompt) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("negative_global_styles")
		e.ArrStart()
		for _, elem := range s.NegativeGlobalStyles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("positive_global_styles")
		e.ArrStart()
		for _, elem := range s.PositiveGlobalStyles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("sections")
		e.ArrStart()
		for _, elem := range s.Sections {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfMusicPrompt = [3]string{
	0: "negative_global_styles",
	1: "positive_global_styles",
	2: "sections",
}

// Decode decodes MusicPrompt from json.
func (s *MusicPrompt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MusicPrompt to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "negative_global_styles":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NegativeGlobalStyles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NegativeGlobalStyles = append(s.NegativeGlobalStyles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"negative_global_styles\"")
			}
		case "positive_global_styles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.PositiveGlobalStyles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PositiveGlobalStyles = append(s.PositiveGlobalStyles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positive_global_styles\"")
			}
		case "sections":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Sections = make([]SongSection, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SongSection
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sections = append(s.Sections, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sections\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MusicPrompt")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMusicPrompt) {
					name = jsonFieldsNameOfMusicPrompt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MusicPrompt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MusicPrompt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddPronunciationDictionaryResponseModelPermissionOnResource as json.
func (o NilAddPronunciationDictionaryResponseModelPermissionOnResource) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AddPronunciationDictionaryResponseModelPermissionOnResource from json.
func (o *NilAddPronunciationDictionaryResponseModelPermissionOnResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilAddPronunciationDictionaryResponseModelPermissionOnResource to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AddPronunciationDictionaryResponseModelPermissionOnResource
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilAddPronunciationDictionaryResponseModelPermissionOnResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilAddPronunciationDictionaryResponseModelPermissionOnResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataInternalDynamicVariablesItem as json.
func (o NilConversationInitiationClientDataInternalDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataInternalDynamicVariablesItem from json.
func (o *NilConversationInitiationClientDataInternalDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilConversationInitiationClientDataInternalDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationInitiationClientDataInternalDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilConversationInitiationClientDataInternalDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilConversationInitiationClientDataInternalDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestInputDynamicVariablesItem as json.
func (o NilConversationInitiationClientDataRequestInputDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataRequestInputDynamicVariablesItem from json.
func (o *NilConversationInitiationClientDataRequestInputDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilConversationInitiationClientDataRequestInputDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationInitiationClientDataRequestInputDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilConversationInitiationClientDataRequestInputDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilConversationInitiationClientDataRequestInputDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestOutputDynamicVariablesItem as json.
func (o NilConversationInitiationClientDataRequestOutputDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataRequestOutputDynamicVariablesItem from json.
func (o *NilConversationInitiationClientDataRequestOutputDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilConversationInitiationClientDataRequestOutputDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationInitiationClientDataRequestOutputDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilConversationInitiationClientDataRequestOutputDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilConversationInitiationClientDataRequestOutputDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUnitTestRequestDynamicVariablesItem as json.
func (o NilCreateUnitTestRequestDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateUnitTestRequestDynamicVariablesItem from json.
func (o *NilCreateUnitTestRequestDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCreateUnitTestRequestDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateUnitTestRequestDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCreateUnitTestRequestDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCreateUnitTestRequestDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPronunciationDictionaryMetadataResponseModelPermissionOnResource as json.
func (o NilGetPronunciationDictionaryMetadataResponseModelPermissionOnResource) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetPronunciationDictionaryMetadataResponseModelPermissionOnResource from json.
func (o *NilGetPronunciationDictionaryMetadataResponseModelPermissionOnResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetPronunciationDictionaryMetadataResponseModelPermissionOnResource to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetPronunciationDictionaryMetadataResponseModelPermissionOnResource
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetPronunciationDictionaryMetadataResponseModelPermissionOnResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetPronunciationDictionaryMetadataResponseModelPermissionOnResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUnitTestResponseModelDynamicVariablesItem as json.
func (o NilGetUnitTestResponseModelDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUnitTestResponseModelDynamicVariablesItem from json.
func (o *NilGetUnitTestResponseModelDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUnitTestResponseModelDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUnitTestResponseModelDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUnitTestResponseModelDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUnitTestResponseModelDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceMetadataResponseModelAnonymousAccessLevelOverride as json.
func (o NilResourceMetadataResponseModelAnonymousAccessLevelOverride) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResourceMetadataResponseModelAnonymousAccessLevelOverride from json.
func (o *NilResourceMetadataResponseModelAnonymousAccessLevelOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilResourceMetadataResponseModelAnonymousAccessLevelOverride to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ResourceMetadataResponseModelAnonymousAccessLevelOverride
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilResourceMetadataResponseModelAnonymousAccessLevelOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilResourceMetadataResponseModelAnonymousAccessLevelOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestCommonModelDynamicVariablesItem as json.
func (o NilUnitTestCommonModelDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UnitTestCommonModelDynamicVariablesItem from json.
func (o *NilUnitTestCommonModelDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUnitTestCommonModelDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UnitTestCommonModelDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUnitTestCommonModelDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUnitTestCommonModelDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUnitTestRequestDynamicVariablesItem as json.
func (o NilUpdateUnitTestRequestDynamicVariablesItem) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateUnitTestRequestDynamicVariablesItem from json.
func (o *NilUpdateUnitTestRequestDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateUnitTestRequestDynamicVariablesItem to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateUnitTestRequestDynamicVariablesItem
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateUnitTestRequestDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateUnitTestRequestDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentConfigOverrideInput as json.
func (o OptAgentConfigOverrideInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AgentConfigOverrideInput from json.
func (o *OptAgentConfigOverrideInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAgentConfigOverrideInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAgentConfigOverrideInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAgentConfigOverrideInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentConfigOverrideOutput as json.
func (o OptAgentConfigOverrideOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AgentConfigOverrideOutput from json.
func (o *OptAgentConfigOverrideOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAgentConfigOverrideOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAgentConfigOverrideOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAgentConfigOverrideOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentDefinitionSource as json.
func (o OptAgentDefinitionSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AgentDefinitionSource from json.
func (o *OptAgentDefinitionSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAgentDefinitionSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAgentDefinitionSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAgentDefinitionSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AgentMetadata as json.
func (o OptAgentMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AgentMetadata from json.
func (o *OptAgentMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAgentMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAgentMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAgentMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AsyncConversationMetadata as json.
func (o OptAsyncConversationMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AsyncConversationMetadata from json.
func (o *OptAsyncConversationMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAsyncConversationMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAsyncConversationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAsyncConversationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AudioNativeProjectSettingsResponseModel as json.
func (o OptAudioNativeProjectSettingsResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AudioNativeProjectSettingsResponseModel from json.
func (o *OptAudioNativeProjectSettingsResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAudioNativeProjectSettingsResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAudioNativeProjectSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAudioNativeProjectSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AudioNativeProjectSettingsResponseModelStatus as json.
func (o OptAudioNativeProjectSettingsResponseModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AudioNativeProjectSettingsResponseModelStatus from json.
func (o *OptAudioNativeProjectSettingsResponseModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAudioNativeProjectSettingsResponseModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAudioNativeProjectSettingsResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAudioNativeProjectSettingsResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthorizationMethod as json.
func (o OptAuthorizationMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AuthorizationMethod from json.
func (o *OptAuthorizationMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAuthorizationMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAuthorizationMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAuthorizationMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BatchCallWhatsAppParams as json.
func (o OptBatchCallWhatsAppParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BatchCallWhatsAppParams from json.
func (o *OptBatchCallWhatsAppParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBatchCallWhatsAppParams to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBatchCallWhatsAppParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBatchCallWhatsAppParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BillingPeriod as json.
func (o OptBillingPeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BillingPeriod from json.
func (o *OptBillingPeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBillingPeriod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBillingPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBillingPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyComposeMusicV1MusicPost as json.
func (o OptBodyComposeMusicV1MusicPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyComposeMusicV1MusicPost from json.
func (o *OptBodyComposeMusicV1MusicPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyComposeMusicV1MusicPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyComposeMusicV1MusicPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyComposeMusicV1MusicPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyComposeMusicV1MusicPostModelID as json.
func (o OptBodyComposeMusicV1MusicPostModelID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyComposeMusicV1MusicPostModelID from json.
func (o *OptBodyComposeMusicV1MusicPostModelID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyComposeMusicV1MusicPostModelID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyComposeMusicV1MusicPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyComposeMusicV1MusicPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPost as json.
func (o OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPost from json.
func (o *OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID as json.
func (o OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID from json.
func (o *OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost as json.
func (o OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost from json.
func (o *OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost as json.
func (o OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost from json.
func (o *OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyEditPVCVoiceV1VoicesPvcVoiceIDPost as json.
func (o OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyEditPVCVoiceV1VoicesPvcVoiceIDPost from json.
func (o *OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyGenerateCompositionPlanV1MusicPlanPostModelID as json.
func (o OptBodyGenerateCompositionPlanV1MusicPlanPostModelID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyGenerateCompositionPlanV1MusicPlanPostModelID from json.
func (o *OptBodyGenerateCompositionPlanV1MusicPlanPostModelID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyGenerateCompositionPlanV1MusicPlanPostModelID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyGenerateCompositionPlanV1MusicPlanPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyGenerateCompositionPlanV1MusicPlanPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection as json.
func (o OptBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection from json.
func (o *OptBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPostDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost as json.
func (o OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost from json.
func (o *OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost as json.
func (o OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost from json.
func (o *OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyStreamComposedMusicV1MusicStreamPost as json.
func (o OptBodyStreamComposedMusicV1MusicStreamPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyStreamComposedMusicV1MusicStreamPost from json.
func (o *OptBodyStreamComposedMusicV1MusicStreamPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyStreamComposedMusicV1MusicStreamPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyStreamComposedMusicV1MusicStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyStreamComposedMusicV1MusicStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyStreamComposedMusicV1MusicStreamPostModelID as json.
func (o OptBodyStreamComposedMusicV1MusicStreamPostModelID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyStreamComposedMusicV1MusicStreamPostModelID from json.
func (o *OptBodyStreamComposedMusicV1MusicStreamPostModelID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyStreamComposedMusicV1MusicStreamPostModelID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyStreamComposedMusicV1MusicStreamPostModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyStreamComposedMusicV1MusicStreamPostModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost as json.
func (o OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost from json.
func (o *OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueFullWithTimestampsApplyTextNormalization as json.
func (o OptBodyTextToDialogueFullWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToDialogueFullWithTimestampsApplyTextNormalization from json.
func (o *OptBodyTextToDialogueFullWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToDialogueFullWithTimestampsApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToDialogueFullWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToDialogueFullWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization as json.
func (o OptBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization from json.
func (o *OptBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization as json.
func (o OptBodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization from json.
func (o *OptBodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToDialogueMultiVoiceV1TextToDialoguePostApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToDialogueStreamWithTimestampsApplyTextNormalization as json.
func (o OptBodyTextToDialogueStreamWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToDialogueStreamWithTimestampsApplyTextNormalization from json.
func (o *OptBodyTextToDialogueStreamWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToDialogueStreamWithTimestampsApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToDialogueStreamWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToDialogueStreamWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechFullApplyTextNormalization as json.
func (o OptBodyTextToSpeechFullApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToSpeechFullApplyTextNormalization from json.
func (o *OptBodyTextToSpeechFullApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToSpeechFullApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToSpeechFullApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToSpeechFullApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechFullWithTimestampsApplyTextNormalization as json.
func (o OptBodyTextToSpeechFullWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToSpeechFullWithTimestampsApplyTextNormalization from json.
func (o *OptBodyTextToSpeechFullWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToSpeechFullWithTimestampsApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToSpeechFullWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToSpeechFullWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechStreamApplyTextNormalization as json.
func (o OptBodyTextToSpeechStreamApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToSpeechStreamApplyTextNormalization from json.
func (o *OptBodyTextToSpeechStreamApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToSpeechStreamApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToSpeechStreamApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToSpeechStreamApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyTextToSpeechStreamWithTimestampsApplyTextNormalization as json.
func (o OptBodyTextToSpeechStreamWithTimestampsApplyTextNormalization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyTextToSpeechStreamWithTimestampsApplyTextNormalization from json.
func (o *OptBodyTextToSpeechStreamWithTimestampsApplyTextNormalization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyTextToSpeechStreamWithTimestampsApplyTextNormalization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyTextToSpeechStreamWithTimestampsApplyTextNormalization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyTextToSpeechStreamWithTimestampsApplyTextNormalization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch as json.
func (o OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch from json.
func (o *OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost as json.
func (o OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost from json.
func (o *OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch as json.
func (o OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch from json.
func (o *OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleCharacterAnimationModel as json.
func (o OptCaptionStyleCharacterAnimationModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleCharacterAnimationModel from json.
func (o *OptCaptionStyleCharacterAnimationModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleCharacterAnimationModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleCharacterAnimationModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleCharacterAnimationModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleHorizontalPlacementModel as json.
func (o OptCaptionStyleHorizontalPlacementModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleHorizontalPlacementModel from json.
func (o *OptCaptionStyleHorizontalPlacementModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleHorizontalPlacementModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleHorizontalPlacementModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleHorizontalPlacementModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModel as json.
func (o OptCaptionStyleModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleModel from json.
func (o *OptCaptionStyleModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleSectionAnimationModel as json.
func (o OptCaptionStyleSectionAnimationModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleSectionAnimationModel from json.
func (o *OptCaptionStyleSectionAnimationModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleSectionAnimationModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleSectionAnimationModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleSectionAnimationModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleTemplateModel as json.
func (o OptCaptionStyleTemplateModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleTemplateModel from json.
func (o *OptCaptionStyleTemplateModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleTemplateModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleTemplateModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleTemplateModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleVerticalPlacementModel as json.
func (o OptCaptionStyleVerticalPlacementModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleVerticalPlacementModel from json.
func (o *OptCaptionStyleVerticalPlacementModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleVerticalPlacementModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleVerticalPlacementModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleVerticalPlacementModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleWordAnimationModel as json.
func (o OptCaptionStyleWordAnimationModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CaptionStyleWordAnimationModel from json.
func (o *OptCaptionStyleWordAnimationModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCaptionStyleWordAnimationModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCaptionStyleWordAnimationModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCaptionStyleWordAnimationModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChapterStatisticsResponseModel as json.
func (o OptChapterStatisticsResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChapterStatisticsResponseModel from json.
func (o *OptChapterStatisticsResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChapterStatisticsResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChapterStatisticsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChapterStatisticsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterAlignmentResponseModel as json.
func (o OptCharacterAlignmentResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CharacterAlignmentResponseModel from json.
func (o *OptCharacterAlignmentResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterAlignmentResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterAlignmentResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterAlignmentResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CharacterRefreshPeriod as json.
func (o OptCharacterRefreshPeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CharacterRefreshPeriod from json.
func (o *OptCharacterRefreshPeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCharacterRefreshPeriod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCharacterRefreshPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCharacterRefreshPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConvAIWebhooks as json.
func (o OptConvAIWebhooks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConvAIWebhooks from json.
func (o *OptConvAIWebhooks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConvAIWebhooks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConvAIWebhooks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConvAIWebhooks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationChargingCommonModel as json.
func (o OptConversationChargingCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationChargingCommonModel from json.
func (o *OptConversationChargingCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationChargingCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationChargingCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationChargingCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationConfigClientOverrideInput as json.
func (o OptConversationConfigClientOverrideInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationConfigClientOverrideInput from json.
func (o *OptConversationConfigClientOverrideInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationConfigClientOverrideInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationConfigClientOverrideInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationConfigClientOverrideInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationConfigClientOverrideOutput as json.
func (o OptConversationConfigClientOverrideOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationConfigClientOverrideOutput from json.
func (o *OptConversationConfigClientOverrideOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationConfigClientOverrideOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationConfigClientOverrideOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationConfigClientOverrideOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationConfigOverride as json.
func (o OptConversationConfigOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationConfigOverride from json.
func (o *OptConversationConfigOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationConfigOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationDeletionSettings as json.
func (o OptConversationDeletionSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationDeletionSettings from json.
func (o *OptConversationDeletionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationDeletionSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationDeletionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationDeletionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationFeedbackType as json.
func (o OptConversationFeedbackType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationFeedbackType from json.
func (o *OptConversationFeedbackType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationFeedbackType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationFeedbackType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationFeedbackType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryAnalysisCommonModel as json.
func (o OptConversationHistoryAnalysisCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryAnalysisCommonModel from json.
func (o *OptConversationHistoryAnalysisCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryAnalysisCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryAnalysisCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryAnalysisCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryAnalysisCommonModelDataCollectionResults as json.
func (o OptConversationHistoryAnalysisCommonModelDataCollectionResults) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryAnalysisCommonModelDataCollectionResults from json.
func (o *OptConversationHistoryAnalysisCommonModelDataCollectionResults) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryAnalysisCommonModelDataCollectionResults to nil")
	}
	o.Set = true
	o.Value = make(ConversationHistoryAnalysisCommonModelDataCollectionResults)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryAnalysisCommonModelDataCollectionResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryAnalysisCommonModelDataCollectionResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults as json.
func (o OptConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults from json.
func (o *OptConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryAnalysisCommonModelEvaluationCriteriaResults to nil")
	}
	o.Set = true
	o.Value = make(ConversationHistoryAnalysisCommonModelEvaluationCriteriaResults)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryAnalysisCommonModelEvaluationCriteriaResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryBatchCallModel as json.
func (o OptConversationHistoryBatchCallModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryBatchCallModel from json.
func (o *OptConversationHistoryBatchCallModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryBatchCallModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryBatchCallModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryBatchCallModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryElevenAssistantCommonModel as json.
func (o OptConversationHistoryElevenAssistantCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryElevenAssistantCommonModel from json.
func (o *OptConversationHistoryElevenAssistantCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryElevenAssistantCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryElevenAssistantCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryElevenAssistantCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryErrorCommonModel as json.
func (o OptConversationHistoryErrorCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryErrorCommonModel from json.
func (o *OptConversationHistoryErrorCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryErrorCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryErrorCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryErrorCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryFeedbackCommonModel as json.
func (o OptConversationHistoryFeedbackCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryFeedbackCommonModel from json.
func (o *OptConversationHistoryFeedbackCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryFeedbackCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryFeedbackCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryFeedbackCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryMetadataCommonModelInitiationTrigger as json.
func (o OptConversationHistoryMetadataCommonModelInitiationTrigger) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryMetadataCommonModelInitiationTrigger from json.
func (o *OptConversationHistoryMetadataCommonModelInitiationTrigger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryMetadataCommonModelInitiationTrigger to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryMetadataCommonModelInitiationTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryMetadataCommonModelInitiationTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryMultivoiceMessageModel as json.
func (o OptConversationHistoryMultivoiceMessageModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryMultivoiceMessageModel from json.
func (o *OptConversationHistoryMultivoiceMessageModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryMultivoiceMessageModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryMultivoiceMessageModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryMultivoiceMessageModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryRagUsageCommonModel as json.
func (o OptConversationHistoryRagUsageCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryRagUsageCommonModel from json.
func (o *OptConversationHistoryRagUsageCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryRagUsageCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryRagUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryRagUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType as json.
func (o OptConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType from json.
func (o *OptConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallApiIntegrationWebhookDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallClientDetailsType as json.
func (o OptConversationHistoryTranscriptToolCallClientDetailsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptToolCallClientDetailsType from json.
func (o *OptConversationHistoryTranscriptToolCallClientDetailsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallClientDetailsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallClientDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallClientDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallMCPDetailsParameters as json.
func (o OptConversationHistoryTranscriptToolCallMCPDetailsParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptToolCallMCPDetailsParameters from json.
func (o *OptConversationHistoryTranscriptToolCallMCPDetailsParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallMCPDetailsParameters to nil")
	}
	o.Set = true
	o.Value = make(ConversationHistoryTranscriptToolCallMCPDetailsParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallMCPDetailsParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallMCPDetailsParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallMCPDetailsType as json.
func (o OptConversationHistoryTranscriptToolCallMCPDetailsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptToolCallMCPDetailsType from json.
func (o *OptConversationHistoryTranscriptToolCallMCPDetailsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallMCPDetailsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallMCPDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallMCPDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallWebhookDetailsHeaders as json.
func (o OptConversationHistoryTranscriptToolCallWebhookDetailsHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsHeaders from json.
func (o *OptConversationHistoryTranscriptToolCallWebhookDetailsHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallWebhookDetailsHeaders to nil")
	}
	o.Set = true
	o.Value = make(ConversationHistoryTranscriptToolCallWebhookDetailsHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallWebhookDetailsHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallWebhookDetailsHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallWebhookDetailsPathParams as json.
func (o OptConversationHistoryTranscriptToolCallWebhookDetailsPathParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsPathParams from json.
func (o *OptConversationHistoryTranscriptToolCallWebhookDetailsPathParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallWebhookDetailsPathParams to nil")
	}
	o.Set = true
	o.Value = make(ConversationHistoryTranscriptToolCallWebhookDetailsPathParams)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallWebhookDetailsPathParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallWebhookDetailsPathParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams as json.
func (o OptConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams from json.
func (o *OptConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallWebhookDetailsQueryParams to nil")
	}
	o.Set = true
	o.Value = make(ConversationHistoryTranscriptToolCallWebhookDetailsQueryParams)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallWebhookDetailsQueryParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallWebhookDetailsType as json.
func (o OptConversationHistoryTranscriptToolCallWebhookDetailsType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptToolCallWebhookDetailsType from json.
func (o *OptConversationHistoryTranscriptToolCallWebhookDetailsType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationHistoryTranscriptToolCallWebhookDetailsType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationHistoryTranscriptToolCallWebhookDetailsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationHistoryTranscriptToolCallWebhookDetailsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataInternal as json.
func (o OptConversationInitiationClientDataInternal) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataInternal from json.
func (o *OptConversationInitiationClientDataInternal) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataInternal to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataInternal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataInternal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataInternalDynamicVariables as json.
func (o OptConversationInitiationClientDataInternalDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataInternalDynamicVariables from json.
func (o *OptConversationInitiationClientDataInternalDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataInternalDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(ConversationInitiationClientDataInternalDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataInternalDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataInternalDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestInput as json.
func (o OptConversationInitiationClientDataRequestInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataRequestInput from json.
func (o *OptConversationInitiationClientDataRequestInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataRequestInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataRequestInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataRequestInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestInputDynamicVariables as json.
func (o OptConversationInitiationClientDataRequestInputDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataRequestInputDynamicVariables from json.
func (o *OptConversationInitiationClientDataRequestInputDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataRequestInputDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(ConversationInitiationClientDataRequestInputDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataRequestInputDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataRequestInputDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestOutput as json.
func (o OptConversationInitiationClientDataRequestOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataRequestOutput from json.
func (o *OptConversationInitiationClientDataRequestOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataRequestOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataRequestOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataRequestOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataRequestOutputDynamicVariables as json.
func (o OptConversationInitiationClientDataRequestOutputDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataRequestOutputDynamicVariables from json.
func (o *OptConversationInitiationClientDataRequestOutputDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataRequestOutputDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(ConversationInitiationClientDataRequestOutputDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataRequestOutputDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataRequestOutputDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationClientDataWebhook as json.
func (o OptConversationInitiationClientDataWebhook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationClientDataWebhook from json.
func (o *OptConversationInitiationClientDataWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationClientDataWebhook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationClientDataWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationClientDataWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationSource as json.
func (o OptConversationInitiationSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationInitiationSource from json.
func (o *OptConversationInitiationSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationInitiationSourceInfo as json.
func (o OptConversationInitiationSourceInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationInitiationSourceInfo from json.
func (o *OptConversationInitiationSourceInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationInitiationSourceInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationInitiationSourceInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationInitiationSourceInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationTokenDBModel as json.
func (o OptConversationTokenDBModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationTokenDBModel from json.
func (o *OptConversationTokenDBModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationTokenDBModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationTokenDBModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationTokenDBModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationTokenPurpose as json.
func (o OptConversationTokenPurpose) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationTokenPurpose from json.
func (o *OptConversationTokenPurpose) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationTokenPurpose to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationTokenPurpose) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationTokenPurpose) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationTurnMetrics as json.
func (o OptConversationTurnMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationTurnMetrics from json.
func (o *OptConversationTurnMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationTurnMetrics to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationTurnMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationTurnMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationTurnMetricsMetrics as json.
func (o OptConversationTurnMetricsMetrics) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationTurnMetricsMetrics from json.
func (o *OptConversationTurnMetricsMetrics) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConversationTurnMetricsMetrics to nil")
	}
	o.Set = true
	o.Value = make(ConversationTurnMetricsMetrics)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConversationTurnMetricsMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConversationTurnMetricsMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUnitTestRequestDynamicVariables as json.
func (o OptCreateUnitTestRequestDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateUnitTestRequestDynamicVariables from json.
func (o *OptCreateUnitTestRequestDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUnitTestRequestDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(CreateUnitTestRequestDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUnitTestRequestDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUnitTestRequestDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardCallSuccessChartModelType as json.
func (o OptDashboardCallSuccessChartModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DashboardCallSuccessChartModelType from json.
func (o *OptDashboardCallSuccessChartModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDashboardCallSuccessChartModelType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDashboardCallSuccessChartModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDashboardCallSuccessChartModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardCriteriaChartModelType as json.
func (o OptDashboardCriteriaChartModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DashboardCriteriaChartModelType from json.
func (o *OptDashboardCriteriaChartModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDashboardCriteriaChartModelType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDashboardCriteriaChartModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDashboardCriteriaChartModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DashboardDataCollectionChartModelType as json.
func (o OptDashboardDataCollectionChartModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DashboardDataCollectionChartModelType from json.
func (o *OptDashboardDataCollectionChartModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDashboardDataCollectionChartModelType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDashboardDataCollectionChartModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDashboardDataCollectionChartModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefaultConversationInitiationTriggerTriggerType as json.
func (o OptDefaultConversationInitiationTriggerTriggerType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DefaultConversationInitiationTriggerTriggerType from json.
func (o *OptDefaultConversationInitiationTriggerTriggerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefaultConversationInitiationTriggerTriggerType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefaultConversationInitiationTriggerTriggerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefaultConversationInitiationTriggerTriggerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentAvailableAgentIdentifierType as json.
func (o OptDependentAvailableAgentIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DependentAvailableAgentIdentifierType from json.
func (o *OptDependentAvailableAgentIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDependentAvailableAgentIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDependentAvailableAgentIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDependentAvailableAgentIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentAvailableToolIdentifierType as json.
func (o OptDependentAvailableToolIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DependentAvailableToolIdentifierType from json.
func (o *OptDependentAvailableToolIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDependentAvailableToolIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDependentAvailableToolIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDependentAvailableToolIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentUnknownAgentIdentifierType as json.
func (o OptDependentUnknownAgentIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DependentUnknownAgentIdentifierType from json.
func (o *OptDependentUnknownAgentIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDependentUnknownAgentIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDependentUnknownAgentIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDependentUnknownAgentIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DependentUnknownToolIdentifierType as json.
func (o OptDependentUnknownToolIdentifierType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DependentUnknownToolIdentifierType from json.
func (o *OptDependentUnknownToolIdentifierType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDependentUnknownToolIdentifierType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDependentUnknownToolIdentifierType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDependentUnknownToolIdentifierType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DubbingMediaMetadata as json.
func (o OptDubbingMediaMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DubbingMediaMetadata from json.
func (o *OptDubbingMediaMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDubbingMediaMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDubbingMediaMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDubbingMediaMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DynamicVariableAssignmentSource as json.
func (o OptDynamicVariableAssignmentSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DynamicVariableAssignmentSource from json.
func (o *OptDynamicVariableAssignmentSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDynamicVariableAssignmentSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDynamicVariableAssignmentSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDynamicVariableAssignmentSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndCallToolResultModelResultType as json.
func (o OptEndCallToolResultModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EndCallToolResultModelResultType from json.
func (o *OptEndCallToolResultModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEndCallToolResultModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEndCallToolResultModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEndCallToolResultModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EndCallToolResultModelStatus as json.
func (o OptEndCallToolResultModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EndCallToolResultModelStatus from json.
func (o *OptEndCallToolResultModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEndCallToolResultModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEndCallToolResultModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEndCallToolResultModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeatureStatusCommonModel as json.
func (o OptFeatureStatusCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeatureStatusCommonModel from json.
func (o *OptFeatureStatusCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeatureStatusCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeatureStatusCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeatureStatusCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeaturesUsageCommonModel as json.
func (o OptFeaturesUsageCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeaturesUsageCommonModel from json.
func (o *OptFeaturesUsageCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeaturesUsageCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeaturesUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeaturesUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeedbackResponseModel as json.
func (o OptFeedbackResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeedbackResponseModel from json.
func (o *OptFeedbackResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeedbackResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeedbackResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeedbackResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningResponseModel as json.
func (o OptFineTuningResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FineTuningResponseModel from json.
func (o *OptFineTuningResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFineTuningResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFineTuningResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFineTuningResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberInboundSIPTrunkConfigResponseModel as json.
func (o OptGetPhoneNumberInboundSIPTrunkConfigResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetPhoneNumberInboundSIPTrunkConfigResponseModel from json.
func (o *OptGetPhoneNumberInboundSIPTrunkConfigResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPhoneNumberInboundSIPTrunkConfigResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPhoneNumberInboundSIPTrunkConfigResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPhoneNumberInboundSIPTrunkConfigResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberOutboundSIPTrunkConfigResponseModel as json.
func (o OptGetPhoneNumberOutboundSIPTrunkConfigResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetPhoneNumberOutboundSIPTrunkConfigResponseModel from json.
func (o *OptGetPhoneNumberOutboundSIPTrunkConfigResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPhoneNumberOutboundSIPTrunkConfigResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPhoneNumberOutboundSIPTrunkConfigResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPhoneNumberOutboundSIPTrunkConfigResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders as json.
func (o OptGetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders from json.
func (o *OptGetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders to nil")
	}
	o.Set = true
	o.Value = make(GetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPhoneNumberOutboundSIPTrunkConfigResponseModelHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberSIPTrunkResponseModelProvider as json.
func (o OptGetPhoneNumberSIPTrunkResponseModelProvider) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetPhoneNumberSIPTrunkResponseModelProvider from json.
func (o *OptGetPhoneNumberSIPTrunkResponseModelProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPhoneNumberSIPTrunkResponseModelProvider to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPhoneNumberSIPTrunkResponseModelProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPhoneNumberSIPTrunkResponseModelProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetPhoneNumberTwilioResponseModelProvider as json.
func (o OptGetPhoneNumberTwilioResponseModelProvider) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetPhoneNumberTwilioResponseModelProvider from json.
func (o *OptGetPhoneNumberTwilioResponseModelProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetPhoneNumberTwilioResponseModelProvider to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetPhoneNumberTwilioResponseModelProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetPhoneNumberTwilioResponseModelProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUnitTestResponseModelDynamicVariables as json.
func (o OptGetUnitTestResponseModelDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUnitTestResponseModelDynamicVariables from json.
func (o *OptGetUnitTestResponseModelDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUnitTestResponseModelDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(GetUnitTestResponseModelDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUnitTestResponseModelDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUnitTestResponseModelDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HistoryAlignmentsResponseModel as json.
func (o OptHistoryAlignmentsResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HistoryAlignmentsResponseModel from json.
func (o *OptHistoryAlignmentsResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHistoryAlignmentsResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHistoryAlignmentsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHistoryAlignmentsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InboundSIPTrunkConfigRequestModel as json.
func (o OptInboundSIPTrunkConfigRequestModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InboundSIPTrunkConfigRequestModel from json.
func (o *OptInboundSIPTrunkConfigRequestModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInboundSIPTrunkConfigRequestModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInboundSIPTrunkConfigRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInboundSIPTrunkConfigRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLM as json.
func (o OptLLM) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LLM from json.
func (o *OptLLM) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLM to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMCategoryUsage as json.
func (o OptLLMCategoryUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMCategoryUsage from json.
func (o *OptLLMCategoryUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMCategoryUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMCategoryUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMCategoryUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMTokensCategoryUsage as json.
func (o OptLLMTokensCategoryUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMTokensCategoryUsage from json.
func (o *OptLLMTokensCategoryUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMTokensCategoryUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMTokensCategoryUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMTokensCategoryUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMUsageInput as json.
func (o OptLLMUsageInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMUsageInput from json.
func (o *OptLLMUsageInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMUsageInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMUsageInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMUsageInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMUsageInputModelUsage as json.
func (o OptLLMUsageInputModelUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMUsageInputModelUsage from json.
func (o *OptLLMUsageInputModelUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMUsageInputModelUsage to nil")
	}
	o.Set = true
	o.Value = make(LLMUsageInputModelUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMUsageInputModelUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMUsageInputModelUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMUsageOutput as json.
func (o OptLLMUsageOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMUsageOutput from json.
func (o *OptLLMUsageOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMUsageOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMUsageOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMUsageOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LLMUsageOutputModelUsage as json.
func (o OptLLMUsageOutputModelUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LLMUsageOutputModelUsage from json.
func (o *OptLLMUsageOutputModelUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLLMUsageOutputModelUsage to nil")
	}
	o.Set = true
	o.Value = make(LLMUsageOutputModelUsage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLLMUsageOutputModelUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLLMUsageOutputModelUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LanguageDetectionToolResultModelResultType as json.
func (o OptLanguageDetectionToolResultModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LanguageDetectionToolResultModelResultType from json.
func (o *OptLanguageDetectionToolResultModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLanguageDetectionToolResultModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLanguageDetectionToolResultModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLanguageDetectionToolResultModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LanguageDetectionToolResultModelStatus as json.
func (o OptLanguageDetectionToolResultModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LanguageDetectionToolResultModelStatus from json.
func (o *OptLanguageDetectionToolResultModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLanguageDetectionToolResultModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLanguageDetectionToolResultModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLanguageDetectionToolResultModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListResponseMeta as json.
func (o OptListResponseMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ListResponseMeta from json.
func (o *OptListResponseMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListResponseMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListResponseMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListResponseMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiteralJsonSchemaProperty as json.
func (o OptLiteralJsonSchemaProperty) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LiteralJsonSchemaProperty from json.
func (o *OptLiteralJsonSchemaProperty) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLiteralJsonSchemaProperty to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLiteralJsonSchemaProperty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLiteralJsonSchemaProperty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LiteralJsonSchemaPropertyConstantValue as json.
func (o OptLiteralJsonSchemaPropertyConstantValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LiteralJsonSchemaPropertyConstantValue from json.
func (o *OptLiteralJsonSchemaPropertyConstantValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLiteralJsonSchemaPropertyConstantValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLiteralJsonSchemaPropertyConstantValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLiteralJsonSchemaPropertyConstantValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LivekitStackType as json.
func (o OptLivekitStackType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LivekitStackType from json.
func (o *OptLivekitStackType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLivekitStackType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLivekitStackType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLivekitStackType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ManualVerificationResponseModel as json.
func (o OptManualVerificationResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ManualVerificationResponseModel from json.
func (o *OptManualVerificationResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptManualVerificationResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptManualVerificationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptManualVerificationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModelSettingsResponseModel as json.
func (o OptModelSettingsResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModelSettingsResponseModel from json.
func (o *OptModelSettingsResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModelSettingsResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModelSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModelSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MusicPrompt as json.
func (o OptMusicPrompt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MusicPrompt from json.
func (o *OptMusicPrompt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMusicPrompt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMusicPrompt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMusicPrompt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []AdditionalFormatResponseModel as json.
func (o OptNilAdditionalFormatResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []AdditionalFormatResponseModel from json.
func (o *OptNilAdditionalFormatResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAdditionalFormatResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []AdditionalFormatResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]AdditionalFormatResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem AdditionalFormatResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAdditionalFormatResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAdditionalFormatResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels as json.
func (o OptNilBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels from json.
func (o *OptNilBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodyCreateANewVoiceFromVoicePreviewV1TextToVoicePostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels as json.
func (o OptNilBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels from json.
func (o *OptNilBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyCreatePVCVoiceV1VoicesPvcPostLabels as json.
func (o OptNilBodyCreatePVCVoiceV1VoicesPvcPostLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyCreatePVCVoiceV1VoicesPvcPostLabels from json.
func (o *OptNilBodyCreatePVCVoiceV1VoicesPvcPostLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodyCreatePVCVoiceV1VoicesPvcPostLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodyCreatePVCVoiceV1VoicesPvcPostLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(BodyCreatePVCVoiceV1VoicesPvcPostLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodyCreatePVCVoiceV1VoicesPvcPostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodyCreatePVCVoiceV1VoicesPvcPostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels as json.
func (o OptNilBodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels from json.
func (o *OptNilBodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(BodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodyEditPVCVoiceV1VoicesPvcVoiceIDPostLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission as json.
func (o OptNilBodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission from json.
func (o *OptNilBodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodyInviteUserV1WorkspaceInvitesAddPostWorkspacePermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata as json.
func (o OptNilBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata from json.
func (o *OptNilBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodySpeechToTextV1SpeechToTextPostMultipartWebhookMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole as json.
func (o OptNilBodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole from json.
func (o *OptNilBodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v BodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBodyUpdateMemberV1WorkspaceMembersPostWorkspaceRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModelTextAlign as json.
func (o OptNilCaptionStyleModelTextAlign) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CaptionStyleModelTextAlign from json.
func (o *OptNilCaptionStyleModelTextAlign) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCaptionStyleModelTextAlign to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CaptionStyleModelTextAlign
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCaptionStyleModelTextAlign) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCaptionStyleModelTextAlign) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModelTextStyle as json.
func (o OptNilCaptionStyleModelTextStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CaptionStyleModelTextStyle from json.
func (o *OptNilCaptionStyleModelTextStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCaptionStyleModelTextStyle to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CaptionStyleModelTextStyle
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCaptionStyleModelTextStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCaptionStyleModelTextStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CaptionStyleModelTextWeight as json.
func (o OptNilCaptionStyleModelTextWeight) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CaptionStyleModelTextWeight from json.
func (o *OptNilCaptionStyleModelTextWeight) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCaptionStyleModelTextWeight to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CaptionStyleModelTextWeight
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCaptionStyleModelTextWeight) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCaptionStyleModelTextWeight) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryMetadataCommonModelPhoneCall as json.
func (o OptNilConversationHistoryMetadataCommonModelPhoneCall) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryMetadataCommonModelPhoneCall from json.
func (o *OptNilConversationHistoryMetadataCommonModelPhoneCall) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryMetadataCommonModelPhoneCall to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryMetadataCommonModelPhoneCall
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryMetadataCommonModelPhoneCall) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryMetadataCommonModelPhoneCall) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelInputSourceMedium as json.
func (o OptNilConversationHistoryTranscriptCommonModelInputSourceMedium) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptCommonModelInputSourceMedium from json.
func (o *OptNilConversationHistoryTranscriptCommonModelInputSourceMedium) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptCommonModelInputSourceMedium to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryTranscriptCommonModelInputSourceMedium
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptCommonModelInputSourceMedium) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptCommonModelInputSourceMedium) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []ConversationHistoryTranscriptCommonModelOutput as json.
func (o OptNilConversationHistoryTranscriptCommonModelOutputArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []ConversationHistoryTranscriptCommonModelOutput from json.
func (o *OptNilConversationHistoryTranscriptCommonModelOutputArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptCommonModelOutputArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []ConversationHistoryTranscriptCommonModelOutput
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]ConversationHistoryTranscriptCommonModelOutput, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem ConversationHistoryTranscriptCommonModelOutput
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptCommonModelOutputArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptCommonModelOutputArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptCommonModelOutputSourceMedium as json.
func (o OptNilConversationHistoryTranscriptCommonModelOutputSourceMedium) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptCommonModelOutputSourceMedium from json.
func (o *OptNilConversationHistoryTranscriptCommonModelOutputSourceMedium) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptCommonModelOutputSourceMedium to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryTranscriptCommonModelOutputSourceMedium
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptCommonModelOutputSourceMedium) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptCommonModelOutputSourceMedium) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptOtherToolsResultCommonModelType as json.
func (o OptNilConversationHistoryTranscriptOtherToolsResultCommonModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationHistoryTranscriptOtherToolsResultCommonModelType from json.
func (o *OptNilConversationHistoryTranscriptOtherToolsResultCommonModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptOtherToolsResultCommonModelType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryTranscriptOtherToolsResultCommonModelType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptOtherToolsResultCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptOtherToolsResultCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptSystemToolResultCommonModelResult as json.
func (o OptNilConversationHistoryTranscriptSystemToolResultCommonModelResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptSystemToolResultCommonModelResult from json.
func (o *OptNilConversationHistoryTranscriptSystemToolResultCommonModelResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptSystemToolResultCommonModelResult to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryTranscriptSystemToolResultCommonModelResult
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptSystemToolResultCommonModelResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptSystemToolResultCommonModelResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallCommonModelInputToolDetails as json.
func (o OptNilConversationHistoryTranscriptToolCallCommonModelInputToolDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptToolCallCommonModelInputToolDetails from json.
func (o *OptNilConversationHistoryTranscriptToolCallCommonModelInputToolDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptToolCallCommonModelInputToolDetails to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryTranscriptToolCallCommonModelInputToolDetails
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptToolCallCommonModelInputToolDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptToolCallCommonModelInputToolDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails as json.
func (o OptNilConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails from json.
func (o *OptNilConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationHistoryTranscriptToolCallCommonModelOutputToolDetails to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationHistoryTranscriptToolCallCommonModelOutputToolDetails
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationHistoryTranscriptToolCallCommonModelOutputToolDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConversationSummaryResponseModelDirection as json.
func (o OptNilConversationSummaryResponseModelDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConversationSummaryResponseModelDirection from json.
func (o *OptNilConversationSummaryResponseModelDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilConversationSummaryResponseModelDirection to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ConversationSummaryResponseModelDirection
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilConversationSummaryResponseModelDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilConversationSummaryResponseModelDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []DialogueInputResponseModel as json.
func (o OptNilDialogueInputResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []DialogueInputResponseModel from json.
func (o *OptNilDialogueInputResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDialogueInputResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []DialogueInputResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]DialogueInputResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem DialogueInputResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDialogueInputResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDialogueInputResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningResponseModelMessage as json.
func (o OptNilFineTuningResponseModelMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FineTuningResponseModelMessage from json.
func (o *OptNilFineTuningResponseModelMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFineTuningResponseModelMessage to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v FineTuningResponseModelMessage
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(FineTuningResponseModelMessage)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFineTuningResponseModelMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFineTuningResponseModelMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FineTuningResponseModelProgress as json.
func (o OptNilFineTuningResponseModelProgress) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FineTuningResponseModelProgress from json.
func (o *OptNilFineTuningResponseModelProgress) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFineTuningResponseModelProgress to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v FineTuningResponseModelProgress
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(FineTuningResponseModelProgress)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFineTuningResponseModelProgress) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFineTuningResponseModelProgress) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []float64 as json.
func (o OptNilFloat64Array) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Float64(elem)
	}
	e.ArrEnd()
}

// Decode decodes []float64 from json.
func (o *OptNilFloat64Array) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64Array to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]float64, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem float64
		v, err := d.Float64()
		elem = float64(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64Array) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64Array) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelAspectRatio as json.
func (o OptNilProjectResponseModelAspectRatio) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectResponseModelAspectRatio from json.
func (o *OptNilProjectResponseModelAspectRatio) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProjectResponseModelAspectRatio to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ProjectResponseModelAspectRatio
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProjectResponseModelAspectRatio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProjectResponseModelAspectRatio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelFiction as json.
func (o OptNilProjectResponseModelFiction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectResponseModelFiction from json.
func (o *OptNilProjectResponseModelFiction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProjectResponseModelFiction to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ProjectResponseModelFiction
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProjectResponseModelFiction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProjectResponseModelFiction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelSourceType as json.
func (o OptNilProjectResponseModelSourceType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectResponseModelSourceType from json.
func (o *OptNilProjectResponseModelSourceType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProjectResponseModelSourceType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ProjectResponseModelSourceType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProjectResponseModelSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProjectResponseModelSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelTargetAudience as json.
func (o OptNilProjectResponseModelTargetAudience) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectResponseModelTargetAudience from json.
func (o *OptNilProjectResponseModelTargetAudience) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProjectResponseModelTargetAudience to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ProjectResponseModelTargetAudience
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProjectResponseModelTargetAudience) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProjectResponseModelTargetAudience) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []PronunciationDictionaryVersionLocatorRequestModel as json.
func (o OptNilPronunciationDictionaryVersionLocatorRequestModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []PronunciationDictionaryVersionLocatorRequestModel from json.
func (o *OptNilPronunciationDictionaryVersionLocatorRequestModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilPronunciationDictionaryVersionLocatorRequestModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []PronunciationDictionaryVersionLocatorRequestModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]PronunciationDictionaryVersionLocatorRequestModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem PronunciationDictionaryVersionLocatorRequestModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilPronunciationDictionaryVersionLocatorRequestModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilPronunciationDictionaryVersionLocatorRequestModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []ReaderResourceResponseModel as json.
func (o OptNilReaderResourceResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []ReaderResourceResponseModel from json.
func (o *OptNilReaderResourceResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReaderResourceResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []ReaderResourceResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]ReaderResourceResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem ReaderResourceResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReaderResourceResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReaderResourceResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SampleResponseModel as json.
func (o OptNilSampleResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SampleResponseModel from json.
func (o *OptNilSampleResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSampleResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SampleResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SampleResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SampleResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSampleResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSampleResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SegmentCreatePayloadTranslations as json.
func (o OptNilSegmentCreatePayloadTranslations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SegmentCreatePayloadTranslations from json.
func (o *OptNilSegmentCreatePayloadTranslations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSegmentCreatePayloadTranslations to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SegmentCreatePayloadTranslations
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SegmentCreatePayloadTranslations)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSegmentCreatePayloadTranslations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSegmentCreatePayloadTranslations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakerSeparationResponseModelSpeakers as json.
func (o OptNilSpeakerSeparationResponseModelSpeakers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpeakerSeparationResponseModelSpeakers from json.
func (o *OptNilSpeakerSeparationResponseModelSpeakers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpeakerSeparationResponseModelSpeakers to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpeakerSeparationResponseModelSpeakers
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SpeakerSeparationResponseModelSpeakers)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpeakerSeparationResponseModelSpeakers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpeakerSeparationResponseModelSpeakers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechHistoryItemResponseModelSource as json.
func (o OptNilSpeechHistoryItemResponseModelSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeechHistoryItemResponseModelSource from json.
func (o *OptNilSpeechHistoryItemResponseModelSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpeechHistoryItemResponseModelSource to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpeechHistoryItemResponseModelSource
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpeechHistoryItemResponseModelSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpeechHistoryItemResponseModelSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechHistoryItemResponseModelVoiceCategory as json.
func (o OptNilSpeechHistoryItemResponseModelVoiceCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpeechHistoryItemResponseModelVoiceCategory from json.
func (o *OptNilSpeechHistoryItemResponseModelVoiceCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpeechHistoryItemResponseModelVoiceCategory to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpeechHistoryItemResponseModelVoiceCategory
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpeechHistoryItemResponseModelVoiceCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpeechHistoryItemResponseModelVoiceCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SpeechToTextCharacterResponseModel as json.
func (o OptNilSpeechToTextCharacterResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SpeechToTextCharacterResponseModel from json.
func (o *OptNilSpeechToTextCharacterResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpeechToTextCharacterResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SpeechToTextCharacterResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SpeechToTextCharacterResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SpeechToTextCharacterResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpeechToTextCharacterResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpeechToTextCharacterResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionResponseModelCurrency as json.
func (o OptNilSubscriptionResponseModelCurrency) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SubscriptionResponseModelCurrency from json.
func (o *OptNilSubscriptionResponseModelCurrency) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSubscriptionResponseModelCurrency to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SubscriptionResponseModelCurrency
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSubscriptionResponseModelCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSubscriptionResponseModelCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []UtteranceResponseModel as json.
func (o OptNilUtteranceResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []UtteranceResponseModel from json.
func (o *OptNilUtteranceResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUtteranceResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []UtteranceResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]UtteranceResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem UtteranceResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUtteranceResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUtteranceResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []VerificationAttemptResponseModel as json.
func (o OptNilVerificationAttemptResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []VerificationAttemptResponseModel from json.
func (o *OptNilVerificationAttemptResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilVerificationAttemptResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []VerificationAttemptResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]VerificationAttemptResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem VerificationAttemptResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilVerificationAttemptResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilVerificationAttemptResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []VerifiedVoiceLanguageResponseModel as json.
func (o OptNilVerifiedVoiceLanguageResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []VerifiedVoiceLanguageResponseModel from json.
func (o *OptNilVerifiedVoiceLanguageResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilVerifiedVoiceLanguageResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []VerifiedVoiceLanguageResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]VerifiedVoiceLanguageResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem VerifiedVoiceLanguageResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilVerifiedVoiceLanguageResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilVerifiedVoiceLanguageResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceResponseModelSafetyControl as json.
func (o OptNilVoiceResponseModelSafetyControl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VoiceResponseModelSafetyControl from json.
func (o *OptNilVoiceResponseModelSafetyControl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilVoiceResponseModelSafetyControl to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v VoiceResponseModelSafetyControl
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilVoiceResponseModelSafetyControl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilVoiceResponseModelSafetyControl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []WorkspaceApiKeyResponseModelPermissionsItem as json.
func (o OptNilWorkspaceApiKeyResponseModelPermissionsItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []WorkspaceApiKeyResponseModelPermissionsItem from json.
func (o *OptNilWorkspaceApiKeyResponseModelPermissionsItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilWorkspaceApiKeyResponseModelPermissionsItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []WorkspaceApiKeyResponseModelPermissionsItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]WorkspaceApiKeyResponseModelPermissionsItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem WorkspaceApiKeyResponseModelPermissionsItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilWorkspaceApiKeyResponseModelPermissionsItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilWorkspaceApiKeyResponseModelPermissionsItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []WorkspaceWebhookUsageResponseModel as json.
func (o OptNilWorkspaceWebhookUsageResponseModelArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []WorkspaceWebhookUsageResponseModel from json.
func (o *OptNilWorkspaceWebhookUsageResponseModelArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilWorkspaceWebhookUsageResponseModelArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []WorkspaceWebhookUsageResponseModel
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]WorkspaceWebhookUsageResponseModel, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem WorkspaceWebhookUsageResponseModel
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilWorkspaceWebhookUsageResponseModelArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilWorkspaceWebhookUsageResponseModelArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OutboundSIPTrunkConfigRequestModel as json.
func (o OptOutboundSIPTrunkConfigRequestModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OutboundSIPTrunkConfigRequestModel from json.
func (o *OptOutboundSIPTrunkConfigRequestModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOutboundSIPTrunkConfigRequestModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOutboundSIPTrunkConfigRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOutboundSIPTrunkConfigRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OutboundSIPTrunkConfigRequestModelHeaders as json.
func (o OptOutboundSIPTrunkConfigRequestModelHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OutboundSIPTrunkConfigRequestModelHeaders from json.
func (o *OptOutboundSIPTrunkConfigRequestModelHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOutboundSIPTrunkConfigRequestModelHeaders to nil")
	}
	o.Set = true
	o.Value = make(OutboundSIPTrunkConfigRequestModelHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOutboundSIPTrunkConfigRequestModelHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOutboundSIPTrunkConfigRequestModelHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PhoneNumberAgentInfo as json.
func (o OptPhoneNumberAgentInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PhoneNumberAgentInfo from json.
func (o *OptPhoneNumberAgentInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPhoneNumberAgentInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPhoneNumberAgentInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPhoneNumberAgentInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultErrorModelResultType as json.
func (o OptPlayDTMFResultErrorModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayDTMFResultErrorModelResultType from json.
func (o *OptPlayDTMFResultErrorModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayDTMFResultErrorModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayDTMFResultErrorModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayDTMFResultErrorModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultErrorModelStatus as json.
func (o OptPlayDTMFResultErrorModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayDTMFResultErrorModelStatus from json.
func (o *OptPlayDTMFResultErrorModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayDTMFResultErrorModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayDTMFResultErrorModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayDTMFResultErrorModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultSuccessModelResultType as json.
func (o OptPlayDTMFResultSuccessModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayDTMFResultSuccessModelResultType from json.
func (o *OptPlayDTMFResultSuccessModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayDTMFResultSuccessModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayDTMFResultSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayDTMFResultSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultSuccessModelStatus as json.
func (o OptPlayDTMFResultSuccessModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlayDTMFResultSuccessModelStatus from json.
func (o *OptPlayDTMFResultSuccessModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlayDTMFResultSuccessModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlayDTMFResultSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlayDTMFResultSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectCreationMetaResponseModel as json.
func (o OptProjectCreationMetaResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectCreationMetaResponseModel from json.
func (o *OptProjectCreationMetaResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectCreationMetaResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectCreationMetaResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectCreationMetaResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ProjectSnapshotExtendedResponseModelAudioUpload as json.
func (o OptProjectSnapshotExtendedResponseModelAudioUpload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ProjectSnapshotExtendedResponseModelAudioUpload from json.
func (o *OptProjectSnapshotExtendedResponseModelAudioUpload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectSnapshotExtendedResponseModelAudioUpload to nil")
	}
	o.Set = true
	o.Value = new(ProjectSnapshotExtendedResponseModelAudioUpload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectSnapshotExtendedResponseModelAudioUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectSnapshotExtendedResponseModelAudioUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ProjectSnapshotExtendedResponseModelZipUpload as json.
func (o OptProjectSnapshotExtendedResponseModelZipUpload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ProjectSnapshotExtendedResponseModelZipUpload from json.
func (o *OptProjectSnapshotExtendedResponseModelZipUpload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectSnapshotExtendedResponseModelZipUpload to nil")
	}
	o.Set = true
	o.Value = new(ProjectSnapshotExtendedResponseModelZipUpload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectSnapshotExtendedResponseModelZipUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectSnapshotExtendedResponseModelZipUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ProjectSnapshotResponseModelAudioUpload as json.
func (o OptProjectSnapshotResponseModelAudioUpload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ProjectSnapshotResponseModelAudioUpload from json.
func (o *OptProjectSnapshotResponseModelAudioUpload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectSnapshotResponseModelAudioUpload to nil")
	}
	o.Set = true
	o.Value = new(ProjectSnapshotResponseModelAudioUpload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectSnapshotResponseModelAudioUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectSnapshotResponseModelAudioUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ProjectSnapshotResponseModelZipUpload as json.
func (o OptProjectSnapshotResponseModelZipUpload) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ProjectSnapshotResponseModelZipUpload from json.
func (o *OptProjectSnapshotResponseModelZipUpload) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectSnapshotResponseModelZipUpload to nil")
	}
	o.Set = true
	o.Value = new(ProjectSnapshotResponseModelZipUpload)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectSnapshotResponseModelZipUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectSnapshotResponseModelZipUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PromptAgentAPIModelOverride as json.
func (o OptPromptAgentAPIModelOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PromptAgentAPIModelOverride from json.
func (o *OptPromptAgentAPIModelOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPromptAgentAPIModelOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPromptAgentAPIModelOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPromptAgentAPIModelOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RagRetrievalInfo as json.
func (o OptRagRetrievalInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RagRetrievalInfo from json.
func (o *OptRagRetrievalInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRagRetrievalInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRagRetrievalInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRagRetrievalInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RecordingResponseModel as json.
func (o OptRecordingResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RecordingResponseModel from json.
func (o *OptRecordingResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRecordingResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRecordingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRecordingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReferencedToolCommonModel as json.
func (o OptReferencedToolCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReferencedToolCommonModel from json.
func (o *OptReferencedToolCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptReferencedToolCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptReferencedToolCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptReferencedToolCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceAccessInfo as json.
func (o OptResourceAccessInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResourceAccessInfo from json.
func (o *OptResourceAccessInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceAccessInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceAccessInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceAccessInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SIPMediaEncryptionEnum as json.
func (o OptSIPMediaEncryptionEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SIPMediaEncryptionEnum from json.
func (o *OptSIPMediaEncryptionEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSIPMediaEncryptionEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSIPMediaEncryptionEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSIPMediaEncryptionEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SIPTrunkCredentialsRequestModel as json.
func (o OptSIPTrunkCredentialsRequestModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SIPTrunkCredentialsRequestModel from json.
func (o *OptSIPTrunkCredentialsRequestModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSIPTrunkCredentialsRequestModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSIPTrunkCredentialsRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSIPTrunkCredentialsRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SIPTrunkTransportEnum as json.
func (o OptSIPTrunkTransportEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SIPTrunkTransportEnum from json.
func (o *OptSIPTrunkTransportEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSIPTrunkTransportEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSIPTrunkTransportEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSIPTrunkTransportEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SectionSource as json.
func (o OptSectionSource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SectionSource from json.
func (o *OptSectionSource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSectionSource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSectionSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSectionSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkipTurnToolResponseModelResultType as json.
func (o OptSkipTurnToolResponseModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SkipTurnToolResponseModelResultType from json.
func (o *OptSkipTurnToolResponseModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSkipTurnToolResponseModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSkipTurnToolResponseModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSkipTurnToolResponseModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkipTurnToolResponseModelStatus as json.
func (o OptSkipTurnToolResponseModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SkipTurnToolResponseModelStatus from json.
func (o *OptSkipTurnToolResponseModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSkipTurnToolResponseModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSkipTurnToolResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSkipTurnToolResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SoftTimeoutConfigOverride as json.
func (o OptSoftTimeoutConfigOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SoftTimeoutConfigOverride from json.
func (o *OptSoftTimeoutConfigOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSoftTimeoutConfigOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSoftTimeoutConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSoftTimeoutConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakerSeparationResponseModel as json.
func (o OptSpeakerSeparationResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpeakerSeparationResponseModel from json.
func (o *OptSpeakerSeparationResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeakerSeparationResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeakerSeparationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeakerSeparationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *SpeechHistoryItemResponseModelSettings as json.
func (o OptSpeechHistoryItemResponseModelSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *SpeechHistoryItemResponseModelSettings from json.
func (o *OptSpeechHistoryItemResponseModelSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpeechHistoryItemResponseModelSettings to nil")
	}
	o.Set = true
	o.Value = new(SpeechHistoryItemResponseModelSettings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpeechHistoryItemResponseModelSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpeechHistoryItemResponseModelSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TTSConversationalConfigOverride as json.
func (o OptTTSConversationalConfigOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TTSConversationalConfigOverride from json.
func (o *OptTTSConversationalConfigOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTTSConversationalConfigOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTTSConversationalConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTTSConversationalConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TelephonyProvider as json.
func (o OptTelephonyProvider) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TelephonyProvider from json.
func (o *OptTelephonyProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTelephonyProvider to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTelephonyProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTelephonyProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestConditionRationaleCommonModel as json.
func (o OptTestConditionRationaleCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestConditionRationaleCommonModel from json.
func (o *OptTestConditionRationaleCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestConditionRationaleCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestConditionRationaleCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestConditionRationaleCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestConditionResultCommonModel as json.
func (o OptTestConditionResultCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestConditionResultCommonModel from json.
func (o *OptTestConditionResultCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestConditionResultCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestConditionResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestConditionResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestFromConversationMetadataInput as json.
func (o OptTestFromConversationMetadataInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestFromConversationMetadataInput from json.
func (o *OptTestFromConversationMetadataInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestFromConversationMetadataInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestFromConversationMetadataInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestFromConversationMetadataInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestFromConversationMetadataOutput as json.
func (o OptTestFromConversationMetadataOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestFromConversationMetadataOutput from json.
func (o *OptTestFromConversationMetadataOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestFromConversationMetadataOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestFromConversationMetadataOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestFromConversationMetadataOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestRunMetadata as json.
func (o OptTestRunMetadata) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestRunMetadata from json.
func (o *OptTestRunMetadata) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestRunMetadata to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestRunMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestRunMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestRunMetadataTestType as json.
func (o OptTestRunMetadataTestType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestRunMetadataTestType from json.
func (o *OptTestRunMetadataTestType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestRunMetadataTestType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestRunMetadataTestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestRunMetadataTestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestToolResultModelResultType as json.
func (o OptTestToolResultModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestToolResultModelResultType from json.
func (o *OptTestToolResultModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestToolResultModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestToolResultModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestToolResultModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestToolResultModelStatus as json.
func (o OptTestToolResultModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestToolResultModelStatus from json.
func (o *OptTestToolResultModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestToolResultModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestToolResultModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestToolResultModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestsFeatureUsageCommonModel as json.
func (o OptTestsFeatureUsageCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestsFeatureUsageCommonModel from json.
func (o *OptTestsFeatureUsageCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestsFeatureUsageCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestsFeatureUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestsFeatureUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolAnnotations as json.
func (o OptToolAnnotations) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ToolAnnotations from json.
func (o *OptToolAnnotations) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolAnnotations to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallSoundBehavior as json.
func (o OptToolCallSoundBehavior) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ToolCallSoundBehavior from json.
func (o *OptToolCallSoundBehavior) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolCallSoundBehavior to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolCallSoundBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolCallSoundBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallSoundType as json.
func (o OptToolCallSoundType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ToolCallSoundType from json.
func (o *OptToolCallSoundType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolCallSoundType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolCallSoundType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolCallSoundType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolExecutionMode as json.
func (o OptToolExecutionMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ToolExecutionMode from json.
func (o *OptToolExecutionMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolExecutionMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolExecutionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolExecutionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ToolMeta as json.
func (o OptToolMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ToolMeta from json.
func (o *OptToolMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolMeta to nil")
	}
	o.Set = true
	o.Value = new(ToolMeta)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *ToolOutputSchema as json.
func (o OptToolOutputSchema) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *ToolOutputSchema from json.
func (o *OptToolOutputSchema) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolOutputSchema to nil")
	}
	o.Set = true
	o.Value = new(ToolOutputSchema)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolOutputSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolOutputSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolType as json.
func (o OptToolType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ToolType from json.
func (o *OptToolType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptToolType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptToolType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptToolType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultErrorModelResultType as json.
func (o OptTransferToAgentToolResultErrorModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToAgentToolResultErrorModelResultType from json.
func (o *OptTransferToAgentToolResultErrorModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToAgentToolResultErrorModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToAgentToolResultErrorModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToAgentToolResultErrorModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultErrorModelStatus as json.
func (o OptTransferToAgentToolResultErrorModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToAgentToolResultErrorModelStatus from json.
func (o *OptTransferToAgentToolResultErrorModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToAgentToolResultErrorModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToAgentToolResultErrorModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToAgentToolResultErrorModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultSuccessModelResultType as json.
func (o OptTransferToAgentToolResultSuccessModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToAgentToolResultSuccessModelResultType from json.
func (o *OptTransferToAgentToolResultSuccessModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToAgentToolResultSuccessModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToAgentToolResultSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToAgentToolResultSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultSuccessModelStatus as json.
func (o OptTransferToAgentToolResultSuccessModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToAgentToolResultSuccessModelStatus from json.
func (o *OptTransferToAgentToolResultSuccessModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToAgentToolResultSuccessModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToAgentToolResultSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToAgentToolResultSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultErrorModelResultType as json.
func (o OptTransferToNumberResultErrorModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToNumberResultErrorModelResultType from json.
func (o *OptTransferToNumberResultErrorModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToNumberResultErrorModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToNumberResultErrorModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToNumberResultErrorModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultErrorModelStatus as json.
func (o OptTransferToNumberResultErrorModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToNumberResultErrorModelStatus from json.
func (o *OptTransferToNumberResultErrorModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToNumberResultErrorModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToNumberResultErrorModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToNumberResultErrorModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultSipSuccessModelResultType as json.
func (o OptTransferToNumberResultSipSuccessModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToNumberResultSipSuccessModelResultType from json.
func (o *OptTransferToNumberResultSipSuccessModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToNumberResultSipSuccessModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToNumberResultSipSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToNumberResultSipSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultSipSuccessModelStatus as json.
func (o OptTransferToNumberResultSipSuccessModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToNumberResultSipSuccessModelStatus from json.
func (o *OptTransferToNumberResultSipSuccessModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToNumberResultSipSuccessModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToNumberResultSipSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToNumberResultSipSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultTwilioSuccessModelResultType as json.
func (o OptTransferToNumberResultTwilioSuccessModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToNumberResultTwilioSuccessModelResultType from json.
func (o *OptTransferToNumberResultTwilioSuccessModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToNumberResultTwilioSuccessModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToNumberResultTwilioSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToNumberResultTwilioSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultTwilioSuccessModelStatus as json.
func (o OptTransferToNumberResultTwilioSuccessModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TransferToNumberResultTwilioSuccessModelStatus from json.
func (o *OptTransferToNumberResultTwilioSuccessModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransferToNumberResultTwilioSuccessModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransferToNumberResultTwilioSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransferToNumberResultTwilioSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TurnConfigOverride as json.
func (o OptTurnConfigOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TurnConfigOverride from json.
func (o *OptTurnConfigOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTurnConfigOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTurnConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTurnConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestCommonModel as json.
func (o OptUnitTestCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UnitTestCommonModel from json.
func (o *OptUnitTestCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnitTestCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnitTestCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnitTestCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestCommonModelDynamicVariables as json.
func (o OptUnitTestCommonModelDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UnitTestCommonModelDynamicVariables from json.
func (o *OptUnitTestCommonModelDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnitTestCommonModelDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(UnitTestCommonModelDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnitTestCommonModelDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnitTestCommonModelDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestCommonModelType as json.
func (o OptUnitTestCommonModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UnitTestCommonModelType from json.
func (o *OptUnitTestCommonModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnitTestCommonModelType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnitTestCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnitTestCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestToolCallEvaluationModelInput as json.
func (o OptUnitTestToolCallEvaluationModelInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UnitTestToolCallEvaluationModelInput from json.
func (o *OptUnitTestToolCallEvaluationModelInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnitTestToolCallEvaluationModelInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnitTestToolCallEvaluationModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnitTestToolCallEvaluationModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestToolCallEvaluationModelOutput as json.
func (o OptUnitTestToolCallEvaluationModelOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UnitTestToolCallEvaluationModelOutput from json.
func (o *OptUnitTestToolCallEvaluationModelOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnitTestToolCallEvaluationModelOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnitTestToolCallEvaluationModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnitTestToolCallEvaluationModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUnitTestRequestDynamicVariables as json.
func (o OptUpdateUnitTestRequestDynamicVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateUnitTestRequestDynamicVariables from json.
func (o *OptUpdateUnitTestRequestDynamicVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUnitTestRequestDynamicVariables to nil")
	}
	o.Set = true
	o.Value = make(UpdateUnitTestRequestDynamicVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUnitTestRequestDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUnitTestRequestDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserFeedback as json.
func (o OptUserFeedback) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserFeedback from json.
func (o *OptUserFeedback) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserFeedback to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserFeedback) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserFeedback) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserFeedbackScore as json.
func (o OptUserFeedbackScore) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserFeedbackScore from json.
func (o *OptUserFeedbackScore) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserFeedbackScore to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserFeedbackScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserFeedbackScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceDesignRequestModelModelID as json.
func (o OptVoiceDesignRequestModelModelID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VoiceDesignRequestModelModelID from json.
func (o *OptVoiceDesignRequestModelModelID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceDesignRequestModelModelID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceDesignRequestModelModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceDesignRequestModelModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceMailDetectionResultSuccessModelResultType as json.
func (o OptVoiceMailDetectionResultSuccessModelResultType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VoiceMailDetectionResultSuccessModelResultType from json.
func (o *OptVoiceMailDetectionResultSuccessModelResultType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceMailDetectionResultSuccessModelResultType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceMailDetectionResultSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceMailDetectionResultSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceMailDetectionResultSuccessModelStatus as json.
func (o OptVoiceMailDetectionResultSuccessModelStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VoiceMailDetectionResultSuccessModelStatus from json.
func (o *OptVoiceMailDetectionResultSuccessModelStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceMailDetectionResultSuccessModelStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceMailDetectionResultSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceMailDetectionResultSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceSettingsResponseModel as json.
func (o OptVoiceSettingsResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceSettingsResponseModel from json.
func (o *OptVoiceSettingsResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceSettingsResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceSharingModerationCheckResponseModel as json.
func (o OptVoiceSharingModerationCheckResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceSharingModerationCheckResponseModel from json.
func (o *OptVoiceSharingModerationCheckResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceSharingModerationCheckResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceSharingModerationCheckResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceSharingModerationCheckResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceSharingResponseModel as json.
func (o OptVoiceSharingResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceSharingResponseModel from json.
func (o *OptVoiceSharingResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceSharingResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceSharingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceSharingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceVerificationResponseModel as json.
func (o OptVoiceVerificationResponseModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VoiceVerificationResponseModel from json.
func (o *OptVoiceVerificationResponseModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVoiceVerificationResponseModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVoiceVerificationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVoiceVerificationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhatsAppConversationInfo as json.
func (o OptWhatsAppConversationInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WhatsAppConversationInfo from json.
func (o *OptWhatsAppConversationInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWhatsAppConversationInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWhatsAppConversationInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWhatsAppConversationInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhatsAppConversationInfoDirection as json.
func (o OptWhatsAppConversationInfoDirection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WhatsAppConversationInfoDirection from json.
func (o *OptWhatsAppConversationInfoDirection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWhatsAppConversationInfoDirection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWhatsAppConversationInfoDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWhatsAppConversationInfoDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowFeaturesUsageCommonModel as json.
func (o OptWorkflowFeaturesUsageCommonModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowFeaturesUsageCommonModel from json.
func (o *OptWorkflowFeaturesUsageCommonModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowFeaturesUsageCommonModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowFeaturesUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowFeaturesUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolEdgeStepModelType as json.
func (o OptWorkflowToolEdgeStepModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowToolEdgeStepModelType from json.
func (o *OptWorkflowToolEdgeStepModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowToolEdgeStepModelType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowToolEdgeStepModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowToolEdgeStepModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolMaxIterationsExceededStepModelType as json.
func (o OptWorkflowToolMaxIterationsExceededStepModelType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowToolMaxIterationsExceededStepModelType from json.
func (o *OptWorkflowToolMaxIterationsExceededStepModelType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowToolMaxIterationsExceededStepModelType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowToolMaxIterationsExceededStepModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowToolMaxIterationsExceededStepModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolNestedToolsStepModelInputType as json.
func (o OptWorkflowToolNestedToolsStepModelInputType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowToolNestedToolsStepModelInputType from json.
func (o *OptWorkflowToolNestedToolsStepModelInputType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowToolNestedToolsStepModelInputType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowToolNestedToolsStepModelInputType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowToolNestedToolsStepModelInputType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolNestedToolsStepModelOutputType as json.
func (o OptWorkflowToolNestedToolsStepModelOutputType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes WorkflowToolNestedToolsStepModelOutputType from json.
func (o *OptWorkflowToolNestedToolsStepModelOutputType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowToolNestedToolsStepModelOutputType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowToolNestedToolsStepModelOutputType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowToolNestedToolsStepModelOutputType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolResponseModelInput as json.
func (o OptWorkflowToolResponseModelInput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowToolResponseModelInput from json.
func (o *OptWorkflowToolResponseModelInput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowToolResponseModelInput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowToolResponseModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowToolResponseModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolResponseModelOutput as json.
func (o OptWorkflowToolResponseModelOutput) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkflowToolResponseModelOutput from json.
func (o *OptWorkflowToolResponseModelOutput) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkflowToolResponseModelOutput to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkflowToolResponseModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkflowToolResponseModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ZendeskConversationInitiationTriggerTriggerType as json.
func (o OptZendeskConversationInitiationTriggerTriggerType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ZendeskConversationInitiationTriggerTriggerType from json.
func (o *OptZendeskConversationInitiationTriggerTriggerType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptZendeskConversationInitiationTriggerTriggerType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptZendeskConversationInitiationTriggerTriggerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptZendeskConversationInitiationTriggerTriggerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OutboundCallRecipient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OutboundCallRecipient) encodeFields(e *jx.Encoder) {
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		if s.WhatsappUserID.Set {
			e.FieldStart("whatsapp_user_id")
			s.WhatsappUserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfOutboundCallRecipient = [4]string{
	0: "conversation_initiation_client_data",
	1: "id",
	2: "phone_number",
	3: "whatsapp_user_id",
}

// Decode decodes OutboundCallRecipient from json.
func (s *OutboundCallRecipient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OutboundCallRecipient to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "whatsapp_user_id":
			if err := func() error {
				s.WhatsappUserID.Reset()
				if err := s.WhatsappUserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OutboundCallRecipient")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OutboundCallRecipient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OutboundCallRecipient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OutboundCallRecipientResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OutboundCallRecipientResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conversation_id")
		s.ConversationID.Encode(e)
	}
	{
		if s.ConversationInitiationClientData.Set {
			e.FieldStart("conversation_initiation_client_data")
			s.ConversationInitiationClientData.Encode(e)
		}
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.PhoneNumber.Set {
			e.FieldStart("phone_number")
			s.PhoneNumber.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("updated_at_unix")
		e.Int(s.UpdatedAtUnix)
	}
	{
		if s.WhatsappUserID.Set {
			e.FieldStart("whatsapp_user_id")
			s.WhatsappUserID.Encode(e)
		}
	}
}

var jsonFieldsNameOfOutboundCallRecipientResponseModel = [8]string{
	0: "conversation_id",
	1: "conversation_initiation_client_data",
	2: "created_at_unix",
	3: "id",
	4: "phone_number",
	5: "status",
	6: "updated_at_unix",
	7: "whatsapp_user_id",
}

// Decode decodes OutboundCallRecipientResponseModel from json.
func (s *OutboundCallRecipientResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OutboundCallRecipientResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "conversation_initiation_client_data":
			if err := func() error {
				s.ConversationInitiationClientData.Reset()
				if err := s.ConversationInitiationClientData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "phone_number":
			if err := func() error {
				s.PhoneNumber.Reset()
				if err := s.PhoneNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "updated_at_unix":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.UpdatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at_unix\"")
			}
		case "whatsapp_user_id":
			if err := func() error {
				s.WhatsappUserID.Reset()
				if err := s.WhatsappUserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OutboundCallRecipientResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOutboundCallRecipientResponseModel) {
					name = jsonFieldsNameOfOutboundCallRecipientResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OutboundCallRecipientResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OutboundCallRecipientResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OutboundSIPTrunkConfigRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OutboundSIPTrunkConfigRequestModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.MediaEncryption.Set {
			e.FieldStart("media_encryption")
			s.MediaEncryption.Encode(e)
		}
	}
	{
		if s.Transport.Set {
			e.FieldStart("transport")
			s.Transport.Encode(e)
		}
	}
}

var jsonFieldsNameOfOutboundSIPTrunkConfigRequestModel = [5]string{
	0: "address",
	1: "credentials",
	2: "headers",
	3: "media_encryption",
	4: "transport",
}

// Decode decodes OutboundSIPTrunkConfigRequestModel from json.
func (s *OutboundSIPTrunkConfigRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OutboundSIPTrunkConfigRequestModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "media_encryption":
			if err := func() error {
				s.MediaEncryption.Reset()
				if err := s.MediaEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_encryption\"")
			}
		case "transport":
			if err := func() error {
				s.Transport.Reset()
				if err := s.Transport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OutboundSIPTrunkConfigRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOutboundSIPTrunkConfigRequestModel) {
					name = jsonFieldsNameOfOutboundSIPTrunkConfigRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OutboundSIPTrunkConfigRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OutboundSIPTrunkConfigRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OutboundSIPTrunkConfigRequestModelHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s OutboundSIPTrunkConfigRequestModelHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes OutboundSIPTrunkConfigRequestModelHeaders from json.
func (s *OutboundSIPTrunkConfigRequestModelHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OutboundSIPTrunkConfigRequestModelHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OutboundSIPTrunkConfigRequestModelHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OutboundSIPTrunkConfigRequestModelHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OutboundSIPTrunkConfigRequestModelHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchConvAIDashboardSettingsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchConvAIDashboardSettingsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Charts != nil {
			e.FieldStart("charts")
			e.ArrStart()
			for _, elem := range s.Charts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPatchConvAIDashboardSettingsRequest = [1]string{
	0: "charts",
}

// Decode decodes PatchConvAIDashboardSettingsRequest from json.
func (s *PatchConvAIDashboardSettingsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchConvAIDashboardSettingsRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "charts":
			if err := func() error {
				s.Charts = make([]PatchConvAIDashboardSettingsRequestChartsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PatchConvAIDashboardSettingsRequestChartsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Charts = append(s.Charts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"charts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchConvAIDashboardSettingsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchConvAIDashboardSettingsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchConvAIDashboardSettingsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchConvAIDashboardSettingsRequestChartsItem as json.
func (s PatchConvAIDashboardSettingsRequestChartsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s PatchConvAIDashboardSettingsRequestChartsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case DashboardCallSuccessChartModelPatchConvAIDashboardSettingsRequestChartsItem:
		e.FieldStart("type")
		e.Str("call_success")
		{
			s := s.DashboardCallSuccessChartModel
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	case DashboardCriteriaChartModelPatchConvAIDashboardSettingsRequestChartsItem:
		e.FieldStart("type")
		e.Str("criteria")
		{
			s := s.DashboardCriteriaChartModel
			{
				e.FieldStart("criteria_id")
				e.Str(s.CriteriaID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	case DashboardDataCollectionChartModelPatchConvAIDashboardSettingsRequestChartsItem:
		e.FieldStart("type")
		e.Str("data_collection")
		{
			s := s.DashboardDataCollectionChartModel
			{
				e.FieldStart("data_collection_id")
				e.Str(s.DataCollectionID)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
		}
	}
}

// Decode decodes PatchConvAIDashboardSettingsRequestChartsItem from json.
func (s *PatchConvAIDashboardSettingsRequestChartsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchConvAIDashboardSettingsRequestChartsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "call_success":
					s.Type = DashboardCallSuccessChartModelPatchConvAIDashboardSettingsRequestChartsItem
					found = true
				case "criteria":
					s.Type = DashboardCriteriaChartModelPatchConvAIDashboardSettingsRequestChartsItem
					found = true
				case "data_collection":
					s.Type = DashboardDataCollectionChartModelPatchConvAIDashboardSettingsRequestChartsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DashboardCallSuccessChartModelPatchConvAIDashboardSettingsRequestChartsItem:
		if err := s.DashboardCallSuccessChartModel.Decode(d); err != nil {
			return err
		}
	case DashboardCriteriaChartModelPatchConvAIDashboardSettingsRequestChartsItem:
		if err := s.DashboardCriteriaChartModel.Decode(d); err != nil {
			return err
		}
	case DashboardDataCollectionChartModelPatchConvAIDashboardSettingsRequestChartsItem:
		if err := s.DashboardDataCollectionChartModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PatchConvAIDashboardSettingsRequestChartsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchConvAIDashboardSettingsRequestChartsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchConvAISettingsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchConvAISettingsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.CanUseMcpServers.Set {
			e.FieldStart("can_use_mcp_servers")
			s.CanUseMcpServers.Encode(e)
		}
	}
	{
		if s.ConversationInitiationClientDataWebhook.Set {
			e.FieldStart("conversation_initiation_client_data_webhook")
			s.ConversationInitiationClientDataWebhook.Encode(e)
		}
	}
	{
		if s.DefaultLivekitStack.Set {
			e.FieldStart("default_livekit_stack")
			s.DefaultLivekitStack.Encode(e)
		}
	}
	{
		if s.RagRetentionPeriodDays.Set {
			e.FieldStart("rag_retention_period_days")
			s.RagRetentionPeriodDays.Encode(e)
		}
	}
	{
		if s.Webhooks.Set {
			e.FieldStart("webhooks")
			s.Webhooks.Encode(e)
		}
	}
}

var jsonFieldsNameOfPatchConvAISettingsRequest = [5]string{
	0: "can_use_mcp_servers",
	1: "conversation_initiation_client_data_webhook",
	2: "default_livekit_stack",
	3: "rag_retention_period_days",
	4: "webhooks",
}

// Decode decodes PatchConvAISettingsRequest from json.
func (s *PatchConvAISettingsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchConvAISettingsRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_use_mcp_servers":
			if err := func() error {
				s.CanUseMcpServers.Reset()
				if err := s.CanUseMcpServers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_mcp_servers\"")
			}
		case "conversation_initiation_client_data_webhook":
			if err := func() error {
				s.ConversationInitiationClientDataWebhook.Reset()
				if err := s.ConversationInitiationClientDataWebhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_initiation_client_data_webhook\"")
			}
		case "default_livekit_stack":
			if err := func() error {
				s.DefaultLivekitStack.Reset()
				if err := s.DefaultLivekitStack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_livekit_stack\"")
			}
		case "rag_retention_period_days":
			if err := func() error {
				s.RagRetentionPeriodDays.Reset()
				if err := s.RagRetentionPeriodDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_retention_period_days\"")
			}
		case "webhooks":
			if err := func() error {
				s.Webhooks.Reset()
				if err := s.Webhooks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchConvAISettingsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchConvAISettingsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchConvAISettingsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchWorkspaceSecretRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchWorkspaceSecretRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPatchWorkspaceSecretRequest = [3]string{
	0: "name",
	1: "type",
	2: "value",
}

// Decode decodes PatchWorkspaceSecretRequest from json.
func (s *PatchWorkspaceSecretRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchWorkspaceSecretRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchWorkspaceSecretRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPatchWorkspaceSecretRequest) {
					name = jsonFieldsNameOfPatchWorkspaceSecretRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchWorkspaceSecretRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchWorkspaceSecretRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchWorkspaceSecretRequestType as json.
func (s PatchWorkspaceSecretRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PatchWorkspaceSecretRequestType from json.
func (s *PatchWorkspaceSecretRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchWorkspaceSecretRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PatchWorkspaceSecretRequestType(v) {
	case PatchWorkspaceSecretRequestTypeUpdate:
		*s = PatchWorkspaceSecretRequestTypeUpdate
	default:
		*s = PatchWorkspaceSecretRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PatchWorkspaceSecretRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchWorkspaceSecretRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchWorkspaceWebhookResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchWorkspaceWebhookResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfPatchWorkspaceWebhookResponseModel = [1]string{
	0: "status",
}

// Decode decodes PatchWorkspaceWebhookResponseModel from json.
func (s *PatchWorkspaceWebhookResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchWorkspaceWebhookResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchWorkspaceWebhookResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPatchWorkspaceWebhookResponseModel) {
					name = jsonFieldsNameOfPatchWorkspaceWebhookResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchWorkspaceWebhookResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchWorkspaceWebhookResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PdfExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PdfExportOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		if s.IncludeSpeakers.Set {
			e.FieldStart("include_speakers")
			s.IncludeSpeakers.Encode(e)
		}
	}
	{
		if s.IncludeTimestamps.Set {
			e.FieldStart("include_timestamps")
			s.IncludeTimestamps.Encode(e)
		}
	}
	{
		if s.MaxSegmentChars.Set {
			e.FieldStart("max_segment_chars")
			s.MaxSegmentChars.Encode(e)
		}
	}
	{
		if s.MaxSegmentDurationS.Set {
			e.FieldStart("max_segment_duration_s")
			s.MaxSegmentDurationS.Encode(e)
		}
	}
	{
		if s.SegmentOnSilenceLongerThanS.Set {
			e.FieldStart("segment_on_silence_longer_than_s")
			s.SegmentOnSilenceLongerThanS.Encode(e)
		}
	}
}

var jsonFieldsNameOfPdfExportOptions = [6]string{
	0: "format",
	1: "include_speakers",
	2: "include_timestamps",
	3: "max_segment_chars",
	4: "max_segment_duration_s",
	5: "segment_on_silence_longer_than_s",
}

// Decode decodes PdfExportOptions from json.
func (s *PdfExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PdfExportOptions to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "include_speakers":
			if err := func() error {
				s.IncludeSpeakers.Reset()
				if err := s.IncludeSpeakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_speakers\"")
			}
		case "include_timestamps":
			if err := func() error {
				s.IncludeTimestamps.Reset()
				if err := s.IncludeTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_timestamps\"")
			}
		case "max_segment_chars":
			if err := func() error {
				s.MaxSegmentChars.Reset()
				if err := s.MaxSegmentChars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_chars\"")
			}
		case "max_segment_duration_s":
			if err := func() error {
				s.MaxSegmentDurationS.Reset()
				if err := s.MaxSegmentDurationS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_duration_s\"")
			}
		case "segment_on_silence_longer_than_s":
			if err := func() error {
				s.SegmentOnSilenceLongerThanS.Reset()
				if err := s.SegmentOnSilenceLongerThanS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_on_silence_longer_than_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PdfExportOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPdfExportOptions) {
					name = jsonFieldsNameOfPdfExportOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PdfExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PdfExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PdfExportOptionsFormat as json.
func (s PdfExportOptionsFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PdfExportOptionsFormat from json.
func (s *PdfExportOptionsFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PdfExportOptionsFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PdfExportOptionsFormat(v) {
	case PdfExportOptionsFormatPdf:
		*s = PdfExportOptionsFormatPdf
	default:
		*s = PdfExportOptionsFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PdfExportOptionsFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PdfExportOptionsFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PhoneNumberAgentInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PhoneNumberAgentInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("agent_name")
		e.Str(s.AgentName)
	}
}

var jsonFieldsNameOfPhoneNumberAgentInfo = [2]string{
	0: "agent_id",
	1: "agent_name",
}

// Decode decodes PhoneNumberAgentInfo from json.
func (s *PhoneNumberAgentInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PhoneNumberAgentInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AgentName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PhoneNumberAgentInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPhoneNumberAgentInfo) {
					name = jsonFieldsNameOfPhoneNumberAgentInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PhoneNumberAgentInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PhoneNumberAgentInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayDTMFResultErrorModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayDTMFResultErrorModel) encodeFields(e *jx.Encoder) {
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayDTMFResultErrorModel = [4]string{
	0: "details",
	1: "error",
	2: "result_type",
	3: "status",
}

// Decode decodes PlayDTMFResultErrorModel from json.
func (s *PlayDTMFResultErrorModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayDTMFResultErrorModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayDTMFResultErrorModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayDTMFResultErrorModel) {
					name = jsonFieldsNameOfPlayDTMFResultErrorModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayDTMFResultErrorModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayDTMFResultErrorModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultErrorModelResultType as json.
func (s PlayDTMFResultErrorModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayDTMFResultErrorModelResultType from json.
func (s *PlayDTMFResultErrorModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayDTMFResultErrorModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayDTMFResultErrorModelResultType(v) {
	case PlayDTMFResultErrorModelResultTypePlayDtmfError:
		*s = PlayDTMFResultErrorModelResultTypePlayDtmfError
	default:
		*s = PlayDTMFResultErrorModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayDTMFResultErrorModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayDTMFResultErrorModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultErrorModelStatus as json.
func (s PlayDTMFResultErrorModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayDTMFResultErrorModelStatus from json.
func (s *PlayDTMFResultErrorModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayDTMFResultErrorModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayDTMFResultErrorModelStatus(v) {
	case PlayDTMFResultErrorModelStatusError:
		*s = PlayDTMFResultErrorModelStatusError
	default:
		*s = PlayDTMFResultErrorModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayDTMFResultErrorModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayDTMFResultErrorModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlayDTMFResultSuccessModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlayDTMFResultSuccessModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dtmf_tones")
		e.Str(s.DtmfTones)
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlayDTMFResultSuccessModel = [4]string{
	0: "dtmf_tones",
	1: "reason",
	2: "result_type",
	3: "status",
}

// Decode decodes PlayDTMFResultSuccessModel from json.
func (s *PlayDTMFResultSuccessModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayDTMFResultSuccessModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dtmf_tones":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DtmfTones = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dtmf_tones\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlayDTMFResultSuccessModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlayDTMFResultSuccessModel) {
					name = jsonFieldsNameOfPlayDTMFResultSuccessModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlayDTMFResultSuccessModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayDTMFResultSuccessModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultSuccessModelResultType as json.
func (s PlayDTMFResultSuccessModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayDTMFResultSuccessModelResultType from json.
func (s *PlayDTMFResultSuccessModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayDTMFResultSuccessModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayDTMFResultSuccessModelResultType(v) {
	case PlayDTMFResultSuccessModelResultTypePlayDtmfSuccess:
		*s = PlayDTMFResultSuccessModelResultTypePlayDtmfSuccess
	default:
		*s = PlayDTMFResultSuccessModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayDTMFResultSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayDTMFResultSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlayDTMFResultSuccessModelStatus as json.
func (s PlayDTMFResultSuccessModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlayDTMFResultSuccessModelStatus from json.
func (s *PlayDTMFResultSuccessModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlayDTMFResultSuccessModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlayDTMFResultSuccessModelStatus(v) {
	case PlayDTMFResultSuccessModelStatusSuccess:
		*s = PlayDTMFResultSuccessModelStatusSuccess
	default:
		*s = PlayDTMFResultSuccessModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlayDTMFResultSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlayDTMFResultSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostAgentAvatarResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostAgentAvatarResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfPostAgentAvatarResponseModel = [2]string{
	0: "agent_id",
	1: "avatar_url",
}

// Decode decodes PostAgentAvatarResponseModel from json.
func (s *PostAgentAvatarResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostAgentAvatarResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostAgentAvatarResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostAgentAvatarResponseModel) {
					name = jsonFieldsNameOfPostAgentAvatarResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostAgentAvatarResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostAgentAvatarResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostConversationFeedbackRouteOKApplicationJSON as json.
func (s PostConversationFeedbackRouteOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes PostConversationFeedbackRouteOKApplicationJSON from json.
func (s *PostConversationFeedbackRouteOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostConversationFeedbackRouteOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = PostConversationFeedbackRouteOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostConversationFeedbackRouteOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostConversationFeedbackRouteOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostWorkspaceSecretRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostWorkspaceSecretRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfPostWorkspaceSecretRequest = [3]string{
	0: "name",
	1: "type",
	2: "value",
}

// Decode decodes PostWorkspaceSecretRequest from json.
func (s *PostWorkspaceSecretRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostWorkspaceSecretRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostWorkspaceSecretRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostWorkspaceSecretRequest) {
					name = jsonFieldsNameOfPostWorkspaceSecretRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostWorkspaceSecretRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostWorkspaceSecretRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostWorkspaceSecretRequestType as json.
func (s PostWorkspaceSecretRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PostWorkspaceSecretRequestType from json.
func (s *PostWorkspaceSecretRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostWorkspaceSecretRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PostWorkspaceSecretRequestType(v) {
	case PostWorkspaceSecretRequestTypeNew:
		*s = PostWorkspaceSecretRequestTypeNew
	default:
		*s = PostWorkspaceSecretRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostWorkspaceSecretRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostWorkspaceSecretRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostWorkspaceSecretResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostWorkspaceSecretResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secret_id")
		e.Str(s.SecretID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfPostWorkspaceSecretResponseModel = [3]string{
	0: "name",
	1: "secret_id",
	2: "type",
}

// Decode decodes PostWorkspaceSecretResponseModel from json.
func (s *PostWorkspaceSecretResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostWorkspaceSecretResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secret_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SecretID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret_id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostWorkspaceSecretResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostWorkspaceSecretResponseModel) {
					name = jsonFieldsNameOfPostWorkspaceSecretResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostWorkspaceSecretResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostWorkspaceSecretResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostWorkspaceSecretResponseModelType as json.
func (s PostWorkspaceSecretResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PostWorkspaceSecretResponseModelType from json.
func (s *PostWorkspaceSecretResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostWorkspaceSecretResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PostWorkspaceSecretResponseModelType(v) {
	case PostWorkspaceSecretResponseModelTypeStored:
		*s = PostWorkspaceSecretResponseModelTypeStored
	default:
		*s = PostWorkspaceSecretResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostWorkspaceSecretResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostWorkspaceSecretResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectCreationMetaResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectCreationMetaResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("creation_progress")
		e.Float64(s.CreationProgress)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfProjectCreationMetaResponseModel = [3]string{
	0: "creation_progress",
	1: "status",
	2: "type",
}

// Decode decodes ProjectCreationMetaResponseModel from json.
func (s *ProjectCreationMetaResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectCreationMetaResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "creation_progress":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.CreationProgress = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creation_progress\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectCreationMetaResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectCreationMetaResponseModel) {
					name = jsonFieldsNameOfProjectCreationMetaResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectCreationMetaResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectCreationMetaResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectCreationMetaResponseModelStatus as json.
func (s ProjectCreationMetaResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectCreationMetaResponseModelStatus from json.
func (s *ProjectCreationMetaResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectCreationMetaResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectCreationMetaResponseModelStatus(v) {
	case ProjectCreationMetaResponseModelStatusPending:
		*s = ProjectCreationMetaResponseModelStatusPending
	case ProjectCreationMetaResponseModelStatusCreating:
		*s = ProjectCreationMetaResponseModelStatusCreating
	case ProjectCreationMetaResponseModelStatusFinished:
		*s = ProjectCreationMetaResponseModelStatusFinished
	case ProjectCreationMetaResponseModelStatusFailed:
		*s = ProjectCreationMetaResponseModelStatusFailed
	default:
		*s = ProjectCreationMetaResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectCreationMetaResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectCreationMetaResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectCreationMetaResponseModelType as json.
func (s ProjectCreationMetaResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectCreationMetaResponseModelType from json.
func (s *ProjectCreationMetaResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectCreationMetaResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectCreationMetaResponseModelType(v) {
	case ProjectCreationMetaResponseModelTypeBlank:
		*s = ProjectCreationMetaResponseModelTypeBlank
	case ProjectCreationMetaResponseModelTypeGeneratePodcast:
		*s = ProjectCreationMetaResponseModelTypeGeneratePodcast
	case ProjectCreationMetaResponseModelTypeAutoAssignVoices:
		*s = ProjectCreationMetaResponseModelTypeAutoAssignVoices
	default:
		*s = ProjectCreationMetaResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectCreationMetaResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectCreationMetaResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_level")
		s.AccessLevel.Encode(e)
	}
	{
		if s.AspectRatio.Set {
			e.FieldStart("aspect_ratio")
			s.AspectRatio.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		e.FieldStart("can_be_downloaded")
		e.Bool(s.CanBeDownloaded)
	}
	{
		if s.CaptionStyle.Set {
			e.FieldStart("caption_style")
			s.CaptionStyle.Encode(e)
		}
	}
	{
		if s.CaptionsEnabled.Set {
			e.FieldStart("captions_enabled")
			s.CaptionsEnabled.Encode(e)
		}
	}
	{
		if s.ChaptersEnabled.Set {
			e.FieldStart("chapters_enabled")
			s.ChaptersEnabled.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("content_type")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.CoverImageURL.Set {
			e.FieldStart("cover_image_url")
			s.CoverImageURL.Encode(e)
		}
	}
	{
		e.FieldStart("create_date_unix")
		e.Int(s.CreateDateUnix)
	}
	{
		e.FieldStart("created_by_user_id")
		s.CreatedByUserID.Encode(e)
	}
	{
		if s.CreationMeta.Set {
			e.FieldStart("creation_meta")
			s.CreationMeta.Encode(e)
		}
	}
	{
		e.FieldStart("default_model_id")
		e.Str(s.DefaultModelID)
	}
	{
		e.FieldStart("default_paragraph_voice_id")
		e.Str(s.DefaultParagraphVoiceID)
	}
	{
		e.FieldStart("default_title_voice_id")
		e.Str(s.DefaultTitleVoiceID)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Fiction.Set {
			e.FieldStart("fiction")
			s.Fiction.Encode(e)
		}
	}
	{
		if s.Genres.Set {
			e.FieldStart("genres")
			s.Genres.Encode(e)
		}
	}
	{
		if s.IsbnNumber.Set {
			e.FieldStart("isbn_number")
			s.IsbnNumber.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.LastConversionDateUnix.Set {
			e.FieldStart("last_conversion_date_unix")
			s.LastConversionDateUnix.Encode(e)
		}
	}
	{
		if s.MatureContent.Set {
			e.FieldStart("mature_content")
			s.MatureContent.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.OriginalPublicationDate.Set {
			e.FieldStart("original_publication_date")
			s.OriginalPublicationDate.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		if s.PublicShareID.Set {
			e.FieldStart("public_share_id")
			s.PublicShareID.Encode(e)
		}
	}
	{
		e.FieldStart("quality_check_on")
		e.Bool(s.QualityCheckOn)
	}
	{
		e.FieldStart("quality_check_on_when_bulk_convert")
		e.Bool(s.QualityCheckOnWhenBulkConvert)
	}
	{
		if s.SourceType.Set {
			e.FieldStart("source_type")
			s.SourceType.Encode(e)
		}
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.TargetAudience.Set {
			e.FieldStart("target_audience")
			s.TargetAudience.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		e.FieldStart("volume_normalization")
		e.Bool(s.VolumeNormalization)
	}
}

var jsonFieldsNameOfProjectResponseModel = [33]string{
	0:  "access_level",
	1:  "aspect_ratio",
	2:  "author",
	3:  "can_be_downloaded",
	4:  "caption_style",
	5:  "captions_enabled",
	6:  "chapters_enabled",
	7:  "content_type",
	8:  "cover_image_url",
	9:  "create_date_unix",
	10: "created_by_user_id",
	11: "creation_meta",
	12: "default_model_id",
	13: "default_paragraph_voice_id",
	14: "default_title_voice_id",
	15: "description",
	16: "fiction",
	17: "genres",
	18: "isbn_number",
	19: "language",
	20: "last_conversion_date_unix",
	21: "mature_content",
	22: "name",
	23: "original_publication_date",
	24: "project_id",
	25: "public_share_id",
	26: "quality_check_on",
	27: "quality_check_on_when_bulk_convert",
	28: "source_type",
	29: "state",
	30: "target_audience",
	31: "title",
	32: "volume_normalization",
}

// Decode decodes ProjectResponseModel from json.
func (s *ProjectResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModel to nil")
	}
	var requiredBitSet [5]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_level\"")
			}
		case "aspect_ratio":
			if err := func() error {
				s.AspectRatio.Reset()
				if err := s.AspectRatio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aspect_ratio\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "can_be_downloaded":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanBeDownloaded = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_be_downloaded\"")
			}
		case "caption_style":
			if err := func() error {
				s.CaptionStyle.Reset()
				if err := s.CaptionStyle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caption_style\"")
			}
		case "captions_enabled":
			if err := func() error {
				s.CaptionsEnabled.Reset()
				if err := s.CaptionsEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"captions_enabled\"")
			}
		case "chapters_enabled":
			if err := func() error {
				s.ChaptersEnabled.Reset()
				if err := s.ChaptersEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chapters_enabled\"")
			}
		case "content_type":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "cover_image_url":
			if err := func() error {
				s.CoverImageURL.Reset()
				if err := s.CoverImageURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cover_image_url\"")
			}
		case "create_date_unix":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreateDateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_date_unix\"")
			}
		case "created_by_user_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.CreatedByUserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by_user_id\"")
			}
		case "creation_meta":
			if err := func() error {
				s.CreationMeta.Reset()
				if err := s.CreationMeta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creation_meta\"")
			}
		case "default_model_id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DefaultModelID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_model_id\"")
			}
		case "default_paragraph_voice_id":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DefaultParagraphVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_paragraph_voice_id\"")
			}
		case "default_title_voice_id":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.DefaultTitleVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_title_voice_id\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "fiction":
			if err := func() error {
				s.Fiction.Reset()
				if err := s.Fiction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fiction\"")
			}
		case "genres":
			if err := func() error {
				s.Genres.Reset()
				if err := s.Genres.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"genres\"")
			}
		case "isbn_number":
			if err := func() error {
				s.IsbnNumber.Reset()
				if err := s.IsbnNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isbn_number\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "last_conversion_date_unix":
			if err := func() error {
				s.LastConversionDateUnix.Reset()
				if err := s.LastConversionDateUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_conversion_date_unix\"")
			}
		case "mature_content":
			if err := func() error {
				s.MatureContent.Reset()
				if err := s.MatureContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mature_content\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "original_publication_date":
			if err := func() error {
				s.OriginalPublicationDate.Reset()
				if err := s.OriginalPublicationDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_publication_date\"")
			}
		case "project_id":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "public_share_id":
			if err := func() error {
				s.PublicShareID.Reset()
				if err := s.PublicShareID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_share_id\"")
			}
		case "quality_check_on":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.QualityCheckOn = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality_check_on\"")
			}
		case "quality_check_on_when_bulk_convert":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.QualityCheckOnWhenBulkConvert = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality_check_on_when_bulk_convert\"")
			}
		case "source_type":
			if err := func() error {
				s.SourceType.Reset()
				if err := s.SourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_type\"")
			}
		case "state":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "target_audience":
			if err := func() error {
				s.TargetAudience.Reset()
				if err := s.TargetAudience.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_audience\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "volume_normalization":
			requiredBitSet[4] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.VolumeNormalization = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_normalization\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00001001,
		0b01110110,
		0b01000000,
		0b00101101,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectResponseModel) {
					name = jsonFieldsNameOfProjectResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelAccessLevel as json.
func (s ProjectResponseModelAccessLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResponseModelAccessLevel from json.
func (s *ProjectResponseModelAccessLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModelAccessLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResponseModelAccessLevel(v) {
	case ProjectResponseModelAccessLevelAdmin:
		*s = ProjectResponseModelAccessLevelAdmin
	case ProjectResponseModelAccessLevelEditor:
		*s = ProjectResponseModelAccessLevelEditor
	case ProjectResponseModelAccessLevelCommenter:
		*s = ProjectResponseModelAccessLevelCommenter
	case ProjectResponseModelAccessLevelViewer:
		*s = ProjectResponseModelAccessLevelViewer
	default:
		*s = ProjectResponseModelAccessLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResponseModelAccessLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModelAccessLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelAspectRatio as json.
func (s ProjectResponseModelAspectRatio) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResponseModelAspectRatio from json.
func (s *ProjectResponseModelAspectRatio) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModelAspectRatio to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResponseModelAspectRatio(v) {
	case ProjectResponseModelAspectRatio169:
		*s = ProjectResponseModelAspectRatio169
	case ProjectResponseModelAspectRatio916:
		*s = ProjectResponseModelAspectRatio916
	case ProjectResponseModelAspectRatio45:
		*s = ProjectResponseModelAspectRatio45
	case ProjectResponseModelAspectRatio11:
		*s = ProjectResponseModelAspectRatio11
	default:
		*s = ProjectResponseModelAspectRatio(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResponseModelAspectRatio) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModelAspectRatio) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelFiction as json.
func (s ProjectResponseModelFiction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResponseModelFiction from json.
func (s *ProjectResponseModelFiction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModelFiction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResponseModelFiction(v) {
	case ProjectResponseModelFictionFiction:
		*s = ProjectResponseModelFictionFiction
	case ProjectResponseModelFictionNonFiction:
		*s = ProjectResponseModelFictionNonFiction
	default:
		*s = ProjectResponseModelFiction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResponseModelFiction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModelFiction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelSourceType as json.
func (s ProjectResponseModelSourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResponseModelSourceType from json.
func (s *ProjectResponseModelSourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModelSourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResponseModelSourceType(v) {
	case ProjectResponseModelSourceTypeBlank:
		*s = ProjectResponseModelSourceTypeBlank
	case ProjectResponseModelSourceTypeBook:
		*s = ProjectResponseModelSourceTypeBook
	case ProjectResponseModelSourceTypeArticle:
		*s = ProjectResponseModelSourceTypeArticle
	case ProjectResponseModelSourceTypeGenfm:
		*s = ProjectResponseModelSourceTypeGenfm
	case ProjectResponseModelSourceTypeVideo:
		*s = ProjectResponseModelSourceTypeVideo
	case ProjectResponseModelSourceTypeScreenplay:
		*s = ProjectResponseModelSourceTypeScreenplay
	default:
		*s = ProjectResponseModelSourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResponseModelSourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModelSourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelState as json.
func (s ProjectResponseModelState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResponseModelState from json.
func (s *ProjectResponseModelState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModelState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResponseModelState(v) {
	case ProjectResponseModelStateCreating:
		*s = ProjectResponseModelStateCreating
	case ProjectResponseModelStateDefault:
		*s = ProjectResponseModelStateDefault
	case ProjectResponseModelStateConverting:
		*s = ProjectResponseModelStateConverting
	case ProjectResponseModelStateInQueue:
		*s = ProjectResponseModelStateInQueue
	default:
		*s = ProjectResponseModelState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResponseModelState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModelState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResponseModelTargetAudience as json.
func (s ProjectResponseModelTargetAudience) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResponseModelTargetAudience from json.
func (s *ProjectResponseModelTargetAudience) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResponseModelTargetAudience to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResponseModelTargetAudience(v) {
	case ProjectResponseModelTargetAudienceChildren:
		*s = ProjectResponseModelTargetAudienceChildren
	case ProjectResponseModelTargetAudienceYoungAdult:
		*s = ProjectResponseModelTargetAudienceYoungAdult
	case ProjectResponseModelTargetAudienceAdult:
		*s = ProjectResponseModelTargetAudienceAdult
	case ProjectResponseModelTargetAudienceAllAges:
		*s = ProjectResponseModelTargetAudienceAllAges
	default:
		*s = ProjectResponseModelTargetAudience(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResponseModelTargetAudience) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResponseModelTargetAudience) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotExtendedResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotExtendedResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audio_duration_secs")
		e.Float64(s.AudioDurationSecs)
	}
	{
		if s.AudioUpload.Set {
			e.FieldStart("audio_upload")
			s.AudioUpload.Encode(e)
		}
	}
	{
		e.FieldStart("character_alignments")
		e.ArrStart()
		for _, elem := range s.CharacterAlignments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("project_snapshot_id")
		e.Str(s.ProjectSnapshotID)
	}
	{
		if s.ZipUpload.Set {
			e.FieldStart("zip_upload")
			s.ZipUpload.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectSnapshotExtendedResponseModel = [8]string{
	0: "audio_duration_secs",
	1: "audio_upload",
	2: "character_alignments",
	3: "created_at_unix",
	4: "name",
	5: "project_id",
	6: "project_snapshot_id",
	7: "zip_upload",
}

// Decode decodes ProjectSnapshotExtendedResponseModel from json.
func (s *ProjectSnapshotExtendedResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotExtendedResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_duration_secs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AudioDurationSecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_duration_secs\"")
			}
		case "audio_upload":
			if err := func() error {
				s.AudioUpload.Reset()
				if err := s.AudioUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_upload\"")
			}
		case "character_alignments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.CharacterAlignments = make([]CharacterAlignmentModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CharacterAlignmentModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CharacterAlignments = append(s.CharacterAlignments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_alignments\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "project_snapshot_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ProjectSnapshotID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_snapshot_id\"")
			}
		case "zip_upload":
			if err := func() error {
				s.ZipUpload.Reset()
				if err := s.ZipUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zip_upload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotExtendedResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectSnapshotExtendedResponseModel) {
					name = jsonFieldsNameOfProjectSnapshotExtendedResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotExtendedResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotExtendedResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotExtendedResponseModelAudioUpload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotExtendedResponseModelAudioUpload) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProjectSnapshotExtendedResponseModelAudioUpload = [0]string{}

// Decode decodes ProjectSnapshotExtendedResponseModelAudioUpload from json.
func (s *ProjectSnapshotExtendedResponseModelAudioUpload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotExtendedResponseModelAudioUpload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotExtendedResponseModelAudioUpload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotExtendedResponseModelAudioUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotExtendedResponseModelAudioUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotExtendedResponseModelZipUpload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotExtendedResponseModelZipUpload) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProjectSnapshotExtendedResponseModelZipUpload = [0]string{}

// Decode decodes ProjectSnapshotExtendedResponseModelZipUpload from json.
func (s *ProjectSnapshotExtendedResponseModelZipUpload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotExtendedResponseModelZipUpload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotExtendedResponseModelZipUpload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotExtendedResponseModelZipUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotExtendedResponseModelZipUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AudioUpload.Set {
			e.FieldStart("audio_upload")
			s.AudioUpload.Encode(e)
		}
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("project_snapshot_id")
		e.Str(s.ProjectSnapshotID)
	}
	{
		if s.ZipUpload.Set {
			e.FieldStart("zip_upload")
			s.ZipUpload.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectSnapshotResponseModel = [6]string{
	0: "audio_upload",
	1: "created_at_unix",
	2: "name",
	3: "project_id",
	4: "project_snapshot_id",
	5: "zip_upload",
}

// Decode decodes ProjectSnapshotResponseModel from json.
func (s *ProjectSnapshotResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_upload":
			if err := func() error {
				s.AudioUpload.Reset()
				if err := s.AudioUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_upload\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "project_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "project_snapshot_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProjectSnapshotID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_snapshot_id\"")
			}
		case "zip_upload":
			if err := func() error {
				s.ZipUpload.Reset()
				if err := s.ZipUpload.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zip_upload\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectSnapshotResponseModel) {
					name = jsonFieldsNameOfProjectSnapshotResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotResponseModelAudioUpload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotResponseModelAudioUpload) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProjectSnapshotResponseModelAudioUpload = [0]string{}

// Decode decodes ProjectSnapshotResponseModelAudioUpload from json.
func (s *ProjectSnapshotResponseModelAudioUpload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotResponseModelAudioUpload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotResponseModelAudioUpload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotResponseModelAudioUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotResponseModelAudioUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotResponseModelZipUpload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotResponseModelZipUpload) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfProjectSnapshotResponseModelZipUpload = [0]string{}

// Decode decodes ProjectSnapshotResponseModelZipUpload from json.
func (s *ProjectSnapshotResponseModelZipUpload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotResponseModelZipUpload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotResponseModelZipUpload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotResponseModelZipUpload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotResponseModelZipUpload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectSnapshotsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectSnapshotsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("snapshots")
		e.ArrStart()
		for _, elem := range s.Snapshots {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfProjectSnapshotsResponseModel = [1]string{
	0: "snapshots",
}

// Decode decodes ProjectSnapshotsResponseModel from json.
func (s *ProjectSnapshotsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectSnapshotsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "snapshots":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Snapshots = make([]ProjectSnapshotResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectSnapshotResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snapshots = append(s.Snapshots, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snapshots\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectSnapshotsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectSnapshotsResponseModel) {
					name = jsonFieldsNameOfProjectSnapshotsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectSnapshotsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectSnapshotsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromptAgentAPIModelOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromptAgentAPIModelOverride) encodeFields(e *jx.Encoder) {
	{
		if s.Llm.Set {
			e.FieldStart("llm")
			s.Llm.Encode(e)
		}
	}
	{
		if s.NativeMcpServerIds.Set {
			e.FieldStart("native_mcp_server_ids")
			s.NativeMcpServerIds.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromptAgentAPIModelOverride = [3]string{
	0: "llm",
	1: "native_mcp_server_ids",
	2: "prompt",
}

// Decode decodes PromptAgentAPIModelOverride from json.
func (s *PromptAgentAPIModelOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromptAgentAPIModelOverride to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "llm":
			if err := func() error {
				s.Llm.Reset()
				if err := s.Llm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"llm\"")
			}
		case "native_mcp_server_ids":
			if err := func() error {
				s.NativeMcpServerIds.Reset()
				if err := s.NativeMcpServerIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"native_mcp_server_ids\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromptAgentAPIModelOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromptAgentAPIModelOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromptAgentAPIModelOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PronunciationDictionaryRulesResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PronunciationDictionaryRulesResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("version_id")
		e.Str(s.VersionID)
	}
	{
		e.FieldStart("version_rules_num")
		e.Int(s.VersionRulesNum)
	}
}

var jsonFieldsNameOfPronunciationDictionaryRulesResponseModel = [3]string{
	0: "id",
	1: "version_id",
	2: "version_rules_num",
}

// Decode decodes PronunciationDictionaryRulesResponseModel from json.
func (s *PronunciationDictionaryRulesResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PronunciationDictionaryRulesResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "version_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VersionID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		case "version_rules_num":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.VersionRulesNum = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_rules_num\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PronunciationDictionaryRulesResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPronunciationDictionaryRulesResponseModel) {
					name = jsonFieldsNameOfPronunciationDictionaryRulesResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PronunciationDictionaryRulesResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PronunciationDictionaryRulesResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PronunciationDictionaryVersionLocatorDBModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PronunciationDictionaryVersionLocatorDBModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pronunciation_dictionary_id")
		e.Str(s.PronunciationDictionaryID)
	}
	{
		e.FieldStart("version_id")
		s.VersionID.Encode(e)
	}
}

var jsonFieldsNameOfPronunciationDictionaryVersionLocatorDBModel = [2]string{
	0: "pronunciation_dictionary_id",
	1: "version_id",
}

// Decode decodes PronunciationDictionaryVersionLocatorDBModel from json.
func (s *PronunciationDictionaryVersionLocatorDBModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PronunciationDictionaryVersionLocatorDBModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pronunciation_dictionary_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PronunciationDictionaryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_id\"")
			}
		case "version_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.VersionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PronunciationDictionaryVersionLocatorDBModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPronunciationDictionaryVersionLocatorDBModel) {
					name = jsonFieldsNameOfPronunciationDictionaryVersionLocatorDBModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PronunciationDictionaryVersionLocatorDBModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PronunciationDictionaryVersionLocatorDBModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PronunciationDictionaryVersionLocatorRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PronunciationDictionaryVersionLocatorRequestModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pronunciation_dictionary_id")
		e.Str(s.PronunciationDictionaryID)
	}
	{
		if s.VersionID.Set {
			e.FieldStart("version_id")
			s.VersionID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPronunciationDictionaryVersionLocatorRequestModel = [2]string{
	0: "pronunciation_dictionary_id",
	1: "version_id",
}

// Decode decodes PronunciationDictionaryVersionLocatorRequestModel from json.
func (s *PronunciationDictionaryVersionLocatorRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PronunciationDictionaryVersionLocatorRequestModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pronunciation_dictionary_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PronunciationDictionaryID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pronunciation_dictionary_id\"")
			}
		case "version_id":
			if err := func() error {
				s.VersionID.Reset()
				if err := s.VersionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PronunciationDictionaryVersionLocatorRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPronunciationDictionaryVersionLocatorRequestModel) {
					name = jsonFieldsNameOfPronunciationDictionaryVersionLocatorRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PronunciationDictionaryVersionLocatorRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PronunciationDictionaryVersionLocatorRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGDocumentIndexResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGDocumentIndexResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("document_model_index_usage")
		s.DocumentModelIndexUsage.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("model")
		s.Model.Encode(e)
	}
	{
		e.FieldStart("progress_percentage")
		e.Float64(s.ProgressPercentage)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfRAGDocumentIndexResponseModel = [5]string{
	0: "document_model_index_usage",
	1: "id",
	2: "model",
	3: "progress_percentage",
	4: "status",
}

// Decode decodes RAGDocumentIndexResponseModel from json.
func (s *RAGDocumentIndexResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGDocumentIndexResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "document_model_index_usage":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DocumentModelIndexUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_model_index_usage\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "model":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "progress_percentage":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.ProgressPercentage = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress_percentage\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGDocumentIndexResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGDocumentIndexResponseModel) {
					name = jsonFieldsNameOfRAGDocumentIndexResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGDocumentIndexResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGDocumentIndexResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGDocumentIndexUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGDocumentIndexUsage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("used_bytes")
		e.Int(s.UsedBytes)
	}
}

var jsonFieldsNameOfRAGDocumentIndexUsage = [1]string{
	0: "used_bytes",
}

// Decode decodes RAGDocumentIndexUsage from json.
func (s *RAGDocumentIndexUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGDocumentIndexUsage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "used_bytes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.UsedBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used_bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGDocumentIndexUsage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGDocumentIndexUsage) {
					name = jsonFieldsNameOfRAGDocumentIndexUsage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGDocumentIndexUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGDocumentIndexUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGDocumentIndexesResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGDocumentIndexesResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("indexes")
		e.ArrStart()
		for _, elem := range s.Indexes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRAGDocumentIndexesResponseModel = [1]string{
	0: "indexes",
}

// Decode decodes RAGDocumentIndexesResponseModel from json.
func (s *RAGDocumentIndexesResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGDocumentIndexesResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "indexes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Indexes = make([]RAGDocumentIndexResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RAGDocumentIndexResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Indexes = append(s.Indexes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGDocumentIndexesResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGDocumentIndexesResponseModel) {
					name = jsonFieldsNameOfRAGDocumentIndexesResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGDocumentIndexesResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGDocumentIndexesResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGIndexBatchSuccessfulResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGIndexBatchSuccessfulResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		s.Data.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
}

var jsonFieldsNameOfRAGIndexBatchSuccessfulResponseModel = [2]string{
	0: "data",
	1: "status",
}

// Decode decodes RAGIndexBatchSuccessfulResponseModel from json.
func (s *RAGIndexBatchSuccessfulResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGIndexBatchSuccessfulResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGIndexBatchSuccessfulResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGIndexBatchSuccessfulResponseModel) {
					name = jsonFieldsNameOfRAGIndexBatchSuccessfulResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGIndexBatchSuccessfulResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGIndexBatchSuccessfulResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RAGIndexBatchSuccessfulResponseModelStatus as json.
func (s RAGIndexBatchSuccessfulResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RAGIndexBatchSuccessfulResponseModelStatus from json.
func (s *RAGIndexBatchSuccessfulResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGIndexBatchSuccessfulResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RAGIndexBatchSuccessfulResponseModelStatus(v) {
	case RAGIndexBatchSuccessfulResponseModelStatusSuccess:
		*s = RAGIndexBatchSuccessfulResponseModelStatusSuccess
	default:
		*s = RAGIndexBatchSuccessfulResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RAGIndexBatchSuccessfulResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGIndexBatchSuccessfulResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGIndexOverviewEmbeddingModelResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGIndexOverviewEmbeddingModelResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		s.Model.Encode(e)
	}
	{
		e.FieldStart("used_bytes")
		e.Int(s.UsedBytes)
	}
}

var jsonFieldsNameOfRAGIndexOverviewEmbeddingModelResponseModel = [2]string{
	0: "model",
	1: "used_bytes",
}

// Decode decodes RAGIndexOverviewEmbeddingModelResponseModel from json.
func (s *RAGIndexOverviewEmbeddingModelResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGIndexOverviewEmbeddingModelResponseModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		case "used_bytes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.UsedBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used_bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGIndexOverviewEmbeddingModelResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGIndexOverviewEmbeddingModelResponseModel) {
					name = jsonFieldsNameOfRAGIndexOverviewEmbeddingModelResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGIndexOverviewEmbeddingModelResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGIndexOverviewEmbeddingModelResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGIndexOverviewResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGIndexOverviewResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("models")
		e.ArrStart()
		for _, elem := range s.Models {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total_max_bytes")
		e.Int(s.TotalMaxBytes)
	}
	{
		e.FieldStart("total_used_bytes")
		e.Int(s.TotalUsedBytes)
	}
}

var jsonFieldsNameOfRAGIndexOverviewResponseModel = [3]string{
	0: "models",
	1: "total_max_bytes",
	2: "total_used_bytes",
}

// Decode decodes RAGIndexOverviewResponseModel from json.
func (s *RAGIndexOverviewResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGIndexOverviewResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "models":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Models = make([]RAGIndexOverviewEmbeddingModelResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RAGIndexOverviewEmbeddingModelResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Models = append(s.Models, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"models\"")
			}
		case "total_max_bytes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TotalMaxBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_max_bytes\"")
			}
		case "total_used_bytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.TotalUsedBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_used_bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGIndexOverviewResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGIndexOverviewResponseModel) {
					name = jsonFieldsNameOfRAGIndexOverviewResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGIndexOverviewResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGIndexOverviewResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RAGIndexRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RAGIndexRequestModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("model")
		s.Model.Encode(e)
	}
}

var jsonFieldsNameOfRAGIndexRequestModel = [1]string{
	0: "model",
}

// Decode decodes RAGIndexRequestModel from json.
func (s *RAGIndexRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGIndexRequestModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "model":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Model.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RAGIndexRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRAGIndexRequestModel) {
					name = jsonFieldsNameOfRAGIndexRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RAGIndexRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGIndexRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RAGIndexStatus as json.
func (s RAGIndexStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RAGIndexStatus from json.
func (s *RAGIndexStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RAGIndexStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RAGIndexStatus(v) {
	case RAGIndexStatusCreated:
		*s = RAGIndexStatusCreated
	case RAGIndexStatusProcessing:
		*s = RAGIndexStatusProcessing
	case RAGIndexStatusFailed:
		*s = RAGIndexStatusFailed
	case RAGIndexStatusSucceeded:
		*s = RAGIndexStatusSucceeded
	case RAGIndexStatusRagLimitExceeded:
		*s = RAGIndexStatusRagLimitExceeded
	case RAGIndexStatusDocumentTooSmall:
		*s = RAGIndexStatusDocumentTooSmall
	case RAGIndexStatusCannotIndexFolder:
		*s = RAGIndexStatusCannotIndexFolder
	default:
		*s = RAGIndexStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RAGIndexStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RAGIndexStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RagChunkMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RagChunkMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chunk_id")
		e.Str(s.ChunkID)
	}
	{
		e.FieldStart("document_id")
		e.Str(s.DocumentID)
	}
	{
		e.FieldStart("vector_distance")
		e.Float64(s.VectorDistance)
	}
}

var jsonFieldsNameOfRagChunkMetadata = [3]string{
	0: "chunk_id",
	1: "document_id",
	2: "vector_distance",
}

// Decode decodes RagChunkMetadata from json.
func (s *RagChunkMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RagChunkMetadata to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chunk_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ChunkID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chunk_id\"")
			}
		case "document_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DocumentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document_id\"")
			}
		case "vector_distance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.VectorDistance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vector_distance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RagChunkMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRagChunkMetadata) {
					name = jsonFieldsNameOfRagChunkMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RagChunkMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RagChunkMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RagRetrievalInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RagRetrievalInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chunks")
		e.ArrStart()
		for _, elem := range s.Chunks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("embedding_model")
		s.EmbeddingModel.Encode(e)
	}
	{
		e.FieldStart("rag_latency_secs")
		e.Float64(s.RagLatencySecs)
	}
	{
		e.FieldStart("retrieval_query")
		e.Str(s.RetrievalQuery)
	}
}

var jsonFieldsNameOfRagRetrievalInfo = [4]string{
	0: "chunks",
	1: "embedding_model",
	2: "rag_latency_secs",
	3: "retrieval_query",
}

// Decode decodes RagRetrievalInfo from json.
func (s *RagRetrievalInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RagRetrievalInfo to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chunks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Chunks = make([]RagChunkMetadata, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RagChunkMetadata
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Chunks = append(s.Chunks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chunks\"")
			}
		case "embedding_model":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.EmbeddingModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"embedding_model\"")
			}
		case "rag_latency_secs":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.RagLatencySecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rag_latency_secs\"")
			}
		case "retrieval_query":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.RetrievalQuery = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retrieval_query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RagRetrievalInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRagRetrievalInfo) {
					name = jsonFieldsNameOfRagRetrievalInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RagRetrievalInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RagRetrievalInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReaderResourceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReaderResourceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("resource_id")
		e.Str(s.ResourceID)
	}
	{
		e.FieldStart("resource_type")
		s.ResourceType.Encode(e)
	}
}

var jsonFieldsNameOfReaderResourceResponseModel = [2]string{
	0: "resource_id",
	1: "resource_type",
}

// Decode decodes ReaderResourceResponseModel from json.
func (s *ReaderResourceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReaderResourceResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ResourceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_id\"")
			}
		case "resource_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReaderResourceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReaderResourceResponseModel) {
					name = jsonFieldsNameOfReaderResourceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReaderResourceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReaderResourceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReaderResourceResponseModelResourceType as json.
func (s ReaderResourceResponseModelResourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReaderResourceResponseModelResourceType from json.
func (s *ReaderResourceResponseModelResourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReaderResourceResponseModelResourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReaderResourceResponseModelResourceType(v) {
	case ReaderResourceResponseModelResourceTypeRead:
		*s = ReaderResourceResponseModelResourceTypeRead
	case ReaderResourceResponseModelResourceTypeCollection:
		*s = ReaderResourceResponseModelResourceTypeCollection
	default:
		*s = ReaderResourceResponseModelResourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReaderResourceResponseModelResourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReaderResourceResponseModelResourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RecordingResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RecordingResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		e.FieldStart("recording_id")
		e.Str(s.RecordingID)
	}
	{
		e.FieldStart("size_bytes")
		e.Int(s.SizeBytes)
	}
	{
		e.FieldStart("transcription")
		e.Str(s.Transcription)
	}
	{
		e.FieldStart("upload_date_unix")
		e.Int(s.UploadDateUnix)
	}
}

var jsonFieldsNameOfRecordingResponseModel = [5]string{
	0: "mime_type",
	1: "recording_id",
	2: "size_bytes",
	3: "transcription",
	4: "upload_date_unix",
}

// Decode decodes RecordingResponseModel from json.
func (s *RecordingResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RecordingResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mime_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "recording_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RecordingID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording_id\"")
			}
		case "size_bytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.SizeBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_bytes\"")
			}
		case "transcription":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Transcription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription\"")
			}
		case "upload_date_unix":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.UploadDateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload_date_unix\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RecordingResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecordingResponseModel) {
					name = jsonFieldsNameOfRecordingResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RecordingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RecordingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReferencedToolCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReferencedToolCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfReferencedToolCommonModel = [2]string{
	0: "id",
	1: "type",
}

// Decode decodes ReferencedToolCommonModel from json.
func (s *ReferencedToolCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferencedToolCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReferencedToolCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReferencedToolCommonModel) {
					name = jsonFieldsNameOfReferencedToolCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReferencedToolCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReferencedToolCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReferencedToolCommonModelType as json.
func (s ReferencedToolCommonModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReferencedToolCommonModelType from json.
func (s *ReferencedToolCommonModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReferencedToolCommonModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReferencedToolCommonModelType(v) {
	case ReferencedToolCommonModelTypeSystem:
		*s = ReferencedToolCommonModelTypeSystem
	case ReferencedToolCommonModelTypeWebhook:
		*s = ReferencedToolCommonModelTypeWebhook
	case ReferencedToolCommonModelTypeClient:
		*s = ReferencedToolCommonModelTypeClient
	case ReferencedToolCommonModelTypeWorkflow:
		*s = ReferencedToolCommonModelTypeWorkflow
	case ReferencedToolCommonModelTypeAPIIntegrationWebhook:
		*s = ReferencedToolCommonModelTypeAPIIntegrationWebhook
	default:
		*s = ReferencedToolCommonModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReferencedToolCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReferencedToolCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegexParameterEvaluationStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegexParameterEvaluationStrategy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pattern")
		e.Str(s.Pattern)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfRegexParameterEvaluationStrategy = [2]string{
	0: "pattern",
	1: "type",
}

// Decode decodes RegexParameterEvaluationStrategy from json.
func (s *RegexParameterEvaluationStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegexParameterEvaluationStrategy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pattern":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Pattern = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegexParameterEvaluationStrategy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegexParameterEvaluationStrategy) {
					name = jsonFieldsNameOfRegexParameterEvaluationStrategy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegexParameterEvaluationStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegexParameterEvaluationStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegexParameterEvaluationStrategyType as json.
func (s RegexParameterEvaluationStrategyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RegexParameterEvaluationStrategyType from json.
func (s *RegexParameterEvaluationStrategyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegexParameterEvaluationStrategyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RegexParameterEvaluationStrategyType(v) {
	case RegexParameterEvaluationStrategyTypeRegex:
		*s = RegexParameterEvaluationStrategyTypeRegex
	default:
		*s = RegexParameterEvaluationStrategyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RegexParameterEvaluationStrategyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegexParameterEvaluationStrategyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Render) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Render) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("media_ref")
		s.MediaRef.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfRender = [6]string{
	0: "id",
	1: "language",
	2: "media_ref",
	3: "status",
	4: "type",
	5: "version",
}

// Decode decodes Render from json.
func (s *Render) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Render to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "language":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "media_ref":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.MediaRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_ref\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Render")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRender) {
					name = jsonFieldsNameOfRender[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Render) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Render) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenderStatus as json.
func (s RenderStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RenderStatus from json.
func (s *RenderStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenderStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RenderStatus(v) {
	case RenderStatusComplete:
		*s = RenderStatusComplete
	case RenderStatusProcessing:
		*s = RenderStatusProcessing
	case RenderStatusFailed:
		*s = RenderStatusFailed
	default:
		*s = RenderStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RenderStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenderStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RenderType as json.
func (s RenderType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RenderType from json.
func (s *RenderType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RenderType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RenderType(v) {
	case RenderTypeMP4:
		*s = RenderTypeMP4
	case RenderTypeAac:
		*s = RenderTypeAac
	case RenderTypeMp3:
		*s = RenderTypeMp3
	case RenderTypeWav:
		*s = RenderTypeWav
	case RenderTypeAaf:
		*s = RenderTypeAaf
	case RenderTypeTracksZip:
		*s = RenderTypeTracksZip
	case RenderTypeClipsZip:
		*s = RenderTypeClipsZip
	default:
		*s = RenderType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RenderType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RenderType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestPVCManualVerificationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestPVCManualVerificationResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfRequestPVCManualVerificationResponseModel = [1]string{
	0: "status",
}

// Decode decodes RequestPVCManualVerificationResponseModel from json.
func (s *RequestPVCManualVerificationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestPVCManualVerificationResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestPVCManualVerificationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRequestPVCManualVerificationResponseModel) {
					name = jsonFieldsNameOfRequestPVCManualVerificationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestPVCManualVerificationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestPVCManualVerificationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceAccessInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceAccessInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("creator_email")
		e.Str(s.CreatorEmail)
	}
	{
		e.FieldStart("creator_name")
		e.Str(s.CreatorName)
	}
	{
		e.FieldStart("is_creator")
		e.Bool(s.IsCreator)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
}

var jsonFieldsNameOfResourceAccessInfo = [4]string{
	0: "creator_email",
	1: "creator_name",
	2: "is_creator",
	3: "role",
}

// Decode decodes ResourceAccessInfo from json.
func (s *ResourceAccessInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceAccessInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "creator_email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CreatorEmail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator_email\"")
			}
		case "creator_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CreatorName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator_name\"")
			}
		case "is_creator":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsCreator = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_creator\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceAccessInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceAccessInfo) {
					name = jsonFieldsNameOfResourceAccessInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceAccessInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceAccessInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceAccessInfoRole as json.
func (s ResourceAccessInfoRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceAccessInfoRole from json.
func (s *ResourceAccessInfoRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceAccessInfoRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceAccessInfoRole(v) {
	case ResourceAccessInfoRoleAdmin:
		*s = ResourceAccessInfoRoleAdmin
	case ResourceAccessInfoRoleEditor:
		*s = ResourceAccessInfoRoleEditor
	case ResourceAccessInfoRoleCommenter:
		*s = ResourceAccessInfoRoleCommenter
	case ResourceAccessInfoRoleViewer:
		*s = ResourceAccessInfoRoleViewer
	default:
		*s = ResourceAccessInfoRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceAccessInfoRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceAccessInfoRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceMetadataResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceMetadataResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("anonymous_access_level_override")
		s.AnonymousAccessLevelOverride.Encode(e)
	}
	{
		e.FieldStart("creator_user_id")
		s.CreatorUserID.Encode(e)
	}
	{
		e.FieldStart("resource_id")
		e.Str(s.ResourceID)
	}
	{
		e.FieldStart("resource_type")
		s.ResourceType.Encode(e)
	}
	{
		e.FieldStart("role_to_group_ids")
		s.RoleToGroupIds.Encode(e)
	}
	{
		e.FieldStart("share_options")
		e.ArrStart()
		for _, elem := range s.ShareOptions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfResourceMetadataResponseModel = [6]string{
	0: "anonymous_access_level_override",
	1: "creator_user_id",
	2: "resource_id",
	3: "resource_type",
	4: "role_to_group_ids",
	5: "share_options",
}

// Decode decodes ResourceMetadataResponseModel from json.
func (s *ResourceMetadataResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceMetadataResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "anonymous_access_level_override":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AnonymousAccessLevelOverride.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anonymous_access_level_override\"")
			}
		case "creator_user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.CreatorUserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator_user_id\"")
			}
		case "resource_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ResourceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_id\"")
			}
		case "resource_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ResourceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_type\"")
			}
		case "role_to_group_ids":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.RoleToGroupIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_to_group_ids\"")
			}
		case "share_options":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.ShareOptions = make([]ShareOptionResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ShareOptionResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ShareOptions = append(s.ShareOptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"share_options\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceMetadataResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResourceMetadataResponseModel) {
					name = jsonFieldsNameOfResourceMetadataResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceMetadataResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceMetadataResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceMetadataResponseModelAnonymousAccessLevelOverride as json.
func (s ResourceMetadataResponseModelAnonymousAccessLevelOverride) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResourceMetadataResponseModelAnonymousAccessLevelOverride from json.
func (s *ResourceMetadataResponseModelAnonymousAccessLevelOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceMetadataResponseModelAnonymousAccessLevelOverride to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResourceMetadataResponseModelAnonymousAccessLevelOverride(v) {
	case ResourceMetadataResponseModelAnonymousAccessLevelOverrideAdmin:
		*s = ResourceMetadataResponseModelAnonymousAccessLevelOverrideAdmin
	case ResourceMetadataResponseModelAnonymousAccessLevelOverrideEditor:
		*s = ResourceMetadataResponseModelAnonymousAccessLevelOverrideEditor
	case ResourceMetadataResponseModelAnonymousAccessLevelOverrideCommenter:
		*s = ResourceMetadataResponseModelAnonymousAccessLevelOverrideCommenter
	case ResourceMetadataResponseModelAnonymousAccessLevelOverrideViewer:
		*s = ResourceMetadataResponseModelAnonymousAccessLevelOverrideViewer
	default:
		*s = ResourceMetadataResponseModelAnonymousAccessLevelOverride(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceMetadataResponseModelAnonymousAccessLevelOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceMetadataResponseModelAnonymousAccessLevelOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ResourceMetadataResponseModelRoleToGroupIds) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ResourceMetadataResponseModelRoleToGroupIds) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ResourceMetadataResponseModelRoleToGroupIds from json.
func (s *ResourceMetadataResponseModelRoleToGroupIds) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceMetadataResponseModelRoleToGroupIds to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceMetadataResponseModelRoleToGroupIds")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResourceMetadataResponseModelRoleToGroupIds) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceMetadataResponseModelRoleToGroupIds) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SIPMediaEncryptionEnum as json.
func (s SIPMediaEncryptionEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SIPMediaEncryptionEnum from json.
func (s *SIPMediaEncryptionEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SIPMediaEncryptionEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SIPMediaEncryptionEnum(v) {
	case SIPMediaEncryptionEnumDisabled:
		*s = SIPMediaEncryptionEnumDisabled
	case SIPMediaEncryptionEnumAllowed:
		*s = SIPMediaEncryptionEnumAllowed
	case SIPMediaEncryptionEnumRequired:
		*s = SIPMediaEncryptionEnumRequired
	default:
		*s = SIPMediaEncryptionEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SIPMediaEncryptionEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SIPMediaEncryptionEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SIPTrunkCredentialsRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SIPTrunkCredentialsRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
}

var jsonFieldsNameOfSIPTrunkCredentialsRequestModel = [2]string{
	0: "password",
	1: "username",
}

// Decode decodes SIPTrunkCredentialsRequestModel from json.
func (s *SIPTrunkCredentialsRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SIPTrunkCredentialsRequestModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SIPTrunkCredentialsRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSIPTrunkCredentialsRequestModel) {
					name = jsonFieldsNameOfSIPTrunkCredentialsRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SIPTrunkCredentialsRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SIPTrunkCredentialsRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SIPTrunkOutboundCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SIPTrunkOutboundCallResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conversation_id")
		s.ConversationID.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("sip_call_id")
		s.SipCallID.Encode(e)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfSIPTrunkOutboundCallResponse = [4]string{
	0: "conversation_id",
	1: "message",
	2: "sip_call_id",
	3: "success",
}

// Decode decodes SIPTrunkOutboundCallResponse from json.
func (s *SIPTrunkOutboundCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SIPTrunkOutboundCallResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "sip_call_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SipCallID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sip_call_id\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SIPTrunkOutboundCallResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSIPTrunkOutboundCallResponse) {
					name = jsonFieldsNameOfSIPTrunkOutboundCallResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SIPTrunkOutboundCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SIPTrunkOutboundCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SIPTrunkTransportEnum as json.
func (s SIPTrunkTransportEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SIPTrunkTransportEnum from json.
func (s *SIPTrunkTransportEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SIPTrunkTransportEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SIPTrunkTransportEnum(v) {
	case SIPTrunkTransportEnumAuto:
		*s = SIPTrunkTransportEnumAuto
	case SIPTrunkTransportEnumUDP:
		*s = SIPTrunkTransportEnumUDP
	case SIPTrunkTransportEnumTCP:
		*s = SIPTrunkTransportEnumTCP
	case SIPTrunkTransportEnumTLS:
		*s = SIPTrunkTransportEnumTLS
	default:
		*s = SIPTrunkTransportEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SIPTrunkTransportEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SIPTrunkTransportEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SampleResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SampleResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.DurationSecs.Set {
			e.FieldStart("duration_secs")
			s.DurationSecs.Encode(e)
		}
	}
	{
		e.FieldStart("file_name")
		e.Str(s.FileName)
	}
	{
		if s.HasIsolatedAudio.Set {
			e.FieldStart("has_isolated_audio")
			s.HasIsolatedAudio.Encode(e)
		}
	}
	{
		if s.HasIsolatedAudioPreview.Set {
			e.FieldStart("has_isolated_audio_preview")
			s.HasIsolatedAudioPreview.Encode(e)
		}
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
	{
		e.FieldStart("mime_type")
		e.Str(s.MimeType)
	}
	{
		if s.RemoveBackgroundNoise.Set {
			e.FieldStart("remove_background_noise")
			s.RemoveBackgroundNoise.Encode(e)
		}
	}
	{
		e.FieldStart("sample_id")
		e.Str(s.SampleID)
	}
	{
		e.FieldStart("size_bytes")
		e.Int(s.SizeBytes)
	}
	{
		if s.SpeakerSeparation.Set {
			e.FieldStart("speaker_separation")
			s.SpeakerSeparation.Encode(e)
		}
	}
	{
		if s.TrimEnd.Set {
			e.FieldStart("trim_end")
			s.TrimEnd.Encode(e)
		}
	}
	{
		if s.TrimStart.Set {
			e.FieldStart("trim_start")
			s.TrimStart.Encode(e)
		}
	}
}

var jsonFieldsNameOfSampleResponseModel = [12]string{
	0:  "duration_secs",
	1:  "file_name",
	2:  "has_isolated_audio",
	3:  "has_isolated_audio_preview",
	4:  "hash",
	5:  "mime_type",
	6:  "remove_background_noise",
	7:  "sample_id",
	8:  "size_bytes",
	9:  "speaker_separation",
	10: "trim_end",
	11: "trim_start",
}

// Decode decodes SampleResponseModel from json.
func (s *SampleResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SampleResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_secs":
			if err := func() error {
				s.DurationSecs.Reset()
				if err := s.DurationSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "file_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "has_isolated_audio":
			if err := func() error {
				s.HasIsolatedAudio.Reset()
				if err := s.HasIsolatedAudio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_isolated_audio\"")
			}
		case "has_isolated_audio_preview":
			if err := func() error {
				s.HasIsolatedAudioPreview.Reset()
				if err := s.HasIsolatedAudioPreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_isolated_audio_preview\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		case "mime_type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.MimeType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mime_type\"")
			}
		case "remove_background_noise":
			if err := func() error {
				s.RemoveBackgroundNoise.Reset()
				if err := s.RemoveBackgroundNoise.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_background_noise\"")
			}
		case "sample_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.SampleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_id\"")
			}
		case "size_bytes":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.SizeBytes = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_bytes\"")
			}
		case "speaker_separation":
			if err := func() error {
				s.SpeakerSeparation.Reset()
				if err := s.SpeakerSeparation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_separation\"")
			}
		case "trim_end":
			if err := func() error {
				s.TrimEnd.Reset()
				if err := s.TrimEnd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trim_end\"")
			}
		case "trim_start":
			if err := func() error {
				s.TrimStart.Reset()
				if err := s.TrimStart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trim_start\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SampleResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10110010,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSampleResponseModel) {
					name = jsonFieldsNameOfSampleResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SampleResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SampleResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchGroupsOKApplicationJSON as json.
func (s SearchGroupsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []WorkspaceGroupByNameResponseModel(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes SearchGroupsOKApplicationJSON from json.
func (s *SearchGroupsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchGroupsOKApplicationJSON to nil")
	}
	var unwrapped []WorkspaceGroupByNameResponseModel
	if err := func() error {
		unwrapped = make([]WorkspaceGroupByNameResponseModel, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem WorkspaceGroupByNameResponseModel
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SearchGroupsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchGroupsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchGroupsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretDependencyType as json.
func (s SecretDependencyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecretDependencyType from json.
func (s *SecretDependencyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretDependencyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecretDependencyType(v) {
	case SecretDependencyTypeConversationInitiationWebhook:
		*s = SecretDependencyTypeConversationInitiationWebhook
	default:
		*s = SecretDependencyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretDependencyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretDependencyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SectionSource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SectionSource) encodeFields(e *jx.Encoder) {
	{
		if s.NegativeRanges != nil {
			e.FieldStart("negative_ranges")
			e.ArrStart()
			for _, elem := range s.NegativeRanges {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("range")
		s.Range.Encode(e)
	}
	{
		e.FieldStart("song_id")
		e.Str(s.SongID)
	}
}

var jsonFieldsNameOfSectionSource = [3]string{
	0: "negative_ranges",
	1: "range",
	2: "song_id",
}

// Decode decodes SectionSource from json.
func (s *SectionSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SectionSource to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "negative_ranges":
			if err := func() error {
				s.NegativeRanges = make([]TimeRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TimeRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NegativeRanges = append(s.NegativeRanges, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"negative_ranges\"")
			}
		case "range":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Range.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range\"")
			}
		case "song_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SongID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"song_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SectionSource")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSectionSource) {
					name = jsonFieldsNameOfSectionSource[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SectionSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SectionSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentCreatePayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentCreatePayload) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("end_time")
		e.Float64(s.EndTime)
	}
	{
		e.FieldStart("start_time")
		e.Float64(s.StartTime)
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Translations.Set {
			e.FieldStart("translations")
			s.Translations.Encode(e)
		}
	}
}

var jsonFieldsNameOfSegmentCreatePayload = [4]string{
	0: "end_time",
	1: "start_time",
	2: "text",
	3: "translations",
}

// Decode decodes SegmentCreatePayload from json.
func (s *SegmentCreatePayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentCreatePayload to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.EndTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.StartTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "translations":
			if err := func() error {
				s.Translations.Reset()
				if err := s.Translations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"translations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentCreatePayload")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentCreatePayload) {
					name = jsonFieldsNameOfSegmentCreatePayload[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentCreatePayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentCreatePayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SegmentCreatePayloadTranslations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SegmentCreatePayloadTranslations) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SegmentCreatePayloadTranslations from json.
func (s *SegmentCreatePayloadTranslations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentCreatePayloadTranslations to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentCreatePayloadTranslations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SegmentCreatePayloadTranslations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentCreatePayloadTranslations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentCreateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentCreateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("new_segment")
		e.Str(s.NewSegment)
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentCreateResponse = [2]string{
	0: "new_segment",
	1: "version",
}

// Decode decodes SegmentCreateResponse from json.
func (s *SegmentCreateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentCreateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "new_segment":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NewSegment = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_segment\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentCreateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentCreateResponse) {
					name = jsonFieldsNameOfSegmentCreateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentCreateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentCreateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentDeleteResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentDeleteResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentDeleteResponse = [1]string{
	0: "version",
}

// Decode decodes SegmentDeleteResponse from json.
func (s *SegmentDeleteResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentDeleteResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentDeleteResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentDeleteResponse) {
					name = jsonFieldsNameOfSegmentDeleteResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentDeleteResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentDeleteResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentDubResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentDubResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentDubResponse = [1]string{
	0: "version",
}

// Decode decodes SegmentDubResponse from json.
func (s *SegmentDubResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentDubResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentDubResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentDubResponse) {
					name = jsonFieldsNameOfSegmentDubResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentDubResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentDubResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentMigrationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentMigrationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentMigrationResponse = [1]string{
	0: "version",
}

// Decode decodes SegmentMigrationResponse from json.
func (s *SegmentMigrationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentMigrationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentMigrationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentMigrationResponse) {
					name = jsonFieldsNameOfSegmentMigrationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentMigrationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentMigrationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentSubtitleFrame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentSubtitleFrame) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("end_time")
		e.Float64(s.EndTime)
	}
	{
		e.FieldStart("lines")
		e.ArrStart()
		for _, elem := range s.Lines {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("start_time")
		e.Float64(s.StartTime)
	}
}

var jsonFieldsNameOfSegmentSubtitleFrame = [3]string{
	0: "end_time",
	1: "lines",
	2: "start_time",
}

// Decode decodes SegmentSubtitleFrame from json.
func (s *SegmentSubtitleFrame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentSubtitleFrame to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end_time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.EndTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "lines":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Lines = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Lines = append(s.Lines, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lines\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.StartTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentSubtitleFrame")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentSubtitleFrame) {
					name = jsonFieldsNameOfSegmentSubtitleFrame[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentSubtitleFrame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentSubtitleFrame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentTranscriptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentTranscriptionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentTranscriptionResponse = [1]string{
	0: "version",
}

// Decode decodes SegmentTranscriptionResponse from json.
func (s *SegmentTranscriptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentTranscriptionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentTranscriptionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentTranscriptionResponse) {
					name = jsonFieldsNameOfSegmentTranscriptionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentTranscriptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentTranscriptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentTranslationResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentTranslationResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentTranslationResponse = [1]string{
	0: "version",
}

// Decode decodes SegmentTranslationResponse from json.
func (s *SegmentTranslationResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentTranslationResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentTranslationResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentTranslationResponse) {
					name = jsonFieldsNameOfSegmentTranslationResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentTranslationResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentTranslationResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentUpdatePayload) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentUpdatePayload) encodeFields(e *jx.Encoder) {
	{
		if s.EndTime.Set {
			e.FieldStart("end_time")
			s.EndTime.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("start_time")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfSegmentUpdatePayload = [3]string{
	0: "end_time",
	1: "start_time",
	2: "text",
}

// Decode decodes SegmentUpdatePayload from json.
func (s *SegmentUpdatePayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentUpdatePayload to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end_time":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "start_time":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentUpdatePayload")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentUpdatePayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentUpdatePayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentUpdateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentUpdateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSegmentUpdateResponse = [1]string{
	0: "version",
}

// Decode decodes SegmentUpdateResponse from json.
func (s *SegmentUpdateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentUpdateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentUpdateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentUpdateResponse) {
					name = jsonFieldsNameOfSegmentUpdateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentUpdateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentUpdateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SegmentedJsonExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SegmentedJsonExportOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		if s.IncludeSpeakers.Set {
			e.FieldStart("include_speakers")
			s.IncludeSpeakers.Encode(e)
		}
	}
	{
		if s.IncludeTimestamps.Set {
			e.FieldStart("include_timestamps")
			s.IncludeTimestamps.Encode(e)
		}
	}
	{
		if s.MaxSegmentChars.Set {
			e.FieldStart("max_segment_chars")
			s.MaxSegmentChars.Encode(e)
		}
	}
	{
		if s.MaxSegmentDurationS.Set {
			e.FieldStart("max_segment_duration_s")
			s.MaxSegmentDurationS.Encode(e)
		}
	}
	{
		if s.SegmentOnSilenceLongerThanS.Set {
			e.FieldStart("segment_on_silence_longer_than_s")
			s.SegmentOnSilenceLongerThanS.Encode(e)
		}
	}
}

var jsonFieldsNameOfSegmentedJsonExportOptions = [6]string{
	0: "format",
	1: "include_speakers",
	2: "include_timestamps",
	3: "max_segment_chars",
	4: "max_segment_duration_s",
	5: "segment_on_silence_longer_than_s",
}

// Decode decodes SegmentedJsonExportOptions from json.
func (s *SegmentedJsonExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentedJsonExportOptions to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "include_speakers":
			if err := func() error {
				s.IncludeSpeakers.Reset()
				if err := s.IncludeSpeakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_speakers\"")
			}
		case "include_timestamps":
			if err := func() error {
				s.IncludeTimestamps.Reset()
				if err := s.IncludeTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_timestamps\"")
			}
		case "max_segment_chars":
			if err := func() error {
				s.MaxSegmentChars.Reset()
				if err := s.MaxSegmentChars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_chars\"")
			}
		case "max_segment_duration_s":
			if err := func() error {
				s.MaxSegmentDurationS.Reset()
				if err := s.MaxSegmentDurationS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_duration_s\"")
			}
		case "segment_on_silence_longer_than_s":
			if err := func() error {
				s.SegmentOnSilenceLongerThanS.Reset()
				if err := s.SegmentOnSilenceLongerThanS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_on_silence_longer_than_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SegmentedJsonExportOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSegmentedJsonExportOptions) {
					name = jsonFieldsNameOfSegmentedJsonExportOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SegmentedJsonExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentedJsonExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SegmentedJsonExportOptionsFormat as json.
func (s SegmentedJsonExportOptionsFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SegmentedJsonExportOptionsFormat from json.
func (s *SegmentedJsonExportOptionsFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SegmentedJsonExportOptionsFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SegmentedJsonExportOptionsFormat(v) {
	case SegmentedJsonExportOptionsFormatSegmentedJSON:
		*s = SegmentedJsonExportOptionsFormatSegmentedJSON
	default:
		*s = SegmentedJsonExportOptionsFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SegmentedJsonExportOptionsFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SegmentedJsonExportOptionsFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ShareOptionResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ShareOptionResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfShareOptionResponseModel = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes ShareOptionResponseModel from json.
func (s *ShareOptionResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShareOptionResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ShareOptionResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfShareOptionResponseModel) {
					name = jsonFieldsNameOfShareOptionResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ShareOptionResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShareOptionResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShareOptionResponseModelType as json.
func (s ShareOptionResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ShareOptionResponseModelType from json.
func (s *ShareOptionResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShareOptionResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ShareOptionResponseModelType(v) {
	case ShareOptionResponseModelTypeUser:
		*s = ShareOptionResponseModelTypeUser
	case ShareOptionResponseModelTypeGroup:
		*s = ShareOptionResponseModelTypeGroup
	case ShareOptionResponseModelTypeKey:
		*s = ShareOptionResponseModelTypeKey
	default:
		*s = ShareOptionResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ShareOptionResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShareOptionResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ShareResourceEndpointOKApplicationJSON as json.
func (s ShareResourceEndpointOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ShareResourceEndpointOKApplicationJSON from json.
func (s *ShareResourceEndpointOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ShareResourceEndpointOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ShareResourceEndpointOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ShareResourceEndpointOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ShareResourceEndpointOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimilarVoice) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimilarVoice) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PreviewURL.Set {
			e.FieldStart("preview_url")
			s.PreviewURL.Encode(e)
		}
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfSimilarVoice = [5]string{
	0: "category",
	1: "description",
	2: "name",
	3: "preview_url",
	4: "voice_id",
}

// Decode decodes SimilarVoice from json.
func (s *SimilarVoice) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimilarVoice to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "category":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "preview_url":
			if err := func() error {
				s.PreviewURL.Reset()
				if err := s.PreviewURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preview_url\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimilarVoice")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimilarVoice) {
					name = jsonFieldsNameOfSimilarVoice[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimilarVoice) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimilarVoice) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SimilarVoiceCategory as json.
func (s SimilarVoiceCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SimilarVoiceCategory from json.
func (s *SimilarVoiceCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimilarVoiceCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SimilarVoiceCategory(v) {
	case SimilarVoiceCategoryPremade:
		*s = SimilarVoiceCategoryPremade
	case SimilarVoiceCategoryCloned:
		*s = SimilarVoiceCategoryCloned
	case SimilarVoiceCategoryGenerated:
		*s = SimilarVoiceCategoryGenerated
	case SimilarVoiceCategoryProfessional:
		*s = SimilarVoiceCategoryProfessional
	case SimilarVoiceCategoryFamous:
		*s = SimilarVoiceCategoryFamous
	default:
		*s = SimilarVoiceCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SimilarVoiceCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimilarVoiceCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SimilarVoicesForSpeakerResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SimilarVoicesForSpeakerResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("voices")
		e.ArrStart()
		for _, elem := range s.Voices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSimilarVoicesForSpeakerResponse = [1]string{
	0: "voices",
}

// Decode decodes SimilarVoicesForSpeakerResponse from json.
func (s *SimilarVoicesForSpeakerResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SimilarVoicesForSpeakerResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "voices":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Voices = make([]SimilarVoice, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SimilarVoice
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Voices = append(s.Voices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SimilarVoicesForSpeakerResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSimilarVoicesForSpeakerResponse) {
					name = jsonFieldsNameOfSimilarVoicesForSpeakerResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SimilarVoicesForSpeakerResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SimilarVoicesForSpeakerResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SingleUseTokenResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SingleUseTokenResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfSingleUseTokenResponseModel = [1]string{
	0: "token",
}

// Decode decodes SingleUseTokenResponseModel from json.
func (s *SingleUseTokenResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SingleUseTokenResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SingleUseTokenResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSingleUseTokenResponseModel) {
					name = jsonFieldsNameOfSingleUseTokenResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SingleUseTokenResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SingleUseTokenResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SkipTurnToolResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SkipTurnToolResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfSkipTurnToolResponseModel = [3]string{
	0: "reason",
	1: "result_type",
	2: "status",
}

// Decode decodes SkipTurnToolResponseModel from json.
func (s *SkipTurnToolResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkipTurnToolResponseModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SkipTurnToolResponseModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SkipTurnToolResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkipTurnToolResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkipTurnToolResponseModelResultType as json.
func (s SkipTurnToolResponseModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkipTurnToolResponseModelResultType from json.
func (s *SkipTurnToolResponseModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkipTurnToolResponseModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkipTurnToolResponseModelResultType(v) {
	case SkipTurnToolResponseModelResultTypeSkipTurnSuccess:
		*s = SkipTurnToolResponseModelResultTypeSkipTurnSuccess
	default:
		*s = SkipTurnToolResponseModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkipTurnToolResponseModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkipTurnToolResponseModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SkipTurnToolResponseModelStatus as json.
func (s SkipTurnToolResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SkipTurnToolResponseModelStatus from json.
func (s *SkipTurnToolResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SkipTurnToolResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SkipTurnToolResponseModelStatus(v) {
	case SkipTurnToolResponseModelStatusSuccess:
		*s = SkipTurnToolResponseModelStatusSuccess
	default:
		*s = SkipTurnToolResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SkipTurnToolResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SkipTurnToolResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SoftTimeoutConfigOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SoftTimeoutConfigOverride) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfSoftTimeoutConfigOverride = [1]string{
	0: "message",
}

// Decode decodes SoftTimeoutConfigOverride from json.
func (s *SoftTimeoutConfigOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SoftTimeoutConfigOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SoftTimeoutConfigOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SoftTimeoutConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SoftTimeoutConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SongSection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SongSection) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("duration_ms")
		e.Int(s.DurationMs)
	}
	{
		e.FieldStart("lines")
		e.ArrStart()
		for _, elem := range s.Lines {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("negative_local_styles")
		e.ArrStart()
		for _, elem := range s.NegativeLocalStyles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("positive_local_styles")
		e.ArrStart()
		for _, elem := range s.PositiveLocalStyles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("section_name")
		e.Str(s.SectionName)
	}
	{
		if s.SourceFrom.Set {
			e.FieldStart("source_from")
			s.SourceFrom.Encode(e)
		}
	}
}

var jsonFieldsNameOfSongSection = [6]string{
	0: "duration_ms",
	1: "lines",
	2: "negative_local_styles",
	3: "positive_local_styles",
	4: "section_name",
	5: "source_from",
}

// Decode decodes SongSection from json.
func (s *SongSection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SongSection to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.DurationMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_ms\"")
			}
		case "lines":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Lines = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Lines = append(s.Lines, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lines\"")
			}
		case "negative_local_styles":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.NegativeLocalStyles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.NegativeLocalStyles = append(s.NegativeLocalStyles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"negative_local_styles\"")
			}
		case "positive_local_styles":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.PositiveLocalStyles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PositiveLocalStyles = append(s.PositiveLocalStyles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"positive_local_styles\"")
			}
		case "section_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SectionName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"section_name\"")
			}
		case "source_from":
			if err := func() error {
				s.SourceFrom.Reset()
				if err := s.SourceFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_from\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SongSection")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSongSection) {
					name = jsonFieldsNameOfSongSection[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SongSection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SongSection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerAudioResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerAudioResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audio_base_64")
		e.Str(s.AudioBase64)
	}
	{
		e.FieldStart("duration_secs")
		e.Float64(s.DurationSecs)
	}
	{
		e.FieldStart("media_type")
		e.Str(s.MediaType)
	}
}

var jsonFieldsNameOfSpeakerAudioResponseModel = [3]string{
	0: "audio_base_64",
	1: "duration_secs",
	2: "media_type",
}

// Decode decodes SpeakerAudioResponseModel from json.
func (s *SpeakerAudioResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerAudioResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_base_64":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base_64\"")
			}
		case "duration_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DurationSecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "media_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MediaType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerAudioResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerAudioResponseModel) {
					name = jsonFieldsNameOfSpeakerAudioResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerAudioResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerAudioResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerCreatedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerCreatedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("speaker_id")
		e.Str(s.SpeakerID)
	}
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSpeakerCreatedResponse = [2]string{
	0: "speaker_id",
	1: "version",
}

// Decode decodes SpeakerCreatedResponse from json.
func (s *SpeakerCreatedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerCreatedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "speaker_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SpeakerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_id\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerCreatedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerCreatedResponse) {
					name = jsonFieldsNameOfSpeakerCreatedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerCreatedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerCreatedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("duration_secs")
		e.Float64(s.DurationSecs)
	}
	{
		e.FieldStart("speaker_id")
		e.Str(s.SpeakerID)
	}
	{
		if s.Utterances.Set {
			e.FieldStart("utterances")
			s.Utterances.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpeakerResponseModel = [3]string{
	0: "duration_secs",
	1: "speaker_id",
	2: "utterances",
}

// Decode decodes SpeakerResponseModel from json.
func (s *SpeakerResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "duration_secs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.DurationSecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "speaker_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SpeakerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_id\"")
			}
		case "utterances":
			if err := func() error {
				s.Utterances.Reset()
				if err := s.Utterances.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"utterances\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerResponseModel) {
					name = jsonFieldsNameOfSpeakerResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerSegment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerSegment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dubs")
		s.Dubs.Encode(e)
	}
	{
		e.FieldStart("end_time")
		e.Float64(s.EndTime)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("start_time")
		e.Float64(s.StartTime)
	}
	{
		e.FieldStart("subtitles")
		e.ArrStart()
		for _, elem := range s.Subtitles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfSpeakerSegment = [6]string{
	0: "dubs",
	1: "end_time",
	2: "id",
	3: "start_time",
	4: "subtitles",
	5: "text",
}

// Decode decodes SpeakerSegment from json.
func (s *SpeakerSegment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerSegment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dubs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dubs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dubs\"")
			}
		case "end_time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.EndTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "start_time":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.StartTime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time\"")
			}
		case "subtitles":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Subtitles = make([]SegmentSubtitleFrame, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SegmentSubtitleFrame
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subtitles = append(s.Subtitles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subtitles\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerSegment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerSegment) {
					name = jsonFieldsNameOfSpeakerSegment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerSegment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerSegment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpeakerSegmentDubs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpeakerSegmentDubs) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SpeakerSegmentDubs from json.
func (s *SpeakerSegmentDubs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerSegmentDubs to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DubbedSegment
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerSegmentDubs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakerSegmentDubs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerSegmentDubs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerSeparationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerSeparationResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sample_id")
		e.Str(s.SampleID)
	}
	{
		if s.SelectedSpeakerIds.Set {
			e.FieldStart("selected_speaker_ids")
			s.SelectedSpeakerIds.Encode(e)
		}
	}
	{
		if s.Speakers.Set {
			e.FieldStart("speakers")
			s.Speakers.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfSpeakerSeparationResponseModel = [5]string{
	0: "sample_id",
	1: "selected_speaker_ids",
	2: "speakers",
	3: "status",
	4: "voice_id",
}

// Decode decodes SpeakerSeparationResponseModel from json.
func (s *SpeakerSeparationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerSeparationResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sample_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SampleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_id\"")
			}
		case "selected_speaker_ids":
			if err := func() error {
				s.SelectedSpeakerIds.Reset()
				if err := s.SelectedSpeakerIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"selected_speaker_ids\"")
			}
		case "speakers":
			if err := func() error {
				s.Speakers.Reset()
				if err := s.Speakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speakers\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerSeparationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerSeparationResponseModel) {
					name = jsonFieldsNameOfSpeakerSeparationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerSeparationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerSeparationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpeakerSeparationResponseModelSpeakers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpeakerSeparationResponseModelSpeakers) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes SpeakerSeparationResponseModelSpeakers from json.
func (s *SpeakerSeparationResponseModelSpeakers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerSeparationResponseModelSpeakers to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem SpeakerResponseModel
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerSeparationResponseModelSpeakers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakerSeparationResponseModelSpeakers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerSeparationResponseModelSpeakers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeakerSeparationResponseModelStatus as json.
func (s SpeakerSeparationResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeakerSeparationResponseModelStatus from json.
func (s *SpeakerSeparationResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerSeparationResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeakerSeparationResponseModelStatus(v) {
	case SpeakerSeparationResponseModelStatusNotStarted:
		*s = SpeakerSeparationResponseModelStatusNotStarted
	case SpeakerSeparationResponseModelStatusPending:
		*s = SpeakerSeparationResponseModelStatusPending
	case SpeakerSeparationResponseModelStatusCompleted:
		*s = SpeakerSeparationResponseModelStatusCompleted
	case SpeakerSeparationResponseModelStatusFailed:
		*s = SpeakerSeparationResponseModelStatusFailed
	default:
		*s = SpeakerSeparationResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakerSeparationResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerSeparationResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerTrack) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerTrack) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("media_ref")
		s.MediaRef.Encode(e)
	}
	{
		e.FieldStart("segments")
		e.ArrStart()
		for _, elem := range s.Segments {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("speaker_name")
		e.Str(s.SpeakerName)
	}
	{
		e.FieldStart("voices")
		s.Voices.Encode(e)
	}
}

var jsonFieldsNameOfSpeakerTrack = [5]string{
	0: "id",
	1: "media_ref",
	2: "segments",
	3: "speaker_name",
	4: "voices",
}

// Decode decodes SpeakerTrack from json.
func (s *SpeakerTrack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerTrack to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "media_ref":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.MediaRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_ref\"")
			}
		case "segments":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Segments = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Segments = append(s.Segments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segments\"")
			}
		case "speaker_name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SpeakerName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_name\"")
			}
		case "voices":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Voices.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerTrack")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerTrack) {
					name = jsonFieldsNameOfSpeakerTrack[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerTrack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerTrack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpeakerTrackVoices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpeakerTrackVoices) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SpeakerTrackVoices from json.
func (s *SpeakerTrackVoices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerTrackVoices to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerTrackVoices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeakerTrackVoices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerTrackVoices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeakerUpdatedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeakerUpdatedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Int(s.Version)
	}
}

var jsonFieldsNameOfSpeakerUpdatedResponse = [1]string{
	0: "version",
}

// Decode decodes SpeakerUpdatedResponse from json.
func (s *SpeakerUpdatedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeakerUpdatedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Version = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeakerUpdatedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeakerUpdatedResponse) {
					name = jsonFieldsNameOfSpeakerUpdatedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeakerUpdatedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeakerUpdatedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechHistoryItemResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechHistoryItemResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Alignments.Set {
			e.FieldStart("alignments")
			s.Alignments.Encode(e)
		}
	}
	{
		e.FieldStart("character_count_change_from")
		e.Int(s.CharacterCountChangeFrom)
	}
	{
		e.FieldStart("character_count_change_to")
		e.Int(s.CharacterCountChangeTo)
	}
	{
		e.FieldStart("content_type")
		e.Str(s.ContentType)
	}
	{
		e.FieldStart("date_unix")
		e.Int(s.DateUnix)
	}
	{
		if s.Dialogue.Set {
			e.FieldStart("dialogue")
			s.Dialogue.Encode(e)
		}
	}
	{
		if s.Feedback.Set {
			e.FieldStart("feedback")
			s.Feedback.Encode(e)
		}
	}
	{
		e.FieldStart("history_item_id")
		e.Str(s.HistoryItemID)
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.RequestID.Set {
			e.FieldStart("request_id")
			s.RequestID.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.ShareLinkID.Set {
			e.FieldStart("share_link_id")
			s.ShareLinkID.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.VoiceCategory.Set {
			e.FieldStart("voice_category")
			s.VoiceCategory.Encode(e)
		}
	}
	{
		if s.VoiceID.Set {
			e.FieldStart("voice_id")
			s.VoiceID.Encode(e)
		}
	}
	{
		if s.VoiceName.Set {
			e.FieldStart("voice_name")
			s.VoiceName.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpeechHistoryItemResponseModel = [18]string{
	0:  "alignments",
	1:  "character_count_change_from",
	2:  "character_count_change_to",
	3:  "content_type",
	4:  "date_unix",
	5:  "dialogue",
	6:  "feedback",
	7:  "history_item_id",
	8:  "model_id",
	9:  "request_id",
	10: "settings",
	11: "share_link_id",
	12: "source",
	13: "state",
	14: "text",
	15: "voice_category",
	16: "voice_id",
	17: "voice_name",
}

// Decode decodes SpeechHistoryItemResponseModel from json.
func (s *SpeechHistoryItemResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechHistoryItemResponseModel to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alignments":
			if err := func() error {
				s.Alignments.Reset()
				if err := s.Alignments.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alignments\"")
			}
		case "character_count_change_from":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CharacterCountChangeFrom = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_count_change_from\"")
			}
		case "character_count_change_to":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.CharacterCountChangeTo = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_count_change_to\"")
			}
		case "content_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ContentType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content_type\"")
			}
		case "date_unix":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.DateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_unix\"")
			}
		case "dialogue":
			if err := func() error {
				s.Dialogue.Reset()
				if err := s.Dialogue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogue\"")
			}
		case "feedback":
			if err := func() error {
				s.Feedback.Reset()
				if err := s.Feedback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feedback\"")
			}
		case "history_item_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HistoryItemID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history_item_id\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "request_id":
			if err := func() error {
				s.RequestID.Reset()
				if err := s.RequestID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		case "share_link_id":
			if err := func() error {
				s.ShareLinkID.Reset()
				if err := s.ShareLinkID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"share_link_id\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "state":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voice_category":
			if err := func() error {
				s.VoiceCategory.Reset()
				if err := s.VoiceCategory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_category\"")
			}
		case "voice_id":
			if err := func() error {
				s.VoiceID.Reset()
				if err := s.VoiceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		case "voice_name":
			if err := func() error {
				s.VoiceName.Reset()
				if err := s.VoiceName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechHistoryItemResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10011110,
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeechHistoryItemResponseModel) {
					name = jsonFieldsNameOfSpeechHistoryItemResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechHistoryItemResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechHistoryItemResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechHistoryItemResponseModelSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechHistoryItemResponseModelSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSpeechHistoryItemResponseModelSettings = [0]string{}

// Decode decodes SpeechHistoryItemResponseModelSettings from json.
func (s *SpeechHistoryItemResponseModelSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechHistoryItemResponseModelSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SpeechHistoryItemResponseModelSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechHistoryItemResponseModelSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechHistoryItemResponseModelSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechHistoryItemResponseModelSource as json.
func (s SpeechHistoryItemResponseModelSource) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeechHistoryItemResponseModelSource from json.
func (s *SpeechHistoryItemResponseModelSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechHistoryItemResponseModelSource to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeechHistoryItemResponseModelSource(v) {
	case SpeechHistoryItemResponseModelSourceTTS:
		*s = SpeechHistoryItemResponseModelSourceTTS
	case SpeechHistoryItemResponseModelSourceSTS:
		*s = SpeechHistoryItemResponseModelSourceSTS
	case SpeechHistoryItemResponseModelSourceProjects:
		*s = SpeechHistoryItemResponseModelSourceProjects
	case SpeechHistoryItemResponseModelSourcePD:
		*s = SpeechHistoryItemResponseModelSourcePD
	case SpeechHistoryItemResponseModelSourceAN:
		*s = SpeechHistoryItemResponseModelSourceAN
	case SpeechHistoryItemResponseModelSourceDubbing:
		*s = SpeechHistoryItemResponseModelSourceDubbing
	case SpeechHistoryItemResponseModelSourcePlayAPI:
		*s = SpeechHistoryItemResponseModelSourcePlayAPI
	case SpeechHistoryItemResponseModelSourceConvAI:
		*s = SpeechHistoryItemResponseModelSourceConvAI
	case SpeechHistoryItemResponseModelSourceVoiceGeneration:
		*s = SpeechHistoryItemResponseModelSourceVoiceGeneration
	default:
		*s = SpeechHistoryItemResponseModelSource(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechHistoryItemResponseModelSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechHistoryItemResponseModelSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechHistoryItemResponseModelState as json.
func (s SpeechHistoryItemResponseModelState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeechHistoryItemResponseModelState from json.
func (s *SpeechHistoryItemResponseModelState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechHistoryItemResponseModelState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeechHistoryItemResponseModelState(v) {
	case SpeechHistoryItemResponseModelStateCreated:
		*s = SpeechHistoryItemResponseModelStateCreated
	case SpeechHistoryItemResponseModelStateDeleted:
		*s = SpeechHistoryItemResponseModelStateDeleted
	case SpeechHistoryItemResponseModelStateProcessing:
		*s = SpeechHistoryItemResponseModelStateProcessing
	default:
		*s = SpeechHistoryItemResponseModelState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechHistoryItemResponseModelState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechHistoryItemResponseModelState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechHistoryItemResponseModelVoiceCategory as json.
func (s SpeechHistoryItemResponseModelVoiceCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeechHistoryItemResponseModelVoiceCategory from json.
func (s *SpeechHistoryItemResponseModelVoiceCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechHistoryItemResponseModelVoiceCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeechHistoryItemResponseModelVoiceCategory(v) {
	case SpeechHistoryItemResponseModelVoiceCategoryPremade:
		*s = SpeechHistoryItemResponseModelVoiceCategoryPremade
	case SpeechHistoryItemResponseModelVoiceCategoryCloned:
		*s = SpeechHistoryItemResponseModelVoiceCategoryCloned
	case SpeechHistoryItemResponseModelVoiceCategoryGenerated:
		*s = SpeechHistoryItemResponseModelVoiceCategoryGenerated
	case SpeechHistoryItemResponseModelVoiceCategoryProfessional:
		*s = SpeechHistoryItemResponseModelVoiceCategoryProfessional
	default:
		*s = SpeechHistoryItemResponseModelVoiceCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechHistoryItemResponseModelVoiceCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechHistoryItemResponseModelVoiceCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechToTextAcceptedApplicationJSON as json.
func (s SpeechToTextAcceptedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes SpeechToTextAcceptedApplicationJSON from json.
func (s *SpeechToTextAcceptedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechToTextAcceptedApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SpeechToTextAcceptedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechToTextAcceptedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechToTextAcceptedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechToTextCharacterResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechToTextCharacterResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfSpeechToTextCharacterResponseModel = [3]string{
	0: "end",
	1: "start",
	2: "text",
}

// Decode decodes SpeechToTextCharacterResponseModel from json.
func (s *SpeechToTextCharacterResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechToTextCharacterResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechToTextCharacterResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeechToTextCharacterResponseModel) {
					name = jsonFieldsNameOfSpeechToTextCharacterResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechToTextCharacterResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechToTextCharacterResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechToTextChunkResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechToTextChunkResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AdditionalFormats.Set {
			e.FieldStart("additional_formats")
			s.AdditionalFormats.Encode(e)
		}
	}
	{
		if s.ChannelIndex.Set {
			e.FieldStart("channel_index")
			s.ChannelIndex.Encode(e)
		}
	}
	{
		e.FieldStart("language_code")
		e.Str(s.LanguageCode)
	}
	{
		e.FieldStart("language_probability")
		e.Float64(s.LanguageProbability)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		if s.TranscriptionID.Set {
			e.FieldStart("transcription_id")
			s.TranscriptionID.Encode(e)
		}
	}
	{
		e.FieldStart("words")
		e.ArrStart()
		for _, elem := range s.Words {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSpeechToTextChunkResponseModel = [7]string{
	0: "additional_formats",
	1: "channel_index",
	2: "language_code",
	3: "language_probability",
	4: "text",
	5: "transcription_id",
	6: "words",
}

// Decode decodes SpeechToTextChunkResponseModel from json.
func (s *SpeechToTextChunkResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechToTextChunkResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additional_formats":
			if err := func() error {
				s.AdditionalFormats.Reset()
				if err := s.AdditionalFormats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_formats\"")
			}
		case "channel_index":
			if err := func() error {
				s.ChannelIndex.Reset()
				if err := s.ChannelIndex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channel_index\"")
			}
		case "language_code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.LanguageCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_code\"")
			}
		case "language_probability":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.LanguageProbability = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language_probability\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "transcription_id":
			if err := func() error {
				s.TranscriptionID.Reset()
				if err := s.TranscriptionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transcription_id\"")
			}
		case "words":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Words = make([]SpeechToTextWordResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SpeechToTextWordResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Words = append(s.Words, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"words\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechToTextChunkResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeechToTextChunkResponseModel) {
					name = jsonFieldsNameOfSpeechToTextChunkResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechToTextChunkResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechToTextChunkResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechToTextOK as json.
func (s SpeechToTextOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case SpeechToTextChunkResponseModelSpeechToTextOK:
		s.SpeechToTextChunkResponseModel.Encode(e)
	case MultichannelSpeechToTextResponseModelSpeechToTextOK:
		s.MultichannelSpeechToTextResponseModel.Encode(e)
	}
}

func (s SpeechToTextOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case SpeechToTextChunkResponseModelSpeechToTextOK:
		s.SpeechToTextChunkResponseModel.encodeFields(e)
	case MultichannelSpeechToTextResponseModelSpeechToTextOK:
		s.MultichannelSpeechToTextResponseModel.encodeFields(e)
	}
}

// Decode decodes SpeechToTextOK from json.
func (s *SpeechToTextOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechToTextOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "additional_formats":
				// Type-based discrimination: check if field has expected JSON type (nullable)
				typ := d.Next()
				if typ != jx.Array && typ != jx.Null {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "channel_index":
				// Type-based discrimination: check if field has expected JSON type (nullable)
				typ := d.Next()
				if typ != jx.Number && typ != jx.Null {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "language_code":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "language_probability":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Number {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "text":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "transcripts":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := MultichannelSpeechToTextResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "words":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := SpeechToTextChunkResponseModelSpeechToTextOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case SpeechToTextChunkResponseModelSpeechToTextOK:
		if err := s.SpeechToTextChunkResponseModel.Decode(d); err != nil {
			return err
		}
	case MultichannelSpeechToTextResponseModelSpeechToTextOK:
		if err := s.MultichannelSpeechToTextResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechToTextOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechToTextOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SpeechToTextWordResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SpeechToTextWordResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Characters.Set {
			e.FieldStart("characters")
			s.Characters.Encode(e)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e)
		}
	}
	{
		e.FieldStart("logprob")
		e.Float64(s.Logprob)
	}
	{
		if s.SpeakerID.Set {
			e.FieldStart("speaker_id")
			s.SpeakerID.Encode(e)
		}
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e)
		}
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfSpeechToTextWordResponseModel = [7]string{
	0: "characters",
	1: "end",
	2: "logprob",
	3: "speaker_id",
	4: "start",
	5: "text",
	6: "type",
}

// Decode decodes SpeechToTextWordResponseModel from json.
func (s *SpeechToTextWordResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechToTextWordResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "characters":
			if err := func() error {
				s.Characters.Reset()
				if err := s.Characters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characters\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "logprob":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Logprob = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logprob\"")
			}
		case "speaker_id":
			if err := func() error {
				s.SpeakerID.Reset()
				if err := s.SpeakerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speaker_id\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpeechToTextWordResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpeechToTextWordResponseModel) {
					name = jsonFieldsNameOfSpeechToTextWordResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SpeechToTextWordResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechToTextWordResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpeechToTextWordResponseModelType as json.
func (s SpeechToTextWordResponseModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpeechToTextWordResponseModelType from json.
func (s *SpeechToTextWordResponseModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpeechToTextWordResponseModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpeechToTextWordResponseModelType(v) {
	case SpeechToTextWordResponseModelTypeWord:
		*s = SpeechToTextWordResponseModelTypeWord
	case SpeechToTextWordResponseModelTypeSpacing:
		*s = SpeechToTextWordResponseModelTypeSpacing
	case SpeechToTextWordResponseModelTypeAudioEvent:
		*s = SpeechToTextWordResponseModelTypeAudioEvent
	default:
		*s = SpeechToTextWordResponseModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpeechToTextWordResponseModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpeechToTextWordResponseModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SrtExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SrtExportOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		if s.IncludeSpeakers.Set {
			e.FieldStart("include_speakers")
			s.IncludeSpeakers.Encode(e)
		}
	}
	{
		if s.IncludeTimestamps.Set {
			e.FieldStart("include_timestamps")
			s.IncludeTimestamps.Encode(e)
		}
	}
	{
		if s.MaxCharactersPerLine.Set {
			e.FieldStart("max_characters_per_line")
			s.MaxCharactersPerLine.Encode(e)
		}
	}
	{
		if s.MaxSegmentChars.Set {
			e.FieldStart("max_segment_chars")
			s.MaxSegmentChars.Encode(e)
		}
	}
	{
		if s.MaxSegmentDurationS.Set {
			e.FieldStart("max_segment_duration_s")
			s.MaxSegmentDurationS.Encode(e)
		}
	}
	{
		if s.SegmentOnSilenceLongerThanS.Set {
			e.FieldStart("segment_on_silence_longer_than_s")
			s.SegmentOnSilenceLongerThanS.Encode(e)
		}
	}
}

var jsonFieldsNameOfSrtExportOptions = [7]string{
	0: "format",
	1: "include_speakers",
	2: "include_timestamps",
	3: "max_characters_per_line",
	4: "max_segment_chars",
	5: "max_segment_duration_s",
	6: "segment_on_silence_longer_than_s",
}

// Decode decodes SrtExportOptions from json.
func (s *SrtExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SrtExportOptions to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "include_speakers":
			if err := func() error {
				s.IncludeSpeakers.Reset()
				if err := s.IncludeSpeakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_speakers\"")
			}
		case "include_timestamps":
			if err := func() error {
				s.IncludeTimestamps.Reset()
				if err := s.IncludeTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_timestamps\"")
			}
		case "max_characters_per_line":
			if err := func() error {
				s.MaxCharactersPerLine.Reset()
				if err := s.MaxCharactersPerLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_characters_per_line\"")
			}
		case "max_segment_chars":
			if err := func() error {
				s.MaxSegmentChars.Reset()
				if err := s.MaxSegmentChars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_chars\"")
			}
		case "max_segment_duration_s":
			if err := func() error {
				s.MaxSegmentDurationS.Reset()
				if err := s.MaxSegmentDurationS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_duration_s\"")
			}
		case "segment_on_silence_longer_than_s":
			if err := func() error {
				s.SegmentOnSilenceLongerThanS.Reset()
				if err := s.SegmentOnSilenceLongerThanS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_on_silence_longer_than_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SrtExportOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSrtExportOptions) {
					name = jsonFieldsNameOfSrtExportOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SrtExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SrtExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SrtExportOptionsFormat as json.
func (s SrtExportOptionsFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SrtExportOptionsFormat from json.
func (s *SrtExportOptionsFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SrtExportOptionsFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SrtExportOptionsFormat(v) {
	case SrtExportOptionsFormatSrt:
		*s = SrtExportOptionsFormatSrt
	default:
		*s = SrtExportOptionsFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SrtExportOptionsFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SrtExportOptionsFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartPVCVoiceTrainingResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartPVCVoiceTrainingResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfStartPVCVoiceTrainingResponseModel = [1]string{
	0: "status",
}

// Decode decodes StartPVCVoiceTrainingResponseModel from json.
func (s *StartPVCVoiceTrainingResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartPVCVoiceTrainingResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartPVCVoiceTrainingResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartPVCVoiceTrainingResponseModel) {
					name = jsonFieldsNameOfStartPVCVoiceTrainingResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartPVCVoiceTrainingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartPVCVoiceTrainingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartSpeakerSeparationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartSpeakerSeparationResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfStartSpeakerSeparationResponseModel = [1]string{
	0: "status",
}

// Decode decodes StartSpeakerSeparationResponseModel from json.
func (s *StartSpeakerSeparationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartSpeakerSeparationResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartSpeakerSeparationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStartSpeakerSeparationResponseModel) {
					name = jsonFieldsNameOfStartSpeakerSeparationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartSpeakerSeparationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartSpeakerSeparationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Alignment.Set {
			e.FieldStart("alignment")
			s.Alignment.Encode(e)
		}
	}
	{
		e.FieldStart("audio_base64")
		e.Str(s.AudioBase64)
	}
	{
		if s.NormalizedAlignment.Set {
			e.FieldStart("normalized_alignment")
			s.NormalizedAlignment.Encode(e)
		}
	}
	{
		e.FieldStart("voice_segments")
		e.ArrStart()
		for _, elem := range s.VoiceSegments {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfStreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel = [4]string{
	0: "alignment",
	1: "audio_base64",
	2: "normalized_alignment",
	3: "voice_segments",
}

// Decode decodes StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel from json.
func (s *StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alignment":
			if err := func() error {
				s.Alignment.Reset()
				if err := s.Alignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alignment\"")
			}
		case "audio_base64":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base64\"")
			}
		case "normalized_alignment":
			if err := func() error {
				s.NormalizedAlignment.Reset()
				if err := s.NormalizedAlignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normalized_alignment\"")
			}
		case "voice_segments":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.VoiceSegments = make([]VoiceSegment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceSegment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VoiceSegments = append(s.VoiceSegments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_segments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel) {
					name = jsonFieldsNameOfStreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StreamingAudioChunkWithTimestampsAndVoiceSegmentsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StreamingAudioChunkWithTimestampsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StreamingAudioChunkWithTimestampsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Alignment.Set {
			e.FieldStart("alignment")
			s.Alignment.Encode(e)
		}
	}
	{
		e.FieldStart("audio_base64")
		e.Str(s.AudioBase64)
	}
	{
		if s.NormalizedAlignment.Set {
			e.FieldStart("normalized_alignment")
			s.NormalizedAlignment.Encode(e)
		}
	}
}

var jsonFieldsNameOfStreamingAudioChunkWithTimestampsResponseModel = [3]string{
	0: "alignment",
	1: "audio_base64",
	2: "normalized_alignment",
}

// Decode decodes StreamingAudioChunkWithTimestampsResponseModel from json.
func (s *StreamingAudioChunkWithTimestampsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StreamingAudioChunkWithTimestampsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alignment":
			if err := func() error {
				s.Alignment.Reset()
				if err := s.Alignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alignment\"")
			}
		case "audio_base64":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base64\"")
			}
		case "normalized_alignment":
			if err := func() error {
				s.NormalizedAlignment.Reset()
				if err := s.NormalizedAlignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"normalized_alignment\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StreamingAudioChunkWithTimestampsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfStreamingAudioChunkWithTimestampsResponseModel) {
					name = jsonFieldsNameOfStreamingAudioChunkWithTimestampsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StreamingAudioChunkWithTimestampsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StreamingAudioChunkWithTimestampsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("allowed_to_extend_character_limit")
		e.Bool(s.AllowedToExtendCharacterLimit)
	}
	{
		if s.BillingPeriod.Set {
			e.FieldStart("billing_period")
			s.BillingPeriod.Encode(e)
		}
	}
	{
		e.FieldStart("can_extend_character_limit")
		e.Bool(s.CanExtendCharacterLimit)
	}
	{
		e.FieldStart("can_extend_voice_limit")
		e.Bool(s.CanExtendVoiceLimit)
	}
	{
		e.FieldStart("can_use_instant_voice_cloning")
		e.Bool(s.CanUseInstantVoiceCloning)
	}
	{
		e.FieldStart("can_use_professional_voice_cloning")
		e.Bool(s.CanUseProfessionalVoiceCloning)
	}
	{
		e.FieldStart("character_count")
		e.Int(s.CharacterCount)
	}
	{
		e.FieldStart("character_limit")
		e.Int(s.CharacterLimit)
	}
	{
		if s.CharacterRefreshPeriod.Set {
			e.FieldStart("character_refresh_period")
			s.CharacterRefreshPeriod.Encode(e)
		}
	}
	{
		if s.Currency.Set {
			e.FieldStart("currency")
			s.Currency.Encode(e)
		}
	}
	{
		e.FieldStart("max_character_limit_extension")
		s.MaxCharacterLimitExtension.Encode(e)
	}
	{
		if s.MaxVoiceAddEdits.Set {
			e.FieldStart("max_voice_add_edits")
			s.MaxVoiceAddEdits.Encode(e)
		}
	}
	{
		if s.NextCharacterCountResetUnix.Set {
			e.FieldStart("next_character_count_reset_unix")
			s.NextCharacterCountResetUnix.Encode(e)
		}
	}
	{
		e.FieldStart("professional_voice_limit")
		e.Int(s.ProfessionalVoiceLimit)
	}
	{
		e.FieldStart("professional_voice_slots_used")
		e.Int(s.ProfessionalVoiceSlotsUsed)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("tier")
		e.Str(s.Tier)
	}
	{
		e.FieldStart("voice_add_edit_counter")
		e.Int(s.VoiceAddEditCounter)
	}
	{
		e.FieldStart("voice_limit")
		e.Int(s.VoiceLimit)
	}
	{
		e.FieldStart("voice_slots_used")
		e.Int(s.VoiceSlotsUsed)
	}
}

var jsonFieldsNameOfSubscriptionResponseModel = [20]string{
	0:  "allowed_to_extend_character_limit",
	1:  "billing_period",
	2:  "can_extend_character_limit",
	3:  "can_extend_voice_limit",
	4:  "can_use_instant_voice_cloning",
	5:  "can_use_professional_voice_cloning",
	6:  "character_count",
	7:  "character_limit",
	8:  "character_refresh_period",
	9:  "currency",
	10: "max_character_limit_extension",
	11: "max_voice_add_edits",
	12: "next_character_count_reset_unix",
	13: "professional_voice_limit",
	14: "professional_voice_slots_used",
	15: "status",
	16: "tier",
	17: "voice_add_edit_counter",
	18: "voice_limit",
	19: "voice_slots_used",
}

// Decode decodes SubscriptionResponseModel from json.
func (s *SubscriptionResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionResponseModel to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowed_to_extend_character_limit":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.AllowedToExtendCharacterLimit = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowed_to_extend_character_limit\"")
			}
		case "billing_period":
			if err := func() error {
				s.BillingPeriod.Reset()
				if err := s.BillingPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billing_period\"")
			}
		case "can_extend_character_limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.CanExtendCharacterLimit = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_extend_character_limit\"")
			}
		case "can_extend_voice_limit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CanExtendVoiceLimit = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_extend_voice_limit\"")
			}
		case "can_use_instant_voice_cloning":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.CanUseInstantVoiceCloning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_instant_voice_cloning\"")
			}
		case "can_use_professional_voice_cloning":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.CanUseProfessionalVoiceCloning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_professional_voice_cloning\"")
			}
		case "character_count":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.CharacterCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_count\"")
			}
		case "character_limit":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.CharacterLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_limit\"")
			}
		case "character_refresh_period":
			if err := func() error {
				s.CharacterRefreshPeriod.Reset()
				if err := s.CharacterRefreshPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_refresh_period\"")
			}
		case "currency":
			if err := func() error {
				s.Currency.Reset()
				if err := s.Currency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currency\"")
			}
		case "max_character_limit_extension":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.MaxCharacterLimitExtension.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_character_limit_extension\"")
			}
		case "max_voice_add_edits":
			if err := func() error {
				s.MaxVoiceAddEdits.Reset()
				if err := s.MaxVoiceAddEdits.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_voice_add_edits\"")
			}
		case "next_character_count_reset_unix":
			if err := func() error {
				s.NextCharacterCountResetUnix.Reset()
				if err := s.NextCharacterCountResetUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_character_count_reset_unix\"")
			}
		case "professional_voice_limit":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.ProfessionalVoiceLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"professional_voice_limit\"")
			}
		case "professional_voice_slots_used":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.ProfessionalVoiceSlotsUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"professional_voice_slots_used\"")
			}
		case "status":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "tier":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tier = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tier\"")
			}
		case "voice_add_edit_counter":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.VoiceAddEditCounter = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_add_edit_counter\"")
			}
		case "voice_limit":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.VoiceLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_limit\"")
			}
		case "voice_slots_used":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.VoiceSlotsUsed = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_slots_used\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111101,
		0b11100100,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubscriptionResponseModel) {
					name = jsonFieldsNameOfSubscriptionResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionResponseModelCurrency as json.
func (s SubscriptionResponseModelCurrency) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubscriptionResponseModelCurrency from json.
func (s *SubscriptionResponseModelCurrency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionResponseModelCurrency to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubscriptionResponseModelCurrency(v) {
	case SubscriptionResponseModelCurrencyUsd:
		*s = SubscriptionResponseModelCurrencyUsd
	case SubscriptionResponseModelCurrencyEur:
		*s = SubscriptionResponseModelCurrencyEur
	case SubscriptionResponseModelCurrencyInr:
		*s = SubscriptionResponseModelCurrencyInr
	default:
		*s = SubscriptionResponseModelCurrency(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubscriptionResponseModelCurrency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionResponseModelCurrency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionStatusType as json.
func (s SubscriptionStatusType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubscriptionStatusType from json.
func (s *SubscriptionStatusType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionStatusType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubscriptionStatusType(v) {
	case SubscriptionStatusTypeTrialing:
		*s = SubscriptionStatusTypeTrialing
	case SubscriptionStatusTypeActive:
		*s = SubscriptionStatusTypeActive
	case SubscriptionStatusTypeIncomplete:
		*s = SubscriptionStatusTypeIncomplete
	case SubscriptionStatusTypePastDue:
		*s = SubscriptionStatusTypePastDue
	case SubscriptionStatusTypeFree:
		*s = SubscriptionStatusTypeFree
	case SubscriptionStatusTypeFreeDisabled:
		*s = SubscriptionStatusTypeFreeDisabled
	default:
		*s = SubscriptionStatusType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubscriptionStatusType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionStatusType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TTSConversationalConfigOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TTSConversationalConfigOverride) encodeFields(e *jx.Encoder) {
	{
		if s.SimilarityBoost.Set {
			e.FieldStart("similarity_boost")
			s.SimilarityBoost.Encode(e)
		}
	}
	{
		if s.Speed.Set {
			e.FieldStart("speed")
			s.Speed.Encode(e)
		}
	}
	{
		if s.Stability.Set {
			e.FieldStart("stability")
			s.Stability.Encode(e)
		}
	}
	{
		if s.VoiceID.Set {
			e.FieldStart("voice_id")
			s.VoiceID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTTSConversationalConfigOverride = [4]string{
	0: "similarity_boost",
	1: "speed",
	2: "stability",
	3: "voice_id",
}

// Decode decodes TTSConversationalConfigOverride from json.
func (s *TTSConversationalConfigOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TTSConversationalConfigOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "similarity_boost":
			if err := func() error {
				s.SimilarityBoost.Reset()
				if err := s.SimilarityBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"similarity_boost\"")
			}
		case "speed":
			if err := func() error {
				s.Speed.Reset()
				if err := s.Speed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "stability":
			if err := func() error {
				s.Stability.Reset()
				if err := s.Stability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stability\"")
			}
		case "voice_id":
			if err := func() error {
				s.VoiceID.Reset()
				if err := s.VoiceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TTSConversationalConfigOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TTSConversationalConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TTSConversationalConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TelephonyProvider as json.
func (s TelephonyProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TelephonyProvider from json.
func (s *TelephonyProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelephonyProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TelephonyProvider(v) {
	case TelephonyProviderTwilio:
		*s = TelephonyProviderTwilio
	case TelephonyProviderSipTrunk:
		*s = TelephonyProviderSipTrunk
	default:
		*s = TelephonyProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TelephonyProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelephonyProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestConditionRationaleCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestConditionRationaleCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.Messages != nil {
			e.FieldStart("messages")
			e.ArrStart()
			for _, elem := range s.Messages {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestConditionRationaleCommonModel = [2]string{
	0: "messages",
	1: "summary",
}

// Decode decodes TestConditionRationaleCommonModel from json.
func (s *TestConditionRationaleCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestConditionRationaleCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "messages":
			if err := func() error {
				s.Messages = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestConditionRationaleCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestConditionRationaleCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestConditionRationaleCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestConditionResultCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestConditionResultCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.Rationale.Set {
			e.FieldStart("rationale")
			s.Rationale.Encode(e)
		}
	}
	{
		e.FieldStart("result")
		s.Result.Encode(e)
	}
}

var jsonFieldsNameOfTestConditionResultCommonModel = [2]string{
	0: "rationale",
	1: "result",
}

// Decode decodes TestConditionResultCommonModel from json.
func (s *TestConditionResultCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestConditionResultCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rationale":
			if err := func() error {
				s.Rationale.Reset()
				if err := s.Rationale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rationale\"")
			}
		case "result":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestConditionResultCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestConditionResultCommonModel) {
					name = jsonFieldsNameOfTestConditionResultCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestConditionResultCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestConditionResultCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestFromConversationMetadataInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestFromConversationMetadataInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("conversation_id")
		e.Str(s.ConversationID)
	}
	{
		if s.OriginalAgentReply != nil {
			e.FieldStart("original_agent_reply")
			e.ArrStart()
			for _, elem := range s.OriginalAgentReply {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkflowNodeID.Set {
			e.FieldStart("workflow_node_id")
			s.WorkflowNodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestFromConversationMetadataInput = [4]string{
	0: "agent_id",
	1: "conversation_id",
	2: "original_agent_reply",
	3: "workflow_node_id",
}

// Decode decodes TestFromConversationMetadataInput from json.
func (s *TestFromConversationMetadataInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestFromConversationMetadataInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "conversation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ConversationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "original_agent_reply":
			if err := func() error {
				s.OriginalAgentReply = make([]ConversationHistoryTranscriptCommonModelInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OriginalAgentReply = append(s.OriginalAgentReply, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_agent_reply\"")
			}
		case "workflow_node_id":
			if err := func() error {
				s.WorkflowNodeID.Reset()
				if err := s.WorkflowNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestFromConversationMetadataInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestFromConversationMetadataInput) {
					name = jsonFieldsNameOfTestFromConversationMetadataInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestFromConversationMetadataInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestFromConversationMetadataInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestFromConversationMetadataOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestFromConversationMetadataOutput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		e.FieldStart("conversation_id")
		e.Str(s.ConversationID)
	}
	{
		if s.OriginalAgentReply != nil {
			e.FieldStart("original_agent_reply")
			e.ArrStart()
			for _, elem := range s.OriginalAgentReply {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkflowNodeID.Set {
			e.FieldStart("workflow_node_id")
			s.WorkflowNodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestFromConversationMetadataOutput = [4]string{
	0: "agent_id",
	1: "conversation_id",
	2: "original_agent_reply",
	3: "workflow_node_id",
}

// Decode decodes TestFromConversationMetadataOutput from json.
func (s *TestFromConversationMetadataOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestFromConversationMetadataOutput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "conversation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ConversationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "original_agent_reply":
			if err := func() error {
				s.OriginalAgentReply = make([]ConversationHistoryTranscriptCommonModelOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OriginalAgentReply = append(s.OriginalAgentReply, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_agent_reply\"")
			}
		case "workflow_node_id":
			if err := func() error {
				s.WorkflowNodeID.Reset()
				if err := s.WorkflowNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestFromConversationMetadataOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestFromConversationMetadataOutput) {
					name = jsonFieldsNameOfTestFromConversationMetadataOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestFromConversationMetadataOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestFromConversationMetadataOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestInvocationSummaryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestInvocationSummaryResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AccessInfo.Set {
			e.FieldStart("access_info")
			s.AccessInfo.Encode(e)
		}
	}
	{
		if s.AgentID.Set {
			e.FieldStart("agent_id")
			s.AgentID.Encode(e)
		}
	}
	{
		if s.BranchID.Set {
			e.FieldStart("branch_id")
			s.BranchID.Encode(e)
		}
	}
	{
		e.FieldStart("created_at_unix_secs")
		e.Int(s.CreatedAtUnixSecs)
	}
	{
		e.FieldStart("failed_count")
		e.Int(s.FailedCount)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("passed_count")
		e.Int(s.PassedCount)
	}
	{
		e.FieldStart("pending_count")
		e.Int(s.PendingCount)
	}
	{
		e.FieldStart("test_run_count")
		e.Int(s.TestRunCount)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfTestInvocationSummaryResponseModel = [10]string{
	0: "access_info",
	1: "agent_id",
	2: "branch_id",
	3: "created_at_unix_secs",
	4: "failed_count",
	5: "id",
	6: "passed_count",
	7: "pending_count",
	8: "test_run_count",
	9: "title",
}

// Decode decodes TestInvocationSummaryResponseModel from json.
func (s *TestInvocationSummaryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestInvocationSummaryResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			if err := func() error {
				s.AccessInfo.Reset()
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "agent_id":
			if err := func() error {
				s.AgentID.Reset()
				if err := s.AgentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "branch_id":
			if err := func() error {
				s.BranchID.Reset()
				if err := s.BranchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_id\"")
			}
		case "created_at_unix_secs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix_secs\"")
			}
		case "failed_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.FailedCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failed_count\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "passed_count":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.PassedCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed_count\"")
			}
		case "pending_count":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.PendingCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pending_count\"")
			}
		case "test_run_count":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TestRunCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_run_count\"")
			}
		case "title":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestInvocationSummaryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111000,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestInvocationSummaryResponseModel) {
					name = jsonFieldsNameOfTestInvocationSummaryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestInvocationSummaryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestInvocationSummaryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestRunMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestRunMetadata) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ran_by_user_email")
		e.Str(s.RanByUserEmail)
	}
	{
		e.FieldStart("test_name")
		e.Str(s.TestName)
	}
	{
		if s.TestType.Set {
			e.FieldStart("test_type")
			s.TestType.Encode(e)
		}
	}
	{
		e.FieldStart("workspace_id")
		e.Str(s.WorkspaceID)
	}
}

var jsonFieldsNameOfTestRunMetadata = [4]string{
	0: "ran_by_user_email",
	1: "test_name",
	2: "test_type",
	3: "workspace_id",
}

// Decode decodes TestRunMetadata from json.
func (s *TestRunMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestRunMetadata to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ran_by_user_email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RanByUserEmail = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ran_by_user_email\"")
			}
		case "test_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TestName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_name\"")
			}
		case "test_type":
			if err := func() error {
				s.TestType.Reset()
				if err := s.TestType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_type\"")
			}
		case "workspace_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.WorkspaceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestRunMetadata")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTestRunMetadata) {
					name = jsonFieldsNameOfTestRunMetadata[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestRunMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestRunMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestRunMetadataTestType as json.
func (s TestRunMetadataTestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestRunMetadataTestType from json.
func (s *TestRunMetadataTestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestRunMetadataTestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestRunMetadataTestType(v) {
	case TestRunMetadataTestTypeLlm:
		*s = TestRunMetadataTestTypeLlm
	case TestRunMetadataTestTypeToolCall:
		*s = TestRunMetadataTestTypeToolCall
	default:
		*s = TestRunMetadataTestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestRunMetadataTestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestRunMetadataTestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestRunStatus as json.
func (s TestRunStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestRunStatus from json.
func (s *TestRunStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestRunStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestRunStatus(v) {
	case TestRunStatusPending:
		*s = TestRunStatusPending
	case TestRunStatusPassed:
		*s = TestRunStatusPassed
	case TestRunStatusFailed:
		*s = TestRunStatusFailed
	default:
		*s = TestRunStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestRunStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestRunStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestToolResultModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestToolResultModel) encodeFields(e *jx.Encoder) {
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestToolResultModel = [3]string{
	0: "reason",
	1: "result_type",
	2: "status",
}

// Decode decodes TestToolResultModel from json.
func (s *TestToolResultModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestToolResultModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestToolResultModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestToolResultModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestToolResultModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestToolResultModelResultType as json.
func (s TestToolResultModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestToolResultModelResultType from json.
func (s *TestToolResultModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestToolResultModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestToolResultModelResultType(v) {
	case TestToolResultModelResultTypeTestingToolResult:
		*s = TestToolResultModelResultTypeTestingToolResult
	default:
		*s = TestToolResultModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestToolResultModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestToolResultModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestToolResultModelStatus as json.
func (s TestToolResultModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestToolResultModelStatus from json.
func (s *TestToolResultModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestToolResultModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestToolResultModelStatus(v) {
	case TestToolResultModelStatusSuccess:
		*s = TestToolResultModelStatusSuccess
	default:
		*s = TestToolResultModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestToolResultModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestToolResultModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestsFeatureUsageCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestsFeatureUsageCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.TestsRanAfterLastModification.Set {
			e.FieldStart("tests_ran_after_last_modification")
			s.TestsRanAfterLastModification.Encode(e)
		}
	}
	{
		if s.TestsRanInLast7Days.Set {
			e.FieldStart("tests_ran_in_last_7_days")
			s.TestsRanInLast7Days.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestsFeatureUsageCommonModel = [3]string{
	0: "enabled",
	1: "tests_ran_after_last_modification",
	2: "tests_ran_in_last_7_days",
}

// Decode decodes TestsFeatureUsageCommonModel from json.
func (s *TestsFeatureUsageCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestsFeatureUsageCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "tests_ran_after_last_modification":
			if err := func() error {
				s.TestsRanAfterLastModification.Reset()
				if err := s.TestsRanAfterLastModification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tests_ran_after_last_modification\"")
			}
		case "tests_ran_in_last_7_days":
			if err := func() error {
				s.TestsRanInLast7Days.Reset()
				if err := s.TestsRanInLast7Days.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tests_ran_in_last_7_days\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestsFeatureUsageCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestsFeatureUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestsFeatureUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TimeRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TimeRange) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("end_ms")
		e.Int(s.EndMs)
	}
	{
		e.FieldStart("start_ms")
		e.Int(s.StartMs)
	}
}

var jsonFieldsNameOfTimeRange = [2]string{
	0: "end_ms",
	1: "start_ms",
}

// Decode decodes TimeRange from json.
func (s *TimeRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TimeRange to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end_ms":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.EndMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_ms\"")
			}
		case "start_ms":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.StartMs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TimeRange")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTimeRange) {
					name = jsonFieldsNameOfTimeRange[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TimeRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TimeRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TokenResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TokenResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
}

var jsonFieldsNameOfTokenResponseModel = [1]string{
	0: "token",
}

// Decode decodes TokenResponseModel from json.
func (s *TokenResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TokenResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TokenResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTokenResponseModel) {
					name = jsonFieldsNameOfTokenResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TokenResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TokenResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tool) encodeFields(e *jx.Encoder) {
	{
		if s.Meta.Set {
			e.FieldStart("_meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Annotations.Set {
			e.FieldStart("annotations")
			s.Annotations.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("inputSchema")
		s.InputSchema.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.OutputSchema.Set {
			e.FieldStart("outputSchema")
			s.OutputSchema.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfTool = [7]string{
	0: "_meta",
	1: "annotations",
	2: "description",
	3: "inputSchema",
	4: "name",
	5: "outputSchema",
	6: "title",
}

// Decode decodes Tool from json.
func (s *Tool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tool to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "_meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"_meta\"")
			}
		case "annotations":
			if err := func() error {
				s.Annotations.Reset()
				if err := s.Annotations.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"annotations\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "inputSchema":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InputSchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputSchema\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "outputSchema":
			if err := func() error {
				s.OutputSchema.Reset()
				if err := s.OutputSchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outputSchema\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tool")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTool) {
					name = jsonFieldsNameOfTool[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ToolAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ToolAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ToolAdditional from json.
func (s *ToolAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolAnnotations) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolAnnotations) encodeFields(e *jx.Encoder) {
	{
		if s.DestructiveHint.Set {
			e.FieldStart("destructiveHint")
			s.DestructiveHint.Encode(e)
		}
	}
	{
		if s.IdempotentHint.Set {
			e.FieldStart("idempotentHint")
			s.IdempotentHint.Encode(e)
		}
	}
	{
		if s.OpenWorldHint.Set {
			e.FieldStart("openWorldHint")
			s.OpenWorldHint.Encode(e)
		}
	}
	{
		if s.ReadOnlyHint.Set {
			e.FieldStart("readOnlyHint")
			s.ReadOnlyHint.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfToolAnnotations = [5]string{
	0: "destructiveHint",
	1: "idempotentHint",
	2: "openWorldHint",
	3: "readOnlyHint",
	4: "title",
}

// Decode decodes ToolAnnotations from json.
func (s *ToolAnnotations) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolAnnotations to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "destructiveHint":
			if err := func() error {
				s.DestructiveHint.Reset()
				if err := s.DestructiveHint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destructiveHint\"")
			}
		case "idempotentHint":
			if err := func() error {
				s.IdempotentHint.Reset()
				if err := s.IdempotentHint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idempotentHint\"")
			}
		case "openWorldHint":
			if err := func() error {
				s.OpenWorldHint.Reset()
				if err := s.OpenWorldHint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openWorldHint\"")
			}
		case "readOnlyHint":
			if err := func() error {
				s.ReadOnlyHint.Reset()
				if err := s.ReadOnlyHint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnlyHint\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolAnnotations")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolAnnotations) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolAnnotations) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ToolAnnotationsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ToolAnnotationsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ToolAnnotationsAdditional from json.
func (s *ToolAnnotationsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolAnnotationsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ToolAnnotationsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolAnnotationsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolAnnotationsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallSoundBehavior as json.
func (s ToolCallSoundBehavior) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolCallSoundBehavior from json.
func (s *ToolCallSoundBehavior) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallSoundBehavior to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolCallSoundBehavior(v) {
	case ToolCallSoundBehaviorAuto:
		*s = ToolCallSoundBehaviorAuto
	case ToolCallSoundBehaviorAlways:
		*s = ToolCallSoundBehaviorAlways
	default:
		*s = ToolCallSoundBehavior(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolCallSoundBehavior) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallSoundBehavior) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolCallSoundType as json.
func (s ToolCallSoundType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolCallSoundType from json.
func (s *ToolCallSoundType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolCallSoundType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolCallSoundType(v) {
	case ToolCallSoundTypeTyping:
		*s = ToolCallSoundTypeTyping
	case ToolCallSoundTypeElevator1:
		*s = ToolCallSoundTypeElevator1
	case ToolCallSoundTypeElevator2:
		*s = ToolCallSoundTypeElevator2
	case ToolCallSoundTypeElevator3:
		*s = ToolCallSoundTypeElevator3
	case ToolCallSoundTypeElevator4:
		*s = ToolCallSoundTypeElevator4
	default:
		*s = ToolCallSoundType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolCallSoundType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolCallSoundType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolExecutionMode as json.
func (s ToolExecutionMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolExecutionMode from json.
func (s *ToolExecutionMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolExecutionMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolExecutionMode(v) {
	case ToolExecutionModeImmediate:
		*s = ToolExecutionModeImmediate
	case ToolExecutionModePostToolSpeech:
		*s = ToolExecutionModePostToolSpeech
	case ToolExecutionModeAsync:
		*s = ToolExecutionModeAsync
	default:
		*s = ToolExecutionMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolExecutionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolExecutionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolInputSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolInputSchema) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfToolInputSchema = [0]string{}

// Decode decodes ToolInputSchema from json.
func (s *ToolInputSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolInputSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ToolInputSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolInputSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolInputSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolMeta) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfToolMeta = [0]string{}

// Decode decodes ToolMeta from json.
func (s *ToolMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ToolMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ToolOutputSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ToolOutputSchema) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfToolOutputSchema = [0]string{}

// Decode decodes ToolOutputSchema from json.
func (s *ToolOutputSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolOutputSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ToolOutputSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ToolOutputSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolOutputSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ToolType as json.
func (s ToolType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ToolType from json.
func (s *ToolType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ToolType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ToolType(v) {
	case ToolTypeSystem:
		*s = ToolTypeSystem
	case ToolTypeWebhook:
		*s = ToolTypeWebhook
	case ToolTypeClient:
		*s = ToolTypeClient
	case ToolTypeMcp:
		*s = ToolTypeMcp
	case ToolTypeWorkflow:
		*s = ToolTypeWorkflow
	case ToolTypeAPIIntegrationWebhook:
		*s = ToolTypeAPIIntegrationWebhook
	case ToolTypeAPIIntegrationMcp:
		*s = ToolTypeAPIIntegrationMcp
	default:
		*s = ToolType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ToolType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ToolType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferToAgentToolResultErrorModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferToAgentToolResultErrorModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		e.FieldStart("from_agent")
		e.Str(s.FromAgent)
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferToAgentToolResultErrorModel = [4]string{
	0: "error",
	1: "from_agent",
	2: "result_type",
	3: "status",
}

// Decode decodes TransferToAgentToolResultErrorModel from json.
func (s *TransferToAgentToolResultErrorModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToAgentToolResultErrorModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "from_agent":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FromAgent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_agent\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferToAgentToolResultErrorModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferToAgentToolResultErrorModel) {
					name = jsonFieldsNameOfTransferToAgentToolResultErrorModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferToAgentToolResultErrorModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToAgentToolResultErrorModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultErrorModelResultType as json.
func (s TransferToAgentToolResultErrorModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToAgentToolResultErrorModelResultType from json.
func (s *TransferToAgentToolResultErrorModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToAgentToolResultErrorModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToAgentToolResultErrorModelResultType(v) {
	case TransferToAgentToolResultErrorModelResultTypeTransferToAgentError:
		*s = TransferToAgentToolResultErrorModelResultTypeTransferToAgentError
	default:
		*s = TransferToAgentToolResultErrorModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToAgentToolResultErrorModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToAgentToolResultErrorModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultErrorModelStatus as json.
func (s TransferToAgentToolResultErrorModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToAgentToolResultErrorModelStatus from json.
func (s *TransferToAgentToolResultErrorModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToAgentToolResultErrorModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToAgentToolResultErrorModelStatus(v) {
	case TransferToAgentToolResultErrorModelStatusError:
		*s = TransferToAgentToolResultErrorModelStatusError
	default:
		*s = TransferToAgentToolResultErrorModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToAgentToolResultErrorModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToAgentToolResultErrorModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferToAgentToolResultSuccessModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferToAgentToolResultSuccessModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("condition")
		e.Str(s.Condition)
	}
	{
		if s.DelayMs.Set {
			e.FieldStart("delay_ms")
			s.DelayMs.Encode(e)
		}
	}
	{
		if s.EnableTransferredAgentFirstMessage.Set {
			e.FieldStart("enable_transferred_agent_first_message")
			s.EnableTransferredAgentFirstMessage.Encode(e)
		}
	}
	{
		e.FieldStart("from_agent")
		e.Str(s.FromAgent)
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("to_agent")
		e.Str(s.ToAgent)
	}
	{
		if s.TransferMessage.Set {
			e.FieldStart("transfer_message")
			s.TransferMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferToAgentToolResultSuccessModel = [8]string{
	0: "condition",
	1: "delay_ms",
	2: "enable_transferred_agent_first_message",
	3: "from_agent",
	4: "result_type",
	5: "status",
	6: "to_agent",
	7: "transfer_message",
}

// Decode decodes TransferToAgentToolResultSuccessModel from json.
func (s *TransferToAgentToolResultSuccessModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToAgentToolResultSuccessModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "condition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Condition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"condition\"")
			}
		case "delay_ms":
			if err := func() error {
				s.DelayMs.Reset()
				if err := s.DelayMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delay_ms\"")
			}
		case "enable_transferred_agent_first_message":
			if err := func() error {
				s.EnableTransferredAgentFirstMessage.Reset()
				if err := s.EnableTransferredAgentFirstMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enable_transferred_agent_first_message\"")
			}
		case "from_agent":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.FromAgent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_agent\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "to_agent":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ToAgent = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_agent\"")
			}
		case "transfer_message":
			if err := func() error {
				s.TransferMessage.Reset()
				if err := s.TransferMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transfer_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferToAgentToolResultSuccessModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferToAgentToolResultSuccessModel) {
					name = jsonFieldsNameOfTransferToAgentToolResultSuccessModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferToAgentToolResultSuccessModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToAgentToolResultSuccessModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultSuccessModelResultType as json.
func (s TransferToAgentToolResultSuccessModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToAgentToolResultSuccessModelResultType from json.
func (s *TransferToAgentToolResultSuccessModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToAgentToolResultSuccessModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToAgentToolResultSuccessModelResultType(v) {
	case TransferToAgentToolResultSuccessModelResultTypeTransferToAgentSuccess:
		*s = TransferToAgentToolResultSuccessModelResultTypeTransferToAgentSuccess
	default:
		*s = TransferToAgentToolResultSuccessModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToAgentToolResultSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToAgentToolResultSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToAgentToolResultSuccessModelStatus as json.
func (s TransferToAgentToolResultSuccessModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToAgentToolResultSuccessModelStatus from json.
func (s *TransferToAgentToolResultSuccessModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToAgentToolResultSuccessModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToAgentToolResultSuccessModelStatus(v) {
	case TransferToAgentToolResultSuccessModelStatusSuccess:
		*s = TransferToAgentToolResultSuccessModelStatusSuccess
	default:
		*s = TransferToAgentToolResultSuccessModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToAgentToolResultSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToAgentToolResultSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferToNumberResultErrorModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferToNumberResultErrorModel) encodeFields(e *jx.Encoder) {
	{
		if s.Details.Set {
			e.FieldStart("details")
			s.Details.Encode(e)
		}
	}
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfTransferToNumberResultErrorModel = [4]string{
	0: "details",
	1: "error",
	2: "result_type",
	3: "status",
}

// Decode decodes TransferToNumberResultErrorModel from json.
func (s *TransferToNumberResultErrorModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultErrorModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "details":
			if err := func() error {
				s.Details.Reset()
				if err := s.Details.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferToNumberResultErrorModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferToNumberResultErrorModel) {
					name = jsonFieldsNameOfTransferToNumberResultErrorModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferToNumberResultErrorModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultErrorModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultErrorModelResultType as json.
func (s TransferToNumberResultErrorModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToNumberResultErrorModelResultType from json.
func (s *TransferToNumberResultErrorModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultErrorModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToNumberResultErrorModelResultType(v) {
	case TransferToNumberResultErrorModelResultTypeTransferToNumberError:
		*s = TransferToNumberResultErrorModelResultTypeTransferToNumberError
	default:
		*s = TransferToNumberResultErrorModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToNumberResultErrorModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultErrorModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultErrorModelStatus as json.
func (s TransferToNumberResultErrorModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToNumberResultErrorModelStatus from json.
func (s *TransferToNumberResultErrorModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultErrorModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToNumberResultErrorModelStatus(v) {
	case TransferToNumberResultErrorModelStatusError:
		*s = TransferToNumberResultErrorModelStatusError
	default:
		*s = TransferToNumberResultErrorModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToNumberResultErrorModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultErrorModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferToNumberResultSipSuccessModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferToNumberResultSipSuccessModel) encodeFields(e *jx.Encoder) {
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("transfer_number")
		e.Str(s.TransferNumber)
	}
}

var jsonFieldsNameOfTransferToNumberResultSipSuccessModel = [5]string{
	0: "note",
	1: "reason",
	2: "result_type",
	3: "status",
	4: "transfer_number",
}

// Decode decodes TransferToNumberResultSipSuccessModel from json.
func (s *TransferToNumberResultSipSuccessModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultSipSuccessModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "transfer_number":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TransferNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transfer_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferToNumberResultSipSuccessModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferToNumberResultSipSuccessModel) {
					name = jsonFieldsNameOfTransferToNumberResultSipSuccessModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferToNumberResultSipSuccessModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultSipSuccessModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultSipSuccessModelResultType as json.
func (s TransferToNumberResultSipSuccessModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToNumberResultSipSuccessModelResultType from json.
func (s *TransferToNumberResultSipSuccessModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultSipSuccessModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToNumberResultSipSuccessModelResultType(v) {
	case TransferToNumberResultSipSuccessModelResultTypeTransferToNumberSipSuccess:
		*s = TransferToNumberResultSipSuccessModelResultTypeTransferToNumberSipSuccess
	default:
		*s = TransferToNumberResultSipSuccessModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToNumberResultSipSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultSipSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultSipSuccessModelStatus as json.
func (s TransferToNumberResultSipSuccessModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToNumberResultSipSuccessModelStatus from json.
func (s *TransferToNumberResultSipSuccessModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultSipSuccessModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToNumberResultSipSuccessModelStatus(v) {
	case TransferToNumberResultSipSuccessModelStatusSuccess:
		*s = TransferToNumberResultSipSuccessModelStatusSuccess
	default:
		*s = TransferToNumberResultSipSuccessModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToNumberResultSipSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultSipSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransferToNumberResultTwilioSuccessModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransferToNumberResultTwilioSuccessModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_message")
		e.Str(s.AgentMessage)
	}
	{
		if s.ClientMessage.Set {
			e.FieldStart("client_message")
			s.ClientMessage.Encode(e)
		}
	}
	{
		e.FieldStart("conference_name")
		e.Str(s.ConferenceName)
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("transfer_number")
		e.Str(s.TransferNumber)
	}
}

var jsonFieldsNameOfTransferToNumberResultTwilioSuccessModel = [8]string{
	0: "agent_message",
	1: "client_message",
	2: "conference_name",
	3: "note",
	4: "reason",
	5: "result_type",
	6: "status",
	7: "transfer_number",
}

// Decode decodes TransferToNumberResultTwilioSuccessModel from json.
func (s *TransferToNumberResultTwilioSuccessModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultTwilioSuccessModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_message\"")
			}
		case "client_message":
			if err := func() error {
				s.ClientMessage.Reset()
				if err := s.ClientMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_message\"")
			}
		case "conference_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ConferenceName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conference_name\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "transfer_number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TransferNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transfer_number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransferToNumberResultTwilioSuccessModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransferToNumberResultTwilioSuccessModel) {
					name = jsonFieldsNameOfTransferToNumberResultTwilioSuccessModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransferToNumberResultTwilioSuccessModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultTwilioSuccessModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultTwilioSuccessModelResultType as json.
func (s TransferToNumberResultTwilioSuccessModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToNumberResultTwilioSuccessModelResultType from json.
func (s *TransferToNumberResultTwilioSuccessModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultTwilioSuccessModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToNumberResultTwilioSuccessModelResultType(v) {
	case TransferToNumberResultTwilioSuccessModelResultTypeTransferToNumberTwilioSuccess:
		*s = TransferToNumberResultTwilioSuccessModelResultTypeTransferToNumberTwilioSuccess
	default:
		*s = TransferToNumberResultTwilioSuccessModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToNumberResultTwilioSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultTwilioSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransferToNumberResultTwilioSuccessModelStatus as json.
func (s TransferToNumberResultTwilioSuccessModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TransferToNumberResultTwilioSuccessModelStatus from json.
func (s *TransferToNumberResultTwilioSuccessModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransferToNumberResultTwilioSuccessModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TransferToNumberResultTwilioSuccessModelStatus(v) {
	case TransferToNumberResultTwilioSuccessModelStatusSuccess:
		*s = TransferToNumberResultTwilioSuccessModelStatusSuccess
	default:
		*s = TransferToNumberResultTwilioSuccessModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransferToNumberResultTwilioSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransferToNumberResultTwilioSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TurnConfigOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TurnConfigOverride) encodeFields(e *jx.Encoder) {
	{
		if s.SoftTimeoutConfig.Set {
			e.FieldStart("soft_timeout_config")
			s.SoftTimeoutConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfTurnConfigOverride = [1]string{
	0: "soft_timeout_config",
}

// Decode decodes TurnConfigOverride from json.
func (s *TurnConfigOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TurnConfigOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "soft_timeout_config":
			if err := func() error {
				s.SoftTimeoutConfig.Reset()
				if err := s.SoftTimeoutConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"soft_timeout_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TurnConfigOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TurnConfigOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TurnConfigOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TwilioOutboundCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TwilioOutboundCallResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("callSid")
		s.CallSid.Encode(e)
	}
	{
		e.FieldStart("conversation_id")
		s.ConversationID.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfTwilioOutboundCallResponse = [4]string{
	0: "callSid",
	1: "conversation_id",
	2: "message",
	3: "success",
}

// Decode decodes TwilioOutboundCallResponse from json.
func (s *TwilioOutboundCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TwilioOutboundCallResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "callSid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CallSid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callSid\"")
			}
		case "conversation_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TwilioOutboundCallResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTwilioOutboundCallResponse) {
					name = jsonFieldsNameOfTwilioOutboundCallResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TwilioOutboundCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TwilioOutboundCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TxtExportOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TxtExportOptions) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("format")
		s.Format.Encode(e)
	}
	{
		if s.IncludeSpeakers.Set {
			e.FieldStart("include_speakers")
			s.IncludeSpeakers.Encode(e)
		}
	}
	{
		if s.IncludeTimestamps.Set {
			e.FieldStart("include_timestamps")
			s.IncludeTimestamps.Encode(e)
		}
	}
	{
		if s.MaxCharactersPerLine.Set {
			e.FieldStart("max_characters_per_line")
			s.MaxCharactersPerLine.Encode(e)
		}
	}
	{
		if s.MaxSegmentChars.Set {
			e.FieldStart("max_segment_chars")
			s.MaxSegmentChars.Encode(e)
		}
	}
	{
		if s.MaxSegmentDurationS.Set {
			e.FieldStart("max_segment_duration_s")
			s.MaxSegmentDurationS.Encode(e)
		}
	}
	{
		if s.SegmentOnSilenceLongerThanS.Set {
			e.FieldStart("segment_on_silence_longer_than_s")
			s.SegmentOnSilenceLongerThanS.Encode(e)
		}
	}
}

var jsonFieldsNameOfTxtExportOptions = [7]string{
	0: "format",
	1: "include_speakers",
	2: "include_timestamps",
	3: "max_characters_per_line",
	4: "max_segment_chars",
	5: "max_segment_duration_s",
	6: "segment_on_silence_longer_than_s",
}

// Decode decodes TxtExportOptions from json.
func (s *TxtExportOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TxtExportOptions to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "format":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		case "include_speakers":
			if err := func() error {
				s.IncludeSpeakers.Reset()
				if err := s.IncludeSpeakers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_speakers\"")
			}
		case "include_timestamps":
			if err := func() error {
				s.IncludeTimestamps.Reset()
				if err := s.IncludeTimestamps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"include_timestamps\"")
			}
		case "max_characters_per_line":
			if err := func() error {
				s.MaxCharactersPerLine.Reset()
				if err := s.MaxCharactersPerLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_characters_per_line\"")
			}
		case "max_segment_chars":
			if err := func() error {
				s.MaxSegmentChars.Reset()
				if err := s.MaxSegmentChars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_chars\"")
			}
		case "max_segment_duration_s":
			if err := func() error {
				s.MaxSegmentDurationS.Reset()
				if err := s.MaxSegmentDurationS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_segment_duration_s\"")
			}
		case "segment_on_silence_longer_than_s":
			if err := func() error {
				s.SegmentOnSilenceLongerThanS.Reset()
				if err := s.SegmentOnSilenceLongerThanS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment_on_silence_longer_than_s\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TxtExportOptions")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTxtExportOptions) {
					name = jsonFieldsNameOfTxtExportOptions[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TxtExportOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TxtExportOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TxtExportOptionsFormat as json.
func (s TxtExportOptionsFormat) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TxtExportOptionsFormat from json.
func (s *TxtExportOptionsFormat) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TxtExportOptionsFormat to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TxtExportOptionsFormat(v) {
	case TxtExportOptionsFormatTxt:
		*s = TxtExportOptionsFormatTxt
	default:
		*s = TxtExportOptionsFormat(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TxtExportOptionsFormat) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TxtExportOptionsFormat) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnitTestCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnitTestCommonModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_history")
		e.ArrStart()
		for _, elem := range s.ChatHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		e.FieldStart("failure_examples")
		e.ArrStart()
		for _, elem := range s.FailureExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FromConversationMetadata.Set {
			e.FieldStart("from_conversation_metadata")
			s.FromConversationMetadata.Encode(e)
		}
	}
	{
		e.FieldStart("success_condition")
		e.Str(s.SuccessCondition)
	}
	{
		e.FieldStart("success_examples")
		e.ArrStart()
		for _, elem := range s.SuccessExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ToolCallParameters.Set {
			e.FieldStart("tool_call_parameters")
			s.ToolCallParameters.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnitTestCommonModel = [8]string{
	0: "chat_history",
	1: "dynamic_variables",
	2: "failure_examples",
	3: "from_conversation_metadata",
	4: "success_condition",
	5: "success_examples",
	6: "tool_call_parameters",
	7: "type",
}

// Decode decodes UnitTestCommonModel from json.
func (s *UnitTestCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestCommonModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_history":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ChatHistory = make([]ConversationHistoryTranscriptCommonModelOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChatHistory = append(s.ChatHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_history\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "failure_examples":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FailureExamples = make([]AgentFailureResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentFailureResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailureExamples = append(s.FailureExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_examples\"")
			}
		case "from_conversation_metadata":
			if err := func() error {
				s.FromConversationMetadata.Reset()
				if err := s.FromConversationMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_conversation_metadata\"")
			}
		case "success_condition":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SuccessCondition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_condition\"")
			}
		case "success_examples":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.SuccessExamples = make([]AgentSuccessfulResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentSuccessfulResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SuccessExamples = append(s.SuccessExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_examples\"")
			}
		case "tool_call_parameters":
			if err := func() error {
				s.ToolCallParameters.Reset()
				if err := s.ToolCallParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_parameters\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestCommonModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnitTestCommonModel) {
					name = jsonFieldsNameOfUnitTestCommonModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnitTestCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UnitTestCommonModelDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UnitTestCommonModelDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes UnitTestCommonModelDynamicVariables from json.
func (s *UnitTestCommonModelDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestCommonModelDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilUnitTestCommonModelDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestCommonModelDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnitTestCommonModelDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestCommonModelDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestCommonModelDynamicVariablesItem as json.
func (s UnitTestCommonModelDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringUnitTestCommonModelDynamicVariablesItem:
		e.Str(s.String)
	case Float64UnitTestCommonModelDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntUnitTestCommonModelDynamicVariablesItem:
		e.Int(s.Int)
	case BoolUnitTestCommonModelDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes UnitTestCommonModelDynamicVariablesItem from json.
func (s *UnitTestCommonModelDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestCommonModelDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolUnitTestCommonModelDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntUnitTestCommonModelDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64UnitTestCommonModelDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUnitTestCommonModelDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnitTestCommonModelDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestCommonModelDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestCommonModelType as json.
func (s UnitTestCommonModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnitTestCommonModelType from json.
func (s *UnitTestCommonModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestCommonModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnitTestCommonModelType(v) {
	case UnitTestCommonModelTypeLlm:
		*s = UnitTestCommonModelTypeLlm
	case UnitTestCommonModelTypeTool:
		*s = UnitTestCommonModelTypeTool
	default:
		*s = UnitTestCommonModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnitTestCommonModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestCommonModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnitTestRunResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnitTestRunResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("agent_id")
		e.Str(s.AgentID)
	}
	{
		if s.AgentResponses.Set {
			e.FieldStart("agent_responses")
			s.AgentResponses.Encode(e)
		}
	}
	{
		if s.BranchID.Set {
			e.FieldStart("branch_id")
			s.BranchID.Encode(e)
		}
	}
	{
		if s.ConditionResult.Set {
			e.FieldStart("condition_result")
			s.ConditionResult.Encode(e)
		}
	}
	{
		if s.LastUpdatedAtUnix.Set {
			e.FieldStart("last_updated_at_unix")
			s.LastUpdatedAtUnix.Encode(e)
		}
	}
	{
		if s.Metadata.Set {
			e.FieldStart("metadata")
			s.Metadata.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("test_id")
		e.Str(s.TestID)
	}
	{
		if s.TestInfo.Set {
			e.FieldStart("test_info")
			s.TestInfo.Encode(e)
		}
	}
	{
		e.FieldStart("test_invocation_id")
		e.Str(s.TestInvocationID)
	}
	{
		if s.TestName.Set {
			e.FieldStart("test_name")
			s.TestName.Encode(e)
		}
	}
	{
		e.FieldStart("test_run_id")
		e.Str(s.TestRunID)
	}
	{
		if s.WorkflowNodeID.Set {
			e.FieldStart("workflow_node_id")
			s.WorkflowNodeID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnitTestRunResponseModel = [13]string{
	0:  "agent_id",
	1:  "agent_responses",
	2:  "branch_id",
	3:  "condition_result",
	4:  "last_updated_at_unix",
	5:  "metadata",
	6:  "status",
	7:  "test_id",
	8:  "test_info",
	9:  "test_invocation_id",
	10: "test_name",
	11: "test_run_id",
	12: "workflow_node_id",
}

// Decode decodes UnitTestRunResponseModel from json.
func (s *UnitTestRunResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestRunResponseModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AgentID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "agent_responses":
			if err := func() error {
				s.AgentResponses.Reset()
				if err := s.AgentResponses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_responses\"")
			}
		case "branch_id":
			if err := func() error {
				s.BranchID.Reset()
				if err := s.BranchID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"branch_id\"")
			}
		case "condition_result":
			if err := func() error {
				s.ConditionResult.Reset()
				if err := s.ConditionResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"condition_result\"")
			}
		case "last_updated_at_unix":
			if err := func() error {
				s.LastUpdatedAtUnix.Reset()
				if err := s.LastUpdatedAtUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at_unix\"")
			}
		case "metadata":
			if err := func() error {
				s.Metadata.Reset()
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "test_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_id\"")
			}
		case "test_info":
			if err := func() error {
				s.TestInfo.Reset()
				if err := s.TestInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_info\"")
			}
		case "test_invocation_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TestInvocationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_invocation_id\"")
			}
		case "test_name":
			if err := func() error {
				s.TestName.Reset()
				if err := s.TestName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_name\"")
			}
		case "test_run_id":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TestRunID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"test_run_id\"")
			}
		case "workflow_node_id":
			if err := func() error {
				s.WorkflowNodeID.Reset()
				if err := s.WorkflowNodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflow_node_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestRunResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000001,
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnitTestRunResponseModel) {
					name = jsonFieldsNameOfUnitTestRunResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnitTestRunResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestRunResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnitTestSummaryResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnitTestSummaryResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.AccessInfo.Set {
			e.FieldStart("access_info")
			s.AccessInfo.Encode(e)
		}
	}
	{
		e.FieldStart("created_at_unix_secs")
		e.Int(s.CreatedAtUnixSecs)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("last_updated_at_unix_secs")
		e.Int(s.LastUpdatedAtUnixSecs)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
}

var jsonFieldsNameOfUnitTestSummaryResponseModel = [6]string{
	0: "access_info",
	1: "created_at_unix_secs",
	2: "id",
	3: "last_updated_at_unix_secs",
	4: "name",
	5: "type",
}

// Decode decodes UnitTestSummaryResponseModel from json.
func (s *UnitTestSummaryResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestSummaryResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_info":
			if err := func() error {
				s.AccessInfo.Reset()
				if err := s.AccessInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_info\"")
			}
		case "created_at_unix_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix_secs\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "last_updated_at_unix_secs":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.LastUpdatedAtUnixSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_updated_at_unix_secs\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestSummaryResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnitTestSummaryResponseModel) {
					name = jsonFieldsNameOfUnitTestSummaryResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnitTestSummaryResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestSummaryResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnitTestToolCallEvaluationModelInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnitTestToolCallEvaluationModelInput) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReferencedTool.Set {
			e.FieldStart("referenced_tool")
			s.ReferencedTool.Encode(e)
		}
	}
	{
		if s.VerifyAbsence.Set {
			e.FieldStart("verify_absence")
			s.VerifyAbsence.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnitTestToolCallEvaluationModelInput = [3]string{
	0: "parameters",
	1: "referenced_tool",
	2: "verify_absence",
}

// Decode decodes UnitTestToolCallEvaluationModelInput from json.
func (s *UnitTestToolCallEvaluationModelInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestToolCallEvaluationModelInput to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]UnitTestToolCallParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UnitTestToolCallParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "referenced_tool":
			if err := func() error {
				s.ReferencedTool.Reset()
				if err := s.ReferencedTool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenced_tool\"")
			}
		case "verify_absence":
			if err := func() error {
				s.VerifyAbsence.Reset()
				if err := s.VerifyAbsence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_absence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestToolCallEvaluationModelInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnitTestToolCallEvaluationModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestToolCallEvaluationModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnitTestToolCallEvaluationModelOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnitTestToolCallEvaluationModelOutput) encodeFields(e *jx.Encoder) {
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ReferencedTool.Set {
			e.FieldStart("referenced_tool")
			s.ReferencedTool.Encode(e)
		}
	}
	{
		if s.VerifyAbsence.Set {
			e.FieldStart("verify_absence")
			s.VerifyAbsence.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnitTestToolCallEvaluationModelOutput = [3]string{
	0: "parameters",
	1: "referenced_tool",
	2: "verify_absence",
}

// Decode decodes UnitTestToolCallEvaluationModelOutput from json.
func (s *UnitTestToolCallEvaluationModelOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestToolCallEvaluationModelOutput to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parameters":
			if err := func() error {
				s.Parameters = make([]UnitTestToolCallParameter, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UnitTestToolCallParameter
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "referenced_tool":
			if err := func() error {
				s.ReferencedTool.Reset()
				if err := s.ReferencedTool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenced_tool\"")
			}
		case "verify_absence":
			if err := func() error {
				s.VerifyAbsence.Reset()
				if err := s.VerifyAbsence.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_absence\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestToolCallEvaluationModelOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnitTestToolCallEvaluationModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestToolCallEvaluationModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnitTestToolCallParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnitTestToolCallParameter) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eval")
		s.Eval.Encode(e)
	}
	{
		e.FieldStart("path")
		e.Str(s.Path)
	}
}

var jsonFieldsNameOfUnitTestToolCallParameter = [2]string{
	0: "eval",
	1: "path",
}

// Decode decodes UnitTestToolCallParameter from json.
func (s *UnitTestToolCallParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestToolCallParameter to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eval":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Eval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eval\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Path = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnitTestToolCallParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnitTestToolCallParameter) {
					name = jsonFieldsNameOfUnitTestToolCallParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnitTestToolCallParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestToolCallParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnitTestToolCallParameterEval as json.
func (s UnitTestToolCallParameterEval) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s UnitTestToolCallParameterEval) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case LLMParameterEvaluationStrategyUnitTestToolCallParameterEval:
		e.FieldStart("type")
		e.Str("llm")
		{
			s := s.LLMParameterEvaluationStrategy
			{
				e.FieldStart("description")
				e.Str(s.Description)
			}
		}
	case RegexParameterEvaluationStrategyUnitTestToolCallParameterEval:
		e.FieldStart("type")
		e.Str("regex")
		{
			s := s.RegexParameterEvaluationStrategy
			{
				e.FieldStart("pattern")
				e.Str(s.Pattern)
			}
		}
	case ExactParameterEvaluationStrategyUnitTestToolCallParameterEval:
		e.FieldStart("type")
		e.Str("exact")
		{
			s := s.ExactParameterEvaluationStrategy
			{
				e.FieldStart("expected_value")
				e.Str(s.ExpectedValue)
			}
		}
	case MatchAnythingParameterEvaluationStrategyUnitTestToolCallParameterEval:
		e.FieldStart("type")
		e.Str("anything")
	}
}

// Decode decodes UnitTestToolCallParameterEval from json.
func (s *UnitTestToolCallParameterEval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnitTestToolCallParameterEval to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "llm":
					s.Type = LLMParameterEvaluationStrategyUnitTestToolCallParameterEval
					found = true
				case "regex":
					s.Type = RegexParameterEvaluationStrategyUnitTestToolCallParameterEval
					found = true
				case "exact":
					s.Type = ExactParameterEvaluationStrategyUnitTestToolCallParameterEval
					found = true
				case "anything":
					s.Type = MatchAnythingParameterEvaluationStrategyUnitTestToolCallParameterEval
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case LLMParameterEvaluationStrategyUnitTestToolCallParameterEval:
		if err := s.LLMParameterEvaluationStrategy.Decode(d); err != nil {
			return err
		}
	case RegexParameterEvaluationStrategyUnitTestToolCallParameterEval:
		if err := s.RegexParameterEvaluationStrategy.Decode(d); err != nil {
			return err
		}
	case ExactParameterEvaluationStrategyUnitTestToolCallParameterEval:
		if err := s.ExactParameterEvaluationStrategy.Decode(d); err != nil {
			return err
		}
	case MatchAnythingParameterEvaluationStrategyUnitTestToolCallParameterEval:
		if err := s.MatchAnythingParameterEvaluationStrategy.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnitTestToolCallParameterEval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnitTestToolCallParameterEval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnshareResourceEndpointOKApplicationJSON as json.
func (s UnshareResourceEndpointOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes UnshareResourceEndpointOKApplicationJSON from json.
func (s *UnshareResourceEndpointOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnshareResourceEndpointOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UnshareResourceEndpointOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnshareResourceEndpointOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnshareResourceEndpointOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDocumentRouteOK as json.
func (s UpdateDocumentRouteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s UpdateDocumentRouteOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetKnowledgeBaseURLResponseModelUpdateDocumentRouteOK:
		e.FieldStart("type")
		e.Str("url")
		{
			s := s.GetKnowledgeBaseURLResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("extracted_inner_html")
				e.Str(s.ExtractedInnerHTML)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("url")
				e.Str(s.URL)
			}
		}
	case GetKnowledgeBaseFileResponseModelUpdateDocumentRouteOK:
		e.FieldStart("type")
		e.Str("file")
		{
			s := s.GetKnowledgeBaseFileResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("extracted_inner_html")
				e.Str(s.ExtractedInnerHTML)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseTextResponseModelUpdateDocumentRouteOK:
		e.FieldStart("type")
		e.Str("text")
		{
			s := s.GetKnowledgeBaseTextResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("extracted_inner_html")
				e.Str(s.ExtractedInnerHTML)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	case GetKnowledgeBaseFolderResponseModelUpdateDocumentRouteOK:
		e.FieldStart("type")
		e.Str("folder")
		{
			s := s.GetKnowledgeBaseFolderResponseModel
			{
				e.FieldStart("access_info")
				s.AccessInfo.Encode(e)
			}
			{
				e.FieldStart("children_count")
				e.Int(s.ChildrenCount)
			}
			{
				if s.FolderParentID.Set {
					e.FieldStart("folder_parent_id")
					s.FolderParentID.Encode(e)
				}
			}
			{
				if s.FolderPath != nil {
					e.FieldStart("folder_path")
					e.ArrStart()
					for _, elem := range s.FolderPath {
						elem.Encode(e)
					}
					e.ArrEnd()
				}
			}
			{
				e.FieldStart("id")
				e.Str(s.ID)
			}
			{
				e.FieldStart("metadata")
				s.Metadata.Encode(e)
			}
			{
				e.FieldStart("name")
				e.Str(s.Name)
			}
			{
				e.FieldStart("supported_usages")
				e.ArrStart()
				for _, elem := range s.SupportedUsages {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
		}
	}
}

// Decode decodes UpdateDocumentRouteOK from json.
func (s *UpdateDocumentRouteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDocumentRouteOK to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "url":
					s.Type = GetKnowledgeBaseURLResponseModelUpdateDocumentRouteOK
					found = true
				case "file":
					s.Type = GetKnowledgeBaseFileResponseModelUpdateDocumentRouteOK
					found = true
				case "text":
					s.Type = GetKnowledgeBaseTextResponseModelUpdateDocumentRouteOK
					found = true
				case "folder":
					s.Type = GetKnowledgeBaseFolderResponseModelUpdateDocumentRouteOK
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetKnowledgeBaseURLResponseModelUpdateDocumentRouteOK:
		if err := s.GetKnowledgeBaseURLResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseFileResponseModelUpdateDocumentRouteOK:
		if err := s.GetKnowledgeBaseFileResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseTextResponseModelUpdateDocumentRouteOK:
		if err := s.GetKnowledgeBaseTextResponseModel.Decode(d); err != nil {
			return err
		}
	case GetKnowledgeBaseFolderResponseModelUpdateDocumentRouteOK:
		if err := s.GetKnowledgeBaseFolderResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDocumentRouteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDocumentRouteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePhoneNumberRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePhoneNumberRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AgentID.Set {
			e.FieldStart("agent_id")
			s.AgentID.Encode(e)
		}
	}
	{
		if s.InboundTrunkConfig.Set {
			e.FieldStart("inbound_trunk_config")
			s.InboundTrunkConfig.Encode(e)
		}
	}
	{
		if s.LivekitStack.Set {
			e.FieldStart("livekit_stack")
			s.LivekitStack.Encode(e)
		}
	}
	{
		if s.OutboundTrunkConfig.Set {
			e.FieldStart("outbound_trunk_config")
			s.OutboundTrunkConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePhoneNumberRequest = [4]string{
	0: "agent_id",
	1: "inbound_trunk_config",
	2: "livekit_stack",
	3: "outbound_trunk_config",
}

// Decode decodes UpdatePhoneNumberRequest from json.
func (s *UpdatePhoneNumberRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePhoneNumberRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "agent_id":
			if err := func() error {
				s.AgentID.Reset()
				if err := s.AgentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"agent_id\"")
			}
		case "inbound_trunk_config":
			if err := func() error {
				s.InboundTrunkConfig.Reset()
				if err := s.InboundTrunkConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound_trunk_config\"")
			}
		case "livekit_stack":
			if err := func() error {
				s.LivekitStack.Reset()
				if err := s.LivekitStack.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livekit_stack\"")
			}
		case "outbound_trunk_config":
			if err := func() error {
				s.OutboundTrunkConfig.Reset()
				if err := s.OutboundTrunkConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outbound_trunk_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePhoneNumberRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePhoneNumberRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePhoneNumberRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdatePhoneNumberRouteOK as json.
func (s UpdatePhoneNumberRouteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s UpdatePhoneNumberRouteOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case GetPhoneNumberTwilioResponseModelUpdatePhoneNumberRouteOK:
		e.FieldStart("provider")
		e.Str("twilio")
		{
			s := s.GetPhoneNumberTwilioResponseModel
			{
				if s.AssignedAgent.Set {
					e.FieldStart("assigned_agent")
					s.AssignedAgent.Encode(e)
				}
			}
			{
				e.FieldStart("label")
				e.Str(s.Label)
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				if s.SupportsInbound.Set {
					e.FieldStart("supports_inbound")
					s.SupportsInbound.Encode(e)
				}
			}
			{
				if s.SupportsOutbound.Set {
					e.FieldStart("supports_outbound")
					s.SupportsOutbound.Encode(e)
				}
			}
		}
	case GetPhoneNumberSIPTrunkResponseModelUpdatePhoneNumberRouteOK:
		e.FieldStart("provider")
		e.Str("sip_trunk")
		{
			s := s.GetPhoneNumberSIPTrunkResponseModel
			{
				if s.AssignedAgent.Set {
					e.FieldStart("assigned_agent")
					s.AssignedAgent.Encode(e)
				}
			}
			{
				if s.InboundTrunk.Set {
					e.FieldStart("inbound_trunk")
					s.InboundTrunk.Encode(e)
				}
			}
			{
				e.FieldStart("label")
				e.Str(s.Label)
			}
			{
				e.FieldStart("livekit_stack")
				s.LivekitStack.Encode(e)
			}
			{
				if s.OutboundTrunk.Set {
					e.FieldStart("outbound_trunk")
					s.OutboundTrunk.Encode(e)
				}
			}
			{
				e.FieldStart("phone_number")
				e.Str(s.PhoneNumber)
			}
			{
				e.FieldStart("phone_number_id")
				e.Str(s.PhoneNumberID)
			}
			{
				if s.ProviderConfig.Set {
					e.FieldStart("provider_config")
					s.ProviderConfig.Encode(e)
				}
			}
			{
				if s.SupportsInbound.Set {
					e.FieldStart("supports_inbound")
					s.SupportsInbound.Encode(e)
				}
			}
			{
				if s.SupportsOutbound.Set {
					e.FieldStart("supports_outbound")
					s.SupportsOutbound.Encode(e)
				}
			}
		}
	}
}

// Decode decodes UpdatePhoneNumberRouteOK from json.
func (s *UpdatePhoneNumberRouteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePhoneNumberRouteOK to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "provider":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "twilio":
					s.Type = GetPhoneNumberTwilioResponseModelUpdatePhoneNumberRouteOK
					found = true
				case "sip_trunk":
					s.Type = GetPhoneNumberSIPTrunkResponseModelUpdatePhoneNumberRouteOK
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case GetPhoneNumberTwilioResponseModelUpdatePhoneNumberRouteOK:
		if err := s.GetPhoneNumberTwilioResponseModel.Decode(d); err != nil {
			return err
		}
	case GetPhoneNumberSIPTrunkResponseModelUpdatePhoneNumberRouteOK:
		if err := s.GetPhoneNumberSIPTrunkResponseModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdatePhoneNumberRouteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePhoneNumberRouteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUnitTestRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUnitTestRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("chat_history")
		e.ArrStart()
		for _, elem := range s.ChatHistory {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.DynamicVariables.Set {
			e.FieldStart("dynamic_variables")
			s.DynamicVariables.Encode(e)
		}
	}
	{
		e.FieldStart("failure_examples")
		e.ArrStart()
		for _, elem := range s.FailureExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.FromConversationMetadata.Set {
			e.FieldStart("from_conversation_metadata")
			s.FromConversationMetadata.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("success_condition")
		e.Str(s.SuccessCondition)
	}
	{
		e.FieldStart("success_examples")
		e.ArrStart()
		for _, elem := range s.SuccessExamples {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ToolCallParameters.Set {
			e.FieldStart("tool_call_parameters")
			s.ToolCallParameters.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateUnitTestRequest = [9]string{
	0: "chat_history",
	1: "dynamic_variables",
	2: "failure_examples",
	3: "from_conversation_metadata",
	4: "name",
	5: "success_condition",
	6: "success_examples",
	7: "tool_call_parameters",
	8: "type",
}

// Decode decodes UpdateUnitTestRequest from json.
func (s *UpdateUnitTestRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUnitTestRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "chat_history":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ChatHistory = make([]ConversationHistoryTranscriptCommonModelInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptCommonModelInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChatHistory = append(s.ChatHistory, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"chat_history\"")
			}
		case "dynamic_variables":
			if err := func() error {
				s.DynamicVariables.Reset()
				if err := s.DynamicVariables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dynamic_variables\"")
			}
		case "failure_examples":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.FailureExamples = make([]AgentFailureResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentFailureResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailureExamples = append(s.FailureExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failure_examples\"")
			}
		case "from_conversation_metadata":
			if err := func() error {
				s.FromConversationMetadata.Reset()
				if err := s.FromConversationMetadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from_conversation_metadata\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "success_condition":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SuccessCondition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_condition\"")
			}
		case "success_examples":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.SuccessExamples = make([]AgentSuccessfulResponseExample, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AgentSuccessfulResponseExample
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SuccessExamples = append(s.SuccessExamples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success_examples\"")
			}
		case "tool_call_parameters":
			if err := func() error {
				s.ToolCallParameters.Reset()
				if err := s.ToolCallParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_call_parameters\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUnitTestRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUnitTestRequest) {
					name = jsonFieldsNameOfUpdateUnitTestRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUnitTestRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUnitTestRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateUnitTestRequestDynamicVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateUnitTestRequestDynamicVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes UpdateUnitTestRequestDynamicVariables from json.
func (s *UpdateUnitTestRequestDynamicVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUnitTestRequestDynamicVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem NilUpdateUnitTestRequestDynamicVariablesItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUnitTestRequestDynamicVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUnitTestRequestDynamicVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUnitTestRequestDynamicVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUnitTestRequestDynamicVariablesItem as json.
func (s UpdateUnitTestRequestDynamicVariablesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringUpdateUnitTestRequestDynamicVariablesItem:
		e.Str(s.String)
	case Float64UpdateUnitTestRequestDynamicVariablesItem:
		e.Float64(s.Float64)
	case IntUpdateUnitTestRequestDynamicVariablesItem:
		e.Int(s.Int)
	case BoolUpdateUnitTestRequestDynamicVariablesItem:
		e.Bool(s.Bool)
	}
}

// Decode decodes UpdateUnitTestRequestDynamicVariablesItem from json.
func (s *UpdateUnitTestRequestDynamicVariablesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUnitTestRequestDynamicVariablesItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolUpdateUnitTestRequestDynamicVariablesItem
	case jx.Number:
		num, err := d.Num()
		if err != nil {
			return errors.Wrap(err, "parse number")
		}
		if d := jx.DecodeBytes(num); num.IsInt() {
			v, err := d.Int()
			s.Int = int(v)
			if err != nil {
				return err
			}
			s.Type = IntUpdateUnitTestRequestDynamicVariablesItem
		} else {
			v, err := d.Float64()
			s.Float64 = float64(v)
			if err != nil {
				return err
			}
			s.Type = Float64UpdateUnitTestRequestDynamicVariablesItem
		}
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringUpdateUnitTestRequestDynamicVariablesItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUnitTestRequestDynamicVariablesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUnitTestRequestDynamicVariablesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateWhatsAppAccountRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateWhatsAppAccountRequest) encodeFields(e *jx.Encoder) {
	{
		if s.AssignedAgentID.Set {
			e.FieldStart("assigned_agent_id")
			s.AssignedAgentID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateWhatsAppAccountRequest = [1]string{
	0: "assigned_agent_id",
}

// Decode decodes UpdateWhatsAppAccountRequest from json.
func (s *UpdateWhatsAppAccountRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWhatsAppAccountRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "assigned_agent_id":
			if err := func() error {
				s.AssignedAgentID.Reset()
				if err := s.AssignedAgentID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assigned_agent_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateWhatsAppAccountRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWhatsAppAccountRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWhatsAppAccountRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateWhatsappAccountOKApplicationJSON as json.
func (s UpdateWhatsappAccountOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes UpdateWhatsappAccountOKApplicationJSON from json.
func (s *UpdateWhatsappAccountOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWhatsappAccountOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateWhatsappAccountOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateWhatsappAccountOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWhatsappAccountOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateWorkspaceMemberResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateWorkspaceMemberResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfUpdateWorkspaceMemberResponseModel = [1]string{
	0: "status",
}

// Decode decodes UpdateWorkspaceMemberResponseModel from json.
func (s *UpdateWorkspaceMemberResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateWorkspaceMemberResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateWorkspaceMemberResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateWorkspaceMemberResponseModel) {
					name = jsonFieldsNameOfUpdateWorkspaceMemberResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateWorkspaceMemberResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateWorkspaceMemberResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsageCharactersResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsageCharactersResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("time")
		e.ArrStart()
		for _, elem := range s.Time {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfUsageCharactersResponseModel = [2]string{
	0: "time",
	1: "usage",
}

// Decode decodes UsageCharactersResponseModel from json.
func (s *UsageCharactersResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageCharactersResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Time = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.Time = append(s.Time, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageCharactersResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsageCharactersResponseModel) {
					name = jsonFieldsNameOfUsageCharactersResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsageCharactersResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageCharactersResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UsageCharactersResponseModelUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UsageCharactersResponseModelUsage) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes UsageCharactersResponseModelUsage from json.
func (s *UsageCharactersResponseModelUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsageCharactersResponseModelUsage to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem []float64
		if err := func() error {
			elem = make([]float64, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem float64
				v, err := d.Float64()
				elemElem = float64(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsageCharactersResponseModelUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UsageCharactersResponseModelUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsageCharactersResponseModelUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserFeedback) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserFeedback) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("score")
		s.Score.Encode(e)
	}
	{
		e.FieldStart("time_in_call_secs")
		e.Int(s.TimeInCallSecs)
	}
}

var jsonFieldsNameOfUserFeedback = [2]string{
	0: "score",
	1: "time_in_call_secs",
}

// Decode decodes UserFeedback from json.
func (s *UserFeedback) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserFeedback to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "score":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "time_in_call_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.TimeInCallSecs = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time_in_call_secs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserFeedback")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserFeedback) {
					name = jsonFieldsNameOfUserFeedback[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserFeedback) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserFeedback) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserFeedbackScore as json.
func (s UserFeedbackScore) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserFeedbackScore from json.
func (s *UserFeedbackScore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserFeedbackScore to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserFeedbackScore(v) {
	case UserFeedbackScoreLike:
		*s = UserFeedbackScoreLike
	case UserFeedbackScoreDislike:
		*s = UserFeedbackScoreDislike
	default:
		*s = UserFeedbackScore(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserFeedbackScore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserFeedbackScore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("can_use_delayed_payment_methods")
		e.Bool(s.CanUseDelayedPaymentMethods)
	}
	{
		e.FieldStart("created_at")
		e.Int(s.CreatedAt)
	}
	{
		if s.FirstName.Set {
			e.FieldStart("first_name")
			s.FirstName.Encode(e)
		}
	}
	{
		if s.IsAPIKeyHashed.Set {
			e.FieldStart("is_api_key_hashed")
			s.IsAPIKeyHashed.Encode(e)
		}
	}
	{
		e.FieldStart("is_new_user")
		e.Bool(s.IsNewUser)
	}
	{
		e.FieldStart("is_onboarding_checklist_completed")
		e.Bool(s.IsOnboardingChecklistCompleted)
	}
	{
		e.FieldStart("is_onboarding_completed")
		e.Bool(s.IsOnboardingCompleted)
	}
	{
		if s.PartnerstackPartnerDefaultLink.Set {
			e.FieldStart("partnerstack_partner_default_link")
			s.PartnerstackPartnerDefaultLink.Encode(e)
		}
	}
	{
		if s.ReferralLinkCode.Set {
			e.FieldStart("referral_link_code")
			s.ReferralLinkCode.Encode(e)
		}
	}
	{
		e.FieldStart("subscription")
		s.Subscription.Encode(e)
	}
	{
		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
	{
		if s.XiAPIKey.Set {
			e.FieldStart("xi_api_key")
			s.XiAPIKey.Encode(e)
		}
	}
	{
		if s.XiAPIKeyPreview.Set {
			e.FieldStart("xi_api_key_preview")
			s.XiAPIKeyPreview.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserResponseModel = [13]string{
	0:  "can_use_delayed_payment_methods",
	1:  "created_at",
	2:  "first_name",
	3:  "is_api_key_hashed",
	4:  "is_new_user",
	5:  "is_onboarding_checklist_completed",
	6:  "is_onboarding_completed",
	7:  "partnerstack_partner_default_link",
	8:  "referral_link_code",
	9:  "subscription",
	10: "user_id",
	11: "xi_api_key",
	12: "xi_api_key_preview",
}

// Decode decodes UserResponseModel from json.
func (s *UserResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "can_use_delayed_payment_methods":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.CanUseDelayedPaymentMethods = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"can_use_delayed_payment_methods\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAt = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "first_name":
			if err := func() error {
				s.FirstName.Reset()
				if err := s.FirstName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "is_api_key_hashed":
			if err := func() error {
				s.IsAPIKeyHashed.Reset()
				if err := s.IsAPIKeyHashed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_api_key_hashed\"")
			}
		case "is_new_user":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsNewUser = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_new_user\"")
			}
		case "is_onboarding_checklist_completed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboardingChecklistCompleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_onboarding_checklist_completed\"")
			}
		case "is_onboarding_completed":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsOnboardingCompleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_onboarding_completed\"")
			}
		case "partnerstack_partner_default_link":
			if err := func() error {
				s.PartnerstackPartnerDefaultLink.Reset()
				if err := s.PartnerstackPartnerDefaultLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"partnerstack_partner_default_link\"")
			}
		case "referral_link_code":
			if err := func() error {
				s.ReferralLinkCode.Reset()
				if err := s.ReferralLinkCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referral_link_code\"")
			}
		case "subscription":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Subscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription\"")
			}
		case "user_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "xi_api_key":
			if err := func() error {
				s.XiAPIKey.Reset()
				if err := s.XiAPIKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xi_api_key\"")
			}
		case "xi_api_key_preview":
			if err := func() error {
				s.XiAPIKeyPreview.Reset()
				if err := s.XiAPIKeyPreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xi_api_key_preview\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110011,
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserResponseModel) {
					name = jsonFieldsNameOfUserResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UtteranceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UtteranceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("end")
		e.Float64(s.End)
	}
	{
		e.FieldStart("start")
		e.Float64(s.Start)
	}
}

var jsonFieldsNameOfUtteranceResponseModel = [2]string{
	0: "end",
	1: "start",
}

// Decode decodes UtteranceResponseModel from json.
func (s *UtteranceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UtteranceResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "end":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.End = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Start = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UtteranceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUtteranceResponseModel) {
					name = jsonFieldsNameOfUtteranceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UtteranceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UtteranceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValidationError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValidationError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loc")
		e.ArrStart()
		for _, elem := range s.Loc {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("msg")
		e.Str(s.Msg)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfValidationError = [3]string{
	0: "loc",
	1: "msg",
	2: "type",
}

// Decode decodes ValidationError from json.
func (s *ValidationError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loc":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Loc = make([]ValidationErrorLocItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValidationErrorLocItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Loc = append(s.Loc, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loc\"")
			}
		case "msg":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Msg = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValidationError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfValidationError) {
					name = jsonFieldsNameOfValidationError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValidationError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ValidationErrorLocItem as json.
func (s ValidationErrorLocItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringValidationErrorLocItem:
		e.Str(s.String)
	case IntValidationErrorLocItem:
		e.Int(s.Int)
	}
}

// Decode decodes ValidationErrorLocItem from json.
func (s *ValidationErrorLocItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValidationErrorLocItem to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Int()
		s.Int = int(v)
		if err != nil {
			return err
		}
		s.Type = IntValidationErrorLocItem
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringValidationErrorLocItem
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ValidationErrorLocItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValidationErrorLocItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerificationAttemptResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerificationAttemptResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accepted")
		e.Bool(s.Accepted)
	}
	{
		e.FieldStart("date_unix")
		e.Int(s.DateUnix)
	}
	{
		e.FieldStart("levenshtein_distance")
		e.Float64(s.LevenshteinDistance)
	}
	{
		if s.Recording.Set {
			e.FieldStart("recording")
			s.Recording.Encode(e)
		}
	}
	{
		e.FieldStart("similarity")
		e.Float64(s.Similarity)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfVerificationAttemptResponseModel = [6]string{
	0: "accepted",
	1: "date_unix",
	2: "levenshtein_distance",
	3: "recording",
	4: "similarity",
	5: "text",
}

// Decode decodes VerificationAttemptResponseModel from json.
func (s *VerificationAttemptResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerificationAttemptResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accepted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Accepted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accepted\"")
			}
		case "date_unix":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.DateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_unix\"")
			}
		case "levenshtein_distance":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.LevenshteinDistance = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"levenshtein_distance\"")
			}
		case "recording":
			if err := func() error {
				s.Recording.Reset()
				if err := s.Recording.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recording\"")
			}
		case "similarity":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Similarity = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"similarity\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerificationAttemptResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerificationAttemptResponseModel) {
					name = jsonFieldsNameOfVerificationAttemptResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerificationAttemptResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerificationAttemptResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifiedVoiceLanguageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifiedVoiceLanguageResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.Accent.Set {
			e.FieldStart("accent")
			s.Accent.Encode(e)
		}
	}
	{
		e.FieldStart("language")
		e.Str(s.Language)
	}
	{
		if s.Locale.Set {
			e.FieldStart("locale")
			s.Locale.Encode(e)
		}
	}
	{
		e.FieldStart("model_id")
		e.Str(s.ModelID)
	}
	{
		if s.PreviewURL.Set {
			e.FieldStart("preview_url")
			s.PreviewURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerifiedVoiceLanguageResponseModel = [5]string{
	0: "accent",
	1: "language",
	2: "locale",
	3: "model_id",
	4: "preview_url",
}

// Decode decodes VerifiedVoiceLanguageResponseModel from json.
func (s *VerifiedVoiceLanguageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifiedVoiceLanguageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accent":
			if err := func() error {
				s.Accent.Reset()
				if err := s.Accent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accent\"")
			}
		case "language":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Language = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "locale":
			if err := func() error {
				s.Locale.Reset()
				if err := s.Locale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"locale\"")
			}
		case "model_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ModelID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "preview_url":
			if err := func() error {
				s.PreviewURL.Reset()
				if err := s.PreviewURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preview_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifiedVoiceLanguageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifiedVoiceLanguageResponseModel) {
					name = jsonFieldsNameOfVerifiedVoiceLanguageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifiedVoiceLanguageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifiedVoiceLanguageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyPVCVoiceCaptchaResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyPVCVoiceCaptchaResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
}

var jsonFieldsNameOfVerifyPVCVoiceCaptchaResponseModel = [1]string{
	0: "status",
}

// Decode decodes VerifyPVCVoiceCaptchaResponseModel from json.
func (s *VerifyPVCVoiceCaptchaResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyPVCVoiceCaptchaResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyPVCVoiceCaptchaResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyPVCVoiceCaptchaResponseModel) {
					name = jsonFieldsNameOfVerifyPVCVoiceCaptchaResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyPVCVoiceCaptchaResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyPVCVoiceCaptchaResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceDesignRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceDesignRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.AutoGenerateText.Set {
			e.FieldStart("auto_generate_text")
			s.AutoGenerateText.Encode(e)
		}
	}
	{
		if s.GuidanceScale.Set {
			e.FieldStart("guidance_scale")
			s.GuidanceScale.Encode(e)
		}
	}
	{
		if s.Loudness.Set {
			e.FieldStart("loudness")
			s.Loudness.Encode(e)
		}
	}
	{
		if s.ModelID.Set {
			e.FieldStart("model_id")
			s.ModelID.Encode(e)
		}
	}
	{
		if s.PromptStrength.Set {
			e.FieldStart("prompt_strength")
			s.PromptStrength.Encode(e)
		}
	}
	{
		if s.Quality.Set {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.ReferenceAudioBase64.Set {
			e.FieldStart("reference_audio_base64")
			s.ReferenceAudioBase64.Encode(e)
		}
	}
	{
		if s.RemixingSessionID.Set {
			e.FieldStart("remixing_session_id")
			s.RemixingSessionID.Encode(e)
		}
	}
	{
		if s.RemixingSessionIterationID.Set {
			e.FieldStart("remixing_session_iteration_id")
			s.RemixingSessionIterationID.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.ShouldEnhance.Set {
			e.FieldStart("should_enhance")
			s.ShouldEnhance.Encode(e)
		}
	}
	{
		if s.StreamPreviews.Set {
			e.FieldStart("stream_previews")
			s.StreamPreviews.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		e.FieldStart("voice_description")
		e.Str(s.VoiceDescription)
	}
}

var jsonFieldsNameOfVoiceDesignRequestModel = [14]string{
	0:  "auto_generate_text",
	1:  "guidance_scale",
	2:  "loudness",
	3:  "model_id",
	4:  "prompt_strength",
	5:  "quality",
	6:  "reference_audio_base64",
	7:  "remixing_session_id",
	8:  "remixing_session_iteration_id",
	9:  "seed",
	10: "should_enhance",
	11: "stream_previews",
	12: "text",
	13: "voice_description",
}

// Decode decodes VoiceDesignRequestModel from json.
func (s *VoiceDesignRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceDesignRequestModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_generate_text":
			if err := func() error {
				s.AutoGenerateText.Reset()
				if err := s.AutoGenerateText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_generate_text\"")
			}
		case "guidance_scale":
			if err := func() error {
				s.GuidanceScale.Reset()
				if err := s.GuidanceScale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guidance_scale\"")
			}
		case "loudness":
			if err := func() error {
				s.Loudness.Reset()
				if err := s.Loudness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loudness\"")
			}
		case "model_id":
			if err := func() error {
				s.ModelID.Reset()
				if err := s.ModelID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"model_id\"")
			}
		case "prompt_strength":
			if err := func() error {
				s.PromptStrength.Reset()
				if err := s.PromptStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_strength\"")
			}
		case "quality":
			if err := func() error {
				s.Quality.Reset()
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "reference_audio_base64":
			if err := func() error {
				s.ReferenceAudioBase64.Reset()
				if err := s.ReferenceAudioBase64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference_audio_base64\"")
			}
		case "remixing_session_id":
			if err := func() error {
				s.RemixingSessionID.Reset()
				if err := s.RemixingSessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remixing_session_id\"")
			}
		case "remixing_session_iteration_id":
			if err := func() error {
				s.RemixingSessionIterationID.Reset()
				if err := s.RemixingSessionIterationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remixing_session_iteration_id\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "should_enhance":
			if err := func() error {
				s.ShouldEnhance.Reset()
				if err := s.ShouldEnhance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"should_enhance\"")
			}
		case "stream_previews":
			if err := func() error {
				s.StreamPreviews.Reset()
				if err := s.StreamPreviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_previews\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voice_description":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.VoiceDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceDesignRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceDesignRequestModel) {
					name = jsonFieldsNameOfVoiceDesignRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceDesignRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceDesignRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceDesignRequestModelModelID as json.
func (s VoiceDesignRequestModelModelID) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceDesignRequestModelModelID from json.
func (s *VoiceDesignRequestModelModelID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceDesignRequestModelModelID to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceDesignRequestModelModelID(v) {
	case VoiceDesignRequestModelModelIDElevenMultilingualTtvV2:
		*s = VoiceDesignRequestModelModelIDElevenMultilingualTtvV2
	case VoiceDesignRequestModelModelIDElevenTtvV3:
		*s = VoiceDesignRequestModelModelIDElevenTtvV3
	default:
		*s = VoiceDesignRequestModelModelID(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceDesignRequestModelModelID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceDesignRequestModelModelID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceGenerationParameterOptionResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceGenerationParameterOptionResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfVoiceGenerationParameterOptionResponseModel = [2]string{
	0: "code",
	1: "name",
}

// Decode decodes VoiceGenerationParameterOptionResponseModel from json.
func (s *VoiceGenerationParameterOptionResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceGenerationParameterOptionResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceGenerationParameterOptionResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceGenerationParameterOptionResponseModel) {
					name = jsonFieldsNameOfVoiceGenerationParameterOptionResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceGenerationParameterOptionResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceGenerationParameterOptionResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceGenerationParameterResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceGenerationParameterResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accents")
		e.ArrStart()
		for _, elem := range s.Accents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ages")
		e.ArrStart()
		for _, elem := range s.Ages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("genders")
		e.ArrStart()
		for _, elem := range s.Genders {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("maximum_accent_strength")
		e.Float64(s.MaximumAccentStrength)
	}
	{
		e.FieldStart("maximum_characters")
		e.Int(s.MaximumCharacters)
	}
	{
		e.FieldStart("minimum_accent_strength")
		e.Float64(s.MinimumAccentStrength)
	}
	{
		e.FieldStart("minimum_characters")
		e.Int(s.MinimumCharacters)
	}
}

var jsonFieldsNameOfVoiceGenerationParameterResponseModel = [7]string{
	0: "accents",
	1: "ages",
	2: "genders",
	3: "maximum_accent_strength",
	4: "maximum_characters",
	5: "minimum_accent_strength",
	6: "minimum_characters",
}

// Decode decodes VoiceGenerationParameterResponseModel from json.
func (s *VoiceGenerationParameterResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceGenerationParameterResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accents":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Accents = make([]VoiceGenerationParameterOptionResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceGenerationParameterOptionResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Accents = append(s.Accents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accents\"")
			}
		case "ages":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Ages = make([]VoiceGenerationParameterOptionResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceGenerationParameterOptionResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ages = append(s.Ages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ages\"")
			}
		case "genders":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Genders = make([]VoiceGenerationParameterOptionResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoiceGenerationParameterOptionResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Genders = append(s.Genders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"genders\"")
			}
		case "maximum_accent_strength":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.MaximumAccentStrength = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_accent_strength\"")
			}
		case "maximum_characters":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.MaximumCharacters = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum_characters\"")
			}
		case "minimum_accent_strength":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.MinimumAccentStrength = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_accent_strength\"")
			}
		case "minimum_characters":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.MinimumCharacters = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_characters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceGenerationParameterResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceGenerationParameterResponseModel) {
					name = jsonFieldsNameOfVoiceGenerationParameterResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceGenerationParameterResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceGenerationParameterResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceMailDetectionResultSuccessModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceMailDetectionResultSuccessModel) encodeFields(e *jx.Encoder) {
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.ResultType.Set {
			e.FieldStart("result_type")
			s.ResultType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.VoicemailMessage.Set {
			e.FieldStart("voicemail_message")
			s.VoicemailMessage.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoiceMailDetectionResultSuccessModel = [4]string{
	0: "reason",
	1: "result_type",
	2: "status",
	3: "voicemail_message",
}

// Decode decodes VoiceMailDetectionResultSuccessModel from json.
func (s *VoiceMailDetectionResultSuccessModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceMailDetectionResultSuccessModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "result_type":
			if err := func() error {
				s.ResultType.Reset()
				if err := s.ResultType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_type\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "voicemail_message":
			if err := func() error {
				s.VoicemailMessage.Reset()
				if err := s.VoicemailMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voicemail_message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceMailDetectionResultSuccessModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceMailDetectionResultSuccessModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceMailDetectionResultSuccessModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceMailDetectionResultSuccessModelResultType as json.
func (s VoiceMailDetectionResultSuccessModelResultType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceMailDetectionResultSuccessModelResultType from json.
func (s *VoiceMailDetectionResultSuccessModelResultType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceMailDetectionResultSuccessModelResultType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceMailDetectionResultSuccessModelResultType(v) {
	case VoiceMailDetectionResultSuccessModelResultTypeVoicemailDetectionSuccess:
		*s = VoiceMailDetectionResultSuccessModelResultTypeVoicemailDetectionSuccess
	default:
		*s = VoiceMailDetectionResultSuccessModelResultType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceMailDetectionResultSuccessModelResultType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceMailDetectionResultSuccessModelResultType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceMailDetectionResultSuccessModelStatus as json.
func (s VoiceMailDetectionResultSuccessModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceMailDetectionResultSuccessModelStatus from json.
func (s *VoiceMailDetectionResultSuccessModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceMailDetectionResultSuccessModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceMailDetectionResultSuccessModelStatus(v) {
	case VoiceMailDetectionResultSuccessModelStatusSuccess:
		*s = VoiceMailDetectionResultSuccessModelStatusSuccess
	default:
		*s = VoiceMailDetectionResultSuccessModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceMailDetectionResultSuccessModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceMailDetectionResultSuccessModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoicePreviewResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoicePreviewResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audio_base_64")
		e.Str(s.AudioBase64)
	}
	{
		e.FieldStart("duration_secs")
		e.Float64(s.DurationSecs)
	}
	{
		e.FieldStart("generated_voice_id")
		e.Str(s.GeneratedVoiceID)
	}
	{
		e.FieldStart("language")
		s.Language.Encode(e)
	}
	{
		e.FieldStart("media_type")
		e.Str(s.MediaType)
	}
}

var jsonFieldsNameOfVoicePreviewResponseModel = [5]string{
	0: "audio_base_64",
	1: "duration_secs",
	2: "generated_voice_id",
	3: "language",
	4: "media_type",
}

// Decode decodes VoicePreviewResponseModel from json.
func (s *VoicePreviewResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoicePreviewResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_base_64":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base_64\"")
			}
		case "duration_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DurationSecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "generated_voice_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.GeneratedVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"generated_voice_id\"")
			}
		case "language":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "media_type":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.MediaType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoicePreviewResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoicePreviewResponseModel) {
					name = jsonFieldsNameOfVoicePreviewResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoicePreviewResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoicePreviewResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoicePreviewsRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoicePreviewsRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.AutoGenerateText.Set {
			e.FieldStart("auto_generate_text")
			s.AutoGenerateText.Encode(e)
		}
	}
	{
		if s.GuidanceScale.Set {
			e.FieldStart("guidance_scale")
			s.GuidanceScale.Encode(e)
		}
	}
	{
		if s.Loudness.Set {
			e.FieldStart("loudness")
			s.Loudness.Encode(e)
		}
	}
	{
		if s.Quality.Set {
			e.FieldStart("quality")
			s.Quality.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.ShouldEnhance.Set {
			e.FieldStart("should_enhance")
			s.ShouldEnhance.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		e.FieldStart("voice_description")
		e.Str(s.VoiceDescription)
	}
}

var jsonFieldsNameOfVoicePreviewsRequestModel = [8]string{
	0: "auto_generate_text",
	1: "guidance_scale",
	2: "loudness",
	3: "quality",
	4: "seed",
	5: "should_enhance",
	6: "text",
	7: "voice_description",
}

// Decode decodes VoicePreviewsRequestModel from json.
func (s *VoicePreviewsRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoicePreviewsRequestModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_generate_text":
			if err := func() error {
				s.AutoGenerateText.Reset()
				if err := s.AutoGenerateText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_generate_text\"")
			}
		case "guidance_scale":
			if err := func() error {
				s.GuidanceScale.Reset()
				if err := s.GuidanceScale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guidance_scale\"")
			}
		case "loudness":
			if err := func() error {
				s.Loudness.Reset()
				if err := s.Loudness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loudness\"")
			}
		case "quality":
			if err := func() error {
				s.Quality.Reset()
				if err := s.Quality.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quality\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "should_enhance":
			if err := func() error {
				s.ShouldEnhance.Reset()
				if err := s.ShouldEnhance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"should_enhance\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voice_description":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.VoiceDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoicePreviewsRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoicePreviewsRequestModel) {
					name = jsonFieldsNameOfVoicePreviewsRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoicePreviewsRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoicePreviewsRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoicePreviewsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoicePreviewsResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("previews")
		e.ArrStart()
		for _, elem := range s.Previews {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
}

var jsonFieldsNameOfVoicePreviewsResponseModel = [2]string{
	0: "previews",
	1: "text",
}

// Decode decodes VoicePreviewsResponseModel from json.
func (s *VoicePreviewsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoicePreviewsResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "previews":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Previews = make([]VoicePreviewResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VoicePreviewResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Previews = append(s.Previews, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previews\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoicePreviewsResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoicePreviewsResponseModel) {
					name = jsonFieldsNameOfVoicePreviewsResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoicePreviewsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoicePreviewsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceRemixRequestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceRemixRequestModel) encodeFields(e *jx.Encoder) {
	{
		if s.AutoGenerateText.Set {
			e.FieldStart("auto_generate_text")
			s.AutoGenerateText.Encode(e)
		}
	}
	{
		if s.GuidanceScale.Set {
			e.FieldStart("guidance_scale")
			s.GuidanceScale.Encode(e)
		}
	}
	{
		if s.Loudness.Set {
			e.FieldStart("loudness")
			s.Loudness.Encode(e)
		}
	}
	{
		if s.PromptStrength.Set {
			e.FieldStart("prompt_strength")
			s.PromptStrength.Encode(e)
		}
	}
	{
		if s.RemixingSessionID.Set {
			e.FieldStart("remixing_session_id")
			s.RemixingSessionID.Encode(e)
		}
	}
	{
		if s.RemixingSessionIterationID.Set {
			e.FieldStart("remixing_session_iteration_id")
			s.RemixingSessionIterationID.Encode(e)
		}
	}
	{
		if s.Seed.Set {
			e.FieldStart("seed")
			s.Seed.Encode(e)
		}
	}
	{
		if s.StreamPreviews.Set {
			e.FieldStart("stream_previews")
			s.StreamPreviews.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		e.FieldStart("voice_description")
		e.Str(s.VoiceDescription)
	}
}

var jsonFieldsNameOfVoiceRemixRequestModel = [10]string{
	0: "auto_generate_text",
	1: "guidance_scale",
	2: "loudness",
	3: "prompt_strength",
	4: "remixing_session_id",
	5: "remixing_session_iteration_id",
	6: "seed",
	7: "stream_previews",
	8: "text",
	9: "voice_description",
}

// Decode decodes VoiceRemixRequestModel from json.
func (s *VoiceRemixRequestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceRemixRequestModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auto_generate_text":
			if err := func() error {
				s.AutoGenerateText.Reset()
				if err := s.AutoGenerateText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_generate_text\"")
			}
		case "guidance_scale":
			if err := func() error {
				s.GuidanceScale.Reset()
				if err := s.GuidanceScale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"guidance_scale\"")
			}
		case "loudness":
			if err := func() error {
				s.Loudness.Reset()
				if err := s.Loudness.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loudness\"")
			}
		case "prompt_strength":
			if err := func() error {
				s.PromptStrength.Reset()
				if err := s.PromptStrength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt_strength\"")
			}
		case "remixing_session_id":
			if err := func() error {
				s.RemixingSessionID.Reset()
				if err := s.RemixingSessionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remixing_session_id\"")
			}
		case "remixing_session_iteration_id":
			if err := func() error {
				s.RemixingSessionIterationID.Reset()
				if err := s.RemixingSessionIterationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remixing_session_iteration_id\"")
			}
		case "seed":
			if err := func() error {
				s.Seed.Reset()
				if err := s.Seed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seed\"")
			}
		case "stream_previews":
			if err := func() error {
				s.StreamPreviews.Reset()
				if err := s.StreamPreviews.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream_previews\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "voice_description":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VoiceDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceRemixRequestModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceRemixRequestModel) {
					name = jsonFieldsNameOfVoiceRemixRequestModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceRemixRequestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceRemixRequestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("available_for_tiers")
		e.ArrStart()
		for _, elem := range s.AvailableForTiers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		if s.CreatedAtUnix.Set {
			e.FieldStart("created_at_unix")
			s.CreatedAtUnix.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.FavoritedAtUnix.Set {
			e.FieldStart("favorited_at_unix")
			s.FavoritedAtUnix.Encode(e)
		}
	}
	{
		if s.FineTuning.Set {
			e.FieldStart("fine_tuning")
			s.FineTuning.Encode(e)
		}
	}
	{
		e.FieldStart("high_quality_base_model_ids")
		e.ArrStart()
		for _, elem := range s.HighQualityBaseModelIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.IsLegacy.Set {
			e.FieldStart("is_legacy")
			s.IsLegacy.Encode(e)
		}
	}
	{
		if s.IsMixed.Set {
			e.FieldStart("is_mixed")
			s.IsMixed.Encode(e)
		}
	}
	{
		if s.IsOwner.Set {
			e.FieldStart("is_owner")
			s.IsOwner.Encode(e)
		}
	}
	{
		e.FieldStart("labels")
		s.Labels.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.PermissionOnResource.Set {
			e.FieldStart("permission_on_resource")
			s.PermissionOnResource.Encode(e)
		}
	}
	{
		if s.PreviewURL.Set {
			e.FieldStart("preview_url")
			s.PreviewURL.Encode(e)
		}
	}
	{
		if s.SafetyControl.Set {
			e.FieldStart("safety_control")
			s.SafetyControl.Encode(e)
		}
	}
	{
		if s.Samples.Set {
			e.FieldStart("samples")
			s.Samples.Encode(e)
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.Sharing.Set {
			e.FieldStart("sharing")
			s.Sharing.Encode(e)
		}
	}
	{
		if s.VerifiedLanguages.Set {
			e.FieldStart("verified_languages")
			s.VerifiedLanguages.Encode(e)
		}
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
	{
		if s.VoiceVerification.Set {
			e.FieldStart("voice_verification")
			s.VoiceVerification.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoiceResponseModel = [21]string{
	0:  "available_for_tiers",
	1:  "category",
	2:  "created_at_unix",
	3:  "description",
	4:  "favorited_at_unix",
	5:  "fine_tuning",
	6:  "high_quality_base_model_ids",
	7:  "is_legacy",
	8:  "is_mixed",
	9:  "is_owner",
	10: "labels",
	11: "name",
	12: "permission_on_resource",
	13: "preview_url",
	14: "safety_control",
	15: "samples",
	16: "settings",
	17: "sharing",
	18: "verified_languages",
	19: "voice_id",
	20: "voice_verification",
}

// Decode decodes VoiceResponseModel from json.
func (s *VoiceResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceResponseModel to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "available_for_tiers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AvailableForTiers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AvailableForTiers = append(s.AvailableForTiers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available_for_tiers\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "created_at_unix":
			if err := func() error {
				s.CreatedAtUnix.Reset()
				if err := s.CreatedAtUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "favorited_at_unix":
			if err := func() error {
				s.FavoritedAtUnix.Reset()
				if err := s.FavoritedAtUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favorited_at_unix\"")
			}
		case "fine_tuning":
			if err := func() error {
				s.FineTuning.Reset()
				if err := s.FineTuning.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fine_tuning\"")
			}
		case "high_quality_base_model_ids":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.HighQualityBaseModelIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.HighQualityBaseModelIds = append(s.HighQualityBaseModelIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"high_quality_base_model_ids\"")
			}
		case "is_legacy":
			if err := func() error {
				s.IsLegacy.Reset()
				if err := s.IsLegacy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_legacy\"")
			}
		case "is_mixed":
			if err := func() error {
				s.IsMixed.Reset()
				if err := s.IsMixed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_mixed\"")
			}
		case "is_owner":
			if err := func() error {
				s.IsOwner.Reset()
				if err := s.IsOwner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_owner\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permission_on_resource":
			if err := func() error {
				s.PermissionOnResource.Reset()
				if err := s.PermissionOnResource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission_on_resource\"")
			}
		case "preview_url":
			if err := func() error {
				s.PreviewURL.Reset()
				if err := s.PreviewURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preview_url\"")
			}
		case "safety_control":
			if err := func() error {
				s.SafetyControl.Reset()
				if err := s.SafetyControl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"safety_control\"")
			}
		case "samples":
			if err := func() error {
				s.Samples.Reset()
				if err := s.Samples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"samples\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		case "sharing":
			if err := func() error {
				s.Sharing.Reset()
				if err := s.Sharing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sharing\"")
			}
		case "verified_languages":
			if err := func() error {
				s.VerifiedLanguages.Reset()
				if err := s.VerifiedLanguages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verified_languages\"")
			}
		case "voice_id":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		case "voice_verification":
			if err := func() error {
				s.VoiceVerification.Reset()
				if err := s.VoiceVerification.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_verification\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000011,
		0b00001100,
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceResponseModel) {
					name = jsonFieldsNameOfVoiceResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceResponseModelCategory as json.
func (s VoiceResponseModelCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceResponseModelCategory from json.
func (s *VoiceResponseModelCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceResponseModelCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceResponseModelCategory(v) {
	case VoiceResponseModelCategoryGenerated:
		*s = VoiceResponseModelCategoryGenerated
	case VoiceResponseModelCategoryCloned:
		*s = VoiceResponseModelCategoryCloned
	case VoiceResponseModelCategoryPremade:
		*s = VoiceResponseModelCategoryPremade
	case VoiceResponseModelCategoryProfessional:
		*s = VoiceResponseModelCategoryProfessional
	case VoiceResponseModelCategoryFamous:
		*s = VoiceResponseModelCategoryFamous
	case VoiceResponseModelCategoryHighQuality:
		*s = VoiceResponseModelCategoryHighQuality
	default:
		*s = VoiceResponseModelCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceResponseModelCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceResponseModelCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s VoiceResponseModelLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s VoiceResponseModelLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes VoiceResponseModelLabels from json.
func (s *VoiceResponseModelLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceResponseModelLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceResponseModelLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceResponseModelLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceResponseModelLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceResponseModelSafetyControl as json.
func (s VoiceResponseModelSafetyControl) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceResponseModelSafetyControl from json.
func (s *VoiceResponseModelSafetyControl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceResponseModelSafetyControl to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceResponseModelSafetyControl(v) {
	case VoiceResponseModelSafetyControlNONE:
		*s = VoiceResponseModelSafetyControlNONE
	case VoiceResponseModelSafetyControlBAN:
		*s = VoiceResponseModelSafetyControlBAN
	case VoiceResponseModelSafetyControlCAPTCHA:
		*s = VoiceResponseModelSafetyControlCAPTCHA
	case VoiceResponseModelSafetyControlENTERPRISEBAN:
		*s = VoiceResponseModelSafetyControlENTERPRISEBAN
	case VoiceResponseModelSafetyControlENTERPRISECAPTCHA:
		*s = VoiceResponseModelSafetyControlENTERPRISECAPTCHA
	default:
		*s = VoiceResponseModelSafetyControl(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceResponseModelSafetyControl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceResponseModelSafetyControl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceSamplePreviewResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceSamplePreviewResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("audio_base_64")
		e.Str(s.AudioBase64)
	}
	{
		if s.DurationSecs.Set {
			e.FieldStart("duration_secs")
			s.DurationSecs.Encode(e)
		}
	}
	{
		e.FieldStart("media_type")
		e.Str(s.MediaType)
	}
	{
		e.FieldStart("sample_id")
		e.Str(s.SampleID)
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfVoiceSamplePreviewResponseModel = [5]string{
	0: "audio_base_64",
	1: "duration_secs",
	2: "media_type",
	3: "sample_id",
	4: "voice_id",
}

// Decode decodes VoiceSamplePreviewResponseModel from json.
func (s *VoiceSamplePreviewResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSamplePreviewResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "audio_base_64":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AudioBase64 = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"audio_base_64\"")
			}
		case "duration_secs":
			if err := func() error {
				s.DurationSecs.Reset()
				if err := s.DurationSecs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration_secs\"")
			}
		case "media_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MediaType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"media_type\"")
			}
		case "sample_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SampleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_id\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSamplePreviewResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceSamplePreviewResponseModel) {
					name = jsonFieldsNameOfVoiceSamplePreviewResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceSamplePreviewResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSamplePreviewResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceSampleVisualWaveformResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceSampleVisualWaveformResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sample_id")
		e.Str(s.SampleID)
	}
	{
		e.FieldStart("visual_waveform")
		e.ArrStart()
		for _, elem := range s.VisualWaveform {
			e.Float64(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVoiceSampleVisualWaveformResponseModel = [2]string{
	0: "sample_id",
	1: "visual_waveform",
}

// Decode decodes VoiceSampleVisualWaveformResponseModel from json.
func (s *VoiceSampleVisualWaveformResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSampleVisualWaveformResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sample_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SampleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_id\"")
			}
		case "visual_waveform":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.VisualWaveform = make([]float64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float64
					v, err := d.Float64()
					elem = float64(v)
					if err != nil {
						return err
					}
					s.VisualWaveform = append(s.VisualWaveform, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visual_waveform\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSampleVisualWaveformResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceSampleVisualWaveformResponseModel) {
					name = jsonFieldsNameOfVoiceSampleVisualWaveformResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceSampleVisualWaveformResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSampleVisualWaveformResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceSegment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceSegment) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("character_end_index")
		e.Int(s.CharacterEndIndex)
	}
	{
		e.FieldStart("character_start_index")
		e.Int(s.CharacterStartIndex)
	}
	{
		e.FieldStart("dialogue_input_index")
		e.Int(s.DialogueInputIndex)
	}
	{
		e.FieldStart("end_time_seconds")
		e.Float64(s.EndTimeSeconds)
	}
	{
		e.FieldStart("start_time_seconds")
		e.Float64(s.StartTimeSeconds)
	}
	{
		e.FieldStart("voice_id")
		e.Str(s.VoiceID)
	}
}

var jsonFieldsNameOfVoiceSegment = [6]string{
	0: "character_end_index",
	1: "character_start_index",
	2: "dialogue_input_index",
	3: "end_time_seconds",
	4: "start_time_seconds",
	5: "voice_id",
}

// Decode decodes VoiceSegment from json.
func (s *VoiceSegment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSegment to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_end_index":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.CharacterEndIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_end_index\"")
			}
		case "character_start_index":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CharacterStartIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_start_index\"")
			}
		case "dialogue_input_index":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.DialogueInputIndex = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dialogue_input_index\"")
			}
		case "end_time_seconds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.EndTimeSeconds = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_time_seconds\"")
			}
		case "start_time_seconds":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.StartTimeSeconds = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_time_seconds\"")
			}
		case "voice_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.VoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSegment")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceSegment) {
					name = jsonFieldsNameOfVoiceSegment[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceSegment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSegment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceSettingsResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceSettingsResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.SimilarityBoost.Set {
			e.FieldStart("similarity_boost")
			s.SimilarityBoost.Encode(e)
		}
	}
	{
		if s.Speed.Set {
			e.FieldStart("speed")
			s.Speed.Encode(e)
		}
	}
	{
		if s.Stability.Set {
			e.FieldStart("stability")
			s.Stability.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.UseSpeakerBoost.Set {
			e.FieldStart("use_speaker_boost")
			s.UseSpeakerBoost.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoiceSettingsResponseModel = [5]string{
	0: "similarity_boost",
	1: "speed",
	2: "stability",
	3: "style",
	4: "use_speaker_boost",
}

// Decode decodes VoiceSettingsResponseModel from json.
func (s *VoiceSettingsResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSettingsResponseModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "similarity_boost":
			if err := func() error {
				s.SimilarityBoost.Reset()
				if err := s.SimilarityBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"similarity_boost\"")
			}
		case "speed":
			if err := func() error {
				s.Speed.Reset()
				if err := s.Speed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"speed\"")
			}
		case "stability":
			if err := func() error {
				s.Stability.Reset()
				if err := s.Stability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stability\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "use_speaker_boost":
			if err := func() error {
				s.UseSpeakerBoost.Reset()
				if err := s.UseSpeakerBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use_speaker_boost\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSettingsResponseModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceSettingsResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSettingsResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceSharingModerationCheckResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceSharingModerationCheckResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.CaptchaChecks.Set {
			e.FieldStart("captcha_checks")
			s.CaptchaChecks.Encode(e)
		}
	}
	{
		if s.CaptchaIds.Set {
			e.FieldStart("captcha_ids")
			s.CaptchaIds.Encode(e)
		}
	}
	{
		if s.DateCheckedUnix.Set {
			e.FieldStart("date_checked_unix")
			s.DateCheckedUnix.Encode(e)
		}
	}
	{
		if s.DescriptionCheck.Set {
			e.FieldStart("description_check")
			s.DescriptionCheck.Encode(e)
		}
	}
	{
		if s.DescriptionValue.Set {
			e.FieldStart("description_value")
			s.DescriptionValue.Encode(e)
		}
	}
	{
		if s.NameCheck.Set {
			e.FieldStart("name_check")
			s.NameCheck.Encode(e)
		}
	}
	{
		if s.NameValue.Set {
			e.FieldStart("name_value")
			s.NameValue.Encode(e)
		}
	}
	{
		if s.SampleChecks.Set {
			e.FieldStart("sample_checks")
			s.SampleChecks.Encode(e)
		}
	}
	{
		if s.SampleIds.Set {
			e.FieldStart("sample_ids")
			s.SampleIds.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoiceSharingModerationCheckResponseModel = [9]string{
	0: "captcha_checks",
	1: "captcha_ids",
	2: "date_checked_unix",
	3: "description_check",
	4: "description_value",
	5: "name_check",
	6: "name_value",
	7: "sample_checks",
	8: "sample_ids",
}

// Decode decodes VoiceSharingModerationCheckResponseModel from json.
func (s *VoiceSharingModerationCheckResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSharingModerationCheckResponseModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "captcha_checks":
			if err := func() error {
				s.CaptchaChecks.Reset()
				if err := s.CaptchaChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"captcha_checks\"")
			}
		case "captcha_ids":
			if err := func() error {
				s.CaptchaIds.Reset()
				if err := s.CaptchaIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"captcha_ids\"")
			}
		case "date_checked_unix":
			if err := func() error {
				s.DateCheckedUnix.Reset()
				if err := s.DateCheckedUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_checked_unix\"")
			}
		case "description_check":
			if err := func() error {
				s.DescriptionCheck.Reset()
				if err := s.DescriptionCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description_check\"")
			}
		case "description_value":
			if err := func() error {
				s.DescriptionValue.Reset()
				if err := s.DescriptionValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description_value\"")
			}
		case "name_check":
			if err := func() error {
				s.NameCheck.Reset()
				if err := s.NameCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_check\"")
			}
		case "name_value":
			if err := func() error {
				s.NameValue.Reset()
				if err := s.NameValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name_value\"")
			}
		case "sample_checks":
			if err := func() error {
				s.SampleChecks.Reset()
				if err := s.SampleChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_checks\"")
			}
		case "sample_ids":
			if err := func() error {
				s.SampleIds.Reset()
				if err := s.SampleIds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sample_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSharingModerationCheckResponseModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceSharingModerationCheckResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSharingModerationCheckResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceSharingResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceSharingResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.BanReason.Set {
			e.FieldStart("ban_reason")
			s.BanReason.Encode(e)
		}
	}
	{
		e.FieldStart("category")
		s.Category.Encode(e)
	}
	{
		e.FieldStart("cloned_by_count")
		e.Int(s.ClonedByCount)
	}
	{
		e.FieldStart("date_unix")
		e.Int(s.DateUnix)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DisableAtUnix.Set {
			e.FieldStart("disable_at_unix")
			s.DisableAtUnix.Encode(e)
		}
	}
	{
		e.FieldStart("enabled_in_library")
		e.Bool(s.EnabledInLibrary)
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
	{
		if s.FiatRate.Set {
			e.FieldStart("fiat_rate")
			s.FiatRate.Encode(e)
		}
	}
	{
		e.FieldStart("financial_rewards_enabled")
		e.Bool(s.FinancialRewardsEnabled)
	}
	{
		e.FieldStart("free_users_allowed")
		e.Bool(s.FreeUsersAllowed)
	}
	{
		if s.HistoryItemSampleID.Set {
			e.FieldStart("history_item_sample_id")
			s.HistoryItemSampleID.Encode(e)
		}
	}
	{
		if s.ImageURL.Set {
			e.FieldStart("image_url")
			s.ImageURL.Encode(e)
		}
	}
	{
		if s.InstagramUsername.Set {
			e.FieldStart("instagram_username")
			s.InstagramUsername.Encode(e)
		}
	}
	{
		e.FieldStart("labels")
		s.Labels.Encode(e)
	}
	{
		e.FieldStart("liked_by_count")
		e.Int(s.LikedByCount)
	}
	{
		e.FieldStart("live_moderation_enabled")
		e.Bool(s.LiveModerationEnabled)
	}
	{
		if s.ModerationCheck.Set {
			e.FieldStart("moderation_check")
			s.ModerationCheck.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("notice_period")
		e.Int(s.NoticePeriod)
	}
	{
		e.FieldStart("original_voice_id")
		e.Str(s.OriginalVoiceID)
	}
	{
		e.FieldStart("public_owner_id")
		e.Str(s.PublicOwnerID)
	}
	{
		if s.Rate.Set {
			e.FieldStart("rate")
			s.Rate.Encode(e)
		}
	}
	{
		if s.ReaderAppEnabled.Set {
			e.FieldStart("reader_app_enabled")
			s.ReaderAppEnabled.Encode(e)
		}
	}
	{
		if s.ReaderRestrictedOn.Set {
			e.FieldStart("reader_restricted_on")
			s.ReaderRestrictedOn.Encode(e)
		}
	}
	{
		if s.ReviewMessage.Set {
			e.FieldStart("review_message")
			s.ReviewMessage.Encode(e)
		}
	}
	{
		e.FieldStart("review_status")
		s.ReviewStatus.Encode(e)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.TiktokUsername.Set {
			e.FieldStart("tiktok_username")
			s.TiktokUsername.Encode(e)
		}
	}
	{
		if s.TwitterUsername.Set {
			e.FieldStart("twitter_username")
			s.TwitterUsername.Encode(e)
		}
	}
	{
		e.FieldStart("voice_mixing_allowed")
		e.Bool(s.VoiceMixingAllowed)
	}
	{
		e.FieldStart("whitelisted_emails")
		e.ArrStart()
		for _, elem := range s.WhitelistedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.YoutubeUsername.Set {
			e.FieldStart("youtube_username")
			s.YoutubeUsername.Encode(e)
		}
	}
}

var jsonFieldsNameOfVoiceSharingResponseModel = [33]string{
	0:  "ban_reason",
	1:  "category",
	2:  "cloned_by_count",
	3:  "date_unix",
	4:  "description",
	5:  "disable_at_unix",
	6:  "enabled_in_library",
	7:  "featured",
	8:  "fiat_rate",
	9:  "financial_rewards_enabled",
	10: "free_users_allowed",
	11: "history_item_sample_id",
	12: "image_url",
	13: "instagram_username",
	14: "labels",
	15: "liked_by_count",
	16: "live_moderation_enabled",
	17: "moderation_check",
	18: "name",
	19: "notice_period",
	20: "original_voice_id",
	21: "public_owner_id",
	22: "rate",
	23: "reader_app_enabled",
	24: "reader_restricted_on",
	25: "review_message",
	26: "review_status",
	27: "status",
	28: "tiktok_username",
	29: "twitter_username",
	30: "voice_mixing_allowed",
	31: "whitelisted_emails",
	32: "youtube_username",
}

// Decode decodes VoiceSharingResponseModel from json.
func (s *VoiceSharingResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSharingResponseModel to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ban_reason":
			if err := func() error {
				s.BanReason.Reset()
				if err := s.BanReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ban_reason\"")
			}
		case "category":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "cloned_by_count":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ClonedByCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cloned_by_count\"")
			}
		case "date_unix":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.DateUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_unix\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "disable_at_unix":
			if err := func() error {
				s.DisableAtUnix.Reset()
				if err := s.DisableAtUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disable_at_unix\"")
			}
		case "enabled_in_library":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.EnabledInLibrary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_in_library\"")
			}
		case "featured":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "fiat_rate":
			if err := func() error {
				s.FiatRate.Reset()
				if err := s.FiatRate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fiat_rate\"")
			}
		case "financial_rewards_enabled":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.FinancialRewardsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"financial_rewards_enabled\"")
			}
		case "free_users_allowed":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.FreeUsersAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free_users_allowed\"")
			}
		case "history_item_sample_id":
			if err := func() error {
				s.HistoryItemSampleID.Reset()
				if err := s.HistoryItemSampleID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"history_item_sample_id\"")
			}
		case "image_url":
			if err := func() error {
				s.ImageURL.Reset()
				if err := s.ImageURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_url\"")
			}
		case "instagram_username":
			if err := func() error {
				s.InstagramUsername.Reset()
				if err := s.InstagramUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instagram_username\"")
			}
		case "labels":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "liked_by_count":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.LikedByCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liked_by_count\"")
			}
		case "live_moderation_enabled":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.LiveModerationEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"live_moderation_enabled\"")
			}
		case "moderation_check":
			if err := func() error {
				s.ModerationCheck.Reset()
				if err := s.ModerationCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderation_check\"")
			}
		case "name":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "notice_period":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.NoticePeriod = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notice_period\"")
			}
		case "original_voice_id":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.OriginalVoiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"original_voice_id\"")
			}
		case "public_owner_id":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.PublicOwnerID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_owner_id\"")
			}
		case "rate":
			if err := func() error {
				s.Rate.Reset()
				if err := s.Rate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rate\"")
			}
		case "reader_app_enabled":
			if err := func() error {
				s.ReaderAppEnabled.Reset()
				if err := s.ReaderAppEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reader_app_enabled\"")
			}
		case "reader_restricted_on":
			if err := func() error {
				s.ReaderRestrictedOn.Reset()
				if err := s.ReaderRestrictedOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reader_restricted_on\"")
			}
		case "review_message":
			if err := func() error {
				s.ReviewMessage.Reset()
				if err := s.ReviewMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_message\"")
			}
		case "review_status":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				if err := s.ReviewStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"review_status\"")
			}
		case "status":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "tiktok_username":
			if err := func() error {
				s.TiktokUsername.Reset()
				if err := s.TiktokUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tiktok_username\"")
			}
		case "twitter_username":
			if err := func() error {
				s.TwitterUsername.Reset()
				if err := s.TwitterUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"twitter_username\"")
			}
		case "voice_mixing_allowed":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.VoiceMixingAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"voice_mixing_allowed\"")
			}
		case "whitelisted_emails":
			requiredBitSet[3] |= 1 << 7
			if err := func() error {
				s.WhitelistedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.WhitelistedEmails = append(s.WhitelistedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whitelisted_emails\"")
			}
		case "youtube_username":
			if err := func() error {
				s.YoutubeUsername.Reset()
				if err := s.YoutubeUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"youtube_username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSharingResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11001110,
		0b11000110,
		0b00111101,
		0b11001100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceSharingResponseModel) {
					name = jsonFieldsNameOfVoiceSharingResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceSharingResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSharingResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceSharingResponseModelCategory as json.
func (s VoiceSharingResponseModelCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceSharingResponseModelCategory from json.
func (s *VoiceSharingResponseModelCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSharingResponseModelCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceSharingResponseModelCategory(v) {
	case VoiceSharingResponseModelCategoryGenerated:
		*s = VoiceSharingResponseModelCategoryGenerated
	case VoiceSharingResponseModelCategoryCloned:
		*s = VoiceSharingResponseModelCategoryCloned
	case VoiceSharingResponseModelCategoryPremade:
		*s = VoiceSharingResponseModelCategoryPremade
	case VoiceSharingResponseModelCategoryProfessional:
		*s = VoiceSharingResponseModelCategoryProfessional
	case VoiceSharingResponseModelCategoryFamous:
		*s = VoiceSharingResponseModelCategoryFamous
	case VoiceSharingResponseModelCategoryHighQuality:
		*s = VoiceSharingResponseModelCategoryHighQuality
	default:
		*s = VoiceSharingResponseModelCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceSharingResponseModelCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSharingResponseModelCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s VoiceSharingResponseModelLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s VoiceSharingResponseModelLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes VoiceSharingResponseModelLabels from json.
func (s *VoiceSharingResponseModelLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSharingResponseModelLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceSharingResponseModelLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceSharingResponseModelLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSharingResponseModelLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceSharingResponseModelReviewStatus as json.
func (s VoiceSharingResponseModelReviewStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceSharingResponseModelReviewStatus from json.
func (s *VoiceSharingResponseModelReviewStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSharingResponseModelReviewStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceSharingResponseModelReviewStatus(v) {
	case VoiceSharingResponseModelReviewStatusNotRequested:
		*s = VoiceSharingResponseModelReviewStatusNotRequested
	case VoiceSharingResponseModelReviewStatusPending:
		*s = VoiceSharingResponseModelReviewStatusPending
	case VoiceSharingResponseModelReviewStatusDeclined:
		*s = VoiceSharingResponseModelReviewStatusDeclined
	case VoiceSharingResponseModelReviewStatusAllowed:
		*s = VoiceSharingResponseModelReviewStatusAllowed
	case VoiceSharingResponseModelReviewStatusAllowedWithChanges:
		*s = VoiceSharingResponseModelReviewStatusAllowedWithChanges
	default:
		*s = VoiceSharingResponseModelReviewStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceSharingResponseModelReviewStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSharingResponseModelReviewStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VoiceSharingResponseModelStatus as json.
func (s VoiceSharingResponseModelStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VoiceSharingResponseModelStatus from json.
func (s *VoiceSharingResponseModelStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceSharingResponseModelStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VoiceSharingResponseModelStatus(v) {
	case VoiceSharingResponseModelStatusEnabled:
		*s = VoiceSharingResponseModelStatusEnabled
	case VoiceSharingResponseModelStatusDisabled:
		*s = VoiceSharingResponseModelStatusDisabled
	case VoiceSharingResponseModelStatusCopied:
		*s = VoiceSharingResponseModelStatusCopied
	case VoiceSharingResponseModelStatusCopiedDisabled:
		*s = VoiceSharingResponseModelStatusCopiedDisabled
	default:
		*s = VoiceSharingResponseModelStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VoiceSharingResponseModelStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceSharingResponseModelStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VoiceVerificationResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VoiceVerificationResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_verified")
		e.Bool(s.IsVerified)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		e.FieldStart("requires_verification")
		e.Bool(s.RequiresVerification)
	}
	{
		if s.VerificationAttempts.Set {
			e.FieldStart("verification_attempts")
			s.VerificationAttempts.Encode(e)
		}
	}
	{
		e.FieldStart("verification_attempts_count")
		e.Int(s.VerificationAttemptsCount)
	}
	{
		e.FieldStart("verification_failures")
		e.ArrStart()
		for _, elem := range s.VerificationFailures {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVoiceVerificationResponseModel = [6]string{
	0: "is_verified",
	1: "language",
	2: "requires_verification",
	3: "verification_attempts",
	4: "verification_attempts_count",
	5: "verification_failures",
}

// Decode decodes VoiceVerificationResponseModel from json.
func (s *VoiceVerificationResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VoiceVerificationResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_verified":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsVerified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_verified\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "requires_verification":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.RequiresVerification = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requires_verification\"")
			}
		case "verification_attempts":
			if err := func() error {
				s.VerificationAttempts.Reset()
				if err := s.VerificationAttempts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_attempts\"")
			}
		case "verification_attempts_count":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.VerificationAttemptsCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_attempts_count\"")
			}
		case "verification_failures":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.VerificationFailures = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.VerificationFailures = append(s.VerificationFailures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_failures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VoiceVerificationResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVoiceVerificationResponseModel) {
					name = jsonFieldsNameOfVoiceVerificationResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VoiceVerificationResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VoiceVerificationResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookAuthMethodType as json.
func (s WebhookAuthMethodType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookAuthMethodType from json.
func (s *WebhookAuthMethodType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookAuthMethodType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookAuthMethodType(v) {
	case WebhookAuthMethodTypeHmac:
		*s = WebhookAuthMethodTypeHmac
	case WebhookAuthMethodTypeOAuth2:
		*s = WebhookAuthMethodTypeOAuth2
	case WebhookAuthMethodTypeMtls:
		*s = WebhookAuthMethodTypeMtls
	default:
		*s = WebhookAuthMethodType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookAuthMethodType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookAuthMethodType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookEventType as json.
func (s WebhookEventType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookEventType from json.
func (s *WebhookEventType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookEventType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookEventType(v) {
	case WebhookEventTypeTranscript:
		*s = WebhookEventTypeTranscript
	case WebhookEventTypeAudio:
		*s = WebhookEventTypeAudio
	case WebhookEventTypeCallInitiationFailure:
		*s = WebhookEventTypeCallInitiationFailure
	default:
		*s = WebhookEventType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookEventType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookEventType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookHMACSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookHMACSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_type")
		s.AuthType.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("webhook_url")
		e.Str(s.WebhookURL)
	}
}

var jsonFieldsNameOfWebhookHMACSettings = [3]string{
	0: "auth_type",
	1: "name",
	2: "webhook_url",
}

// Decode decodes WebhookHMACSettings from json.
func (s *WebhookHMACSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookHMACSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_type\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "webhook_url":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WebhookURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookHMACSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWebhookHMACSettings) {
					name = jsonFieldsNameOfWebhookHMACSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookHMACSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookHMACSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookHMACSettingsAuthType as json.
func (s WebhookHMACSettingsAuthType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookHMACSettingsAuthType from json.
func (s *WebhookHMACSettingsAuthType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookHMACSettingsAuthType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookHMACSettingsAuthType(v) {
	case WebhookHMACSettingsAuthTypeHmac:
		*s = WebhookHMACSettingsAuthTypeHmac
	default:
		*s = WebhookHMACSettingsAuthType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookHMACSettingsAuthType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookHMACSettingsAuthType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookUsageType as json.
func (s WebhookUsageType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WebhookUsageType from json.
func (s *WebhookUsageType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookUsageType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WebhookUsageType(v) {
	case WebhookUsageTypeConvAIAgentSettings:
		*s = WebhookUsageTypeConvAIAgentSettings
	case WebhookUsageTypeConvAISettings:
		*s = WebhookUsageTypeConvAISettings
	case WebhookUsageTypeVoiceLibraryRemovalNotices:
		*s = WebhookUsageTypeVoiceLibraryRemovalNotices
	case WebhookUsageTypeSpeechToText:
		*s = WebhookUsageTypeSpeechToText
	default:
		*s = WebhookUsageType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WebhookUsageType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookUsageType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WhatsAppConversationInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WhatsAppConversationInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Direction.Set {
			e.FieldStart("direction")
			s.Direction.Encode(e)
		}
	}
	{
		if s.WhatsappPhoneNumberID.Set {
			e.FieldStart("whatsapp_phone_number_id")
			s.WhatsappPhoneNumberID.Encode(e)
		}
	}
	{
		e.FieldStart("whatsapp_user_id")
		e.Str(s.WhatsappUserID)
	}
}

var jsonFieldsNameOfWhatsAppConversationInfo = [3]string{
	0: "direction",
	1: "whatsapp_phone_number_id",
	2: "whatsapp_user_id",
}

// Decode decodes WhatsAppConversationInfo from json.
func (s *WhatsAppConversationInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhatsAppConversationInfo to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "direction":
			if err := func() error {
				s.Direction.Reset()
				if err := s.Direction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direction\"")
			}
		case "whatsapp_phone_number_id":
			if err := func() error {
				s.WhatsappPhoneNumberID.Reset()
				if err := s.WhatsappPhoneNumberID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_phone_number_id\"")
			}
		case "whatsapp_user_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.WhatsappUserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"whatsapp_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WhatsAppConversationInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWhatsAppConversationInfo) {
					name = jsonFieldsNameOfWhatsAppConversationInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhatsAppConversationInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhatsAppConversationInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WhatsAppConversationInfoDirection as json.
func (s WhatsAppConversationInfoDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WhatsAppConversationInfoDirection from json.
func (s *WhatsAppConversationInfoDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhatsAppConversationInfoDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WhatsAppConversationInfoDirection(v) {
	case WhatsAppConversationInfoDirectionInbound:
		*s = WhatsAppConversationInfoDirectionInbound
	case WhatsAppConversationInfoDirectionOutbound:
		*s = WhatsAppConversationInfoDirectionOutbound
	case WhatsAppConversationInfoDirectionUnknown:
		*s = WhatsAppConversationInfoDirectionUnknown
	default:
		*s = WhatsAppConversationInfoDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WhatsAppConversationInfoDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhatsAppConversationInfoDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WhatsAppOutboundCallResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WhatsAppOutboundCallResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("conversation_id")
		s.ConversationID.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("success")
		e.Bool(s.Success)
	}
}

var jsonFieldsNameOfWhatsAppOutboundCallResponse = [3]string{
	0: "conversation_id",
	1: "message",
	2: "success",
}

// Decode decodes WhatsAppOutboundCallResponse from json.
func (s *WhatsAppOutboundCallResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhatsAppOutboundCallResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "conversation_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConversationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conversation_id\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "success":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Success = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WhatsAppOutboundCallResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWhatsAppOutboundCallResponse) {
					name = jsonFieldsNameOfWhatsAppOutboundCallResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhatsAppOutboundCallResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhatsAppOutboundCallResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowFeaturesUsageCommonModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowFeaturesUsageCommonModel) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.EndNode.Set {
			e.FieldStart("end_node")
			s.EndNode.Encode(e)
		}
	}
	{
		if s.PhoneNumberNode.Set {
			e.FieldStart("phone_number_node")
			s.PhoneNumberNode.Encode(e)
		}
	}
	{
		if s.StandaloneAgentNode.Set {
			e.FieldStart("standalone_agent_node")
			s.StandaloneAgentNode.Encode(e)
		}
	}
	{
		if s.ToolNode.Set {
			e.FieldStart("tool_node")
			s.ToolNode.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowFeaturesUsageCommonModel = [5]string{
	0: "enabled",
	1: "end_node",
	2: "phone_number_node",
	3: "standalone_agent_node",
	4: "tool_node",
}

// Decode decodes WorkflowFeaturesUsageCommonModel from json.
func (s *WorkflowFeaturesUsageCommonModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowFeaturesUsageCommonModel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "end_node":
			if err := func() error {
				s.EndNode.Reset()
				if err := s.EndNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end_node\"")
			}
		case "phone_number_node":
			if err := func() error {
				s.PhoneNumberNode.Reset()
				if err := s.PhoneNumberNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phone_number_node\"")
			}
		case "standalone_agent_node":
			if err := func() error {
				s.StandaloneAgentNode.Reset()
				if err := s.StandaloneAgentNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standalone_agent_node\"")
			}
		case "tool_node":
			if err := func() error {
				s.ToolNode.Reset()
				if err := s.ToolNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tool_node\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowFeaturesUsageCommonModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowFeaturesUsageCommonModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowFeaturesUsageCommonModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowToolEdgeStepModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowToolEdgeStepModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("edge_id")
		e.Str(s.EdgeID)
	}
	{
		e.FieldStart("step_latency_secs")
		e.Float64(s.StepLatencySecs)
	}
	{
		e.FieldStart("target_node_id")
		e.Str(s.TargetNodeID)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowToolEdgeStepModel = [4]string{
	0: "edge_id",
	1: "step_latency_secs",
	2: "target_node_id",
	3: "type",
}

// Decode decodes WorkflowToolEdgeStepModel from json.
func (s *WorkflowToolEdgeStepModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolEdgeStepModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "edge_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EdgeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"edge_id\"")
			}
		case "step_latency_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.StepLatencySecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step_latency_secs\"")
			}
		case "target_node_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TargetNodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target_node_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowToolEdgeStepModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowToolEdgeStepModel) {
					name = jsonFieldsNameOfWorkflowToolEdgeStepModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowToolEdgeStepModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolEdgeStepModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolEdgeStepModelType as json.
func (s WorkflowToolEdgeStepModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowToolEdgeStepModelType from json.
func (s *WorkflowToolEdgeStepModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolEdgeStepModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowToolEdgeStepModelType(v) {
	case WorkflowToolEdgeStepModelTypeEdge:
		*s = WorkflowToolEdgeStepModelTypeEdge
	default:
		*s = WorkflowToolEdgeStepModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolEdgeStepModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolEdgeStepModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowToolMaxIterationsExceededStepModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowToolMaxIterationsExceededStepModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("max_iterations")
		e.Int(s.MaxIterations)
	}
	{
		e.FieldStart("step_latency_secs")
		e.Float64(s.StepLatencySecs)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowToolMaxIterationsExceededStepModel = [3]string{
	0: "max_iterations",
	1: "step_latency_secs",
	2: "type",
}

// Decode decodes WorkflowToolMaxIterationsExceededStepModel from json.
func (s *WorkflowToolMaxIterationsExceededStepModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolMaxIterationsExceededStepModel to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max_iterations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.MaxIterations = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max_iterations\"")
			}
		case "step_latency_secs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.StepLatencySecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step_latency_secs\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowToolMaxIterationsExceededStepModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowToolMaxIterationsExceededStepModel) {
					name = jsonFieldsNameOfWorkflowToolMaxIterationsExceededStepModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowToolMaxIterationsExceededStepModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolMaxIterationsExceededStepModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolMaxIterationsExceededStepModelType as json.
func (s WorkflowToolMaxIterationsExceededStepModelType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowToolMaxIterationsExceededStepModelType from json.
func (s *WorkflowToolMaxIterationsExceededStepModelType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolMaxIterationsExceededStepModelType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowToolMaxIterationsExceededStepModelType(v) {
	case WorkflowToolMaxIterationsExceededStepModelTypeMaxIterationsExceeded:
		*s = WorkflowToolMaxIterationsExceededStepModelTypeMaxIterationsExceeded
	default:
		*s = WorkflowToolMaxIterationsExceededStepModelType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolMaxIterationsExceededStepModelType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolMaxIterationsExceededStepModelType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowToolNestedToolsStepModelInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowToolNestedToolsStepModelInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_successful")
		e.Bool(s.IsSuccessful)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("requests")
		e.ArrStart()
		for _, elem := range s.Requests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("step_latency_secs")
		e.Float64(s.StepLatencySecs)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowToolNestedToolsStepModelInput = [6]string{
	0: "is_successful",
	1: "node_id",
	2: "requests",
	3: "results",
	4: "step_latency_secs",
	5: "type",
}

// Decode decodes WorkflowToolNestedToolsStepModelInput from json.
func (s *WorkflowToolNestedToolsStepModelInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolNestedToolsStepModelInput to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_successful":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsSuccessful = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_successful\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "requests":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Requests = make([]ConversationHistoryTranscriptToolCallCommonModelInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptToolCallCommonModelInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Requests = append(s.Requests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]WorkflowToolNestedToolsStepModelInputResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowToolNestedToolsStepModelInputResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "step_latency_secs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.StepLatencySecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step_latency_secs\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowToolNestedToolsStepModelInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowToolNestedToolsStepModelInput) {
					name = jsonFieldsNameOfWorkflowToolNestedToolsStepModelInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowToolNestedToolsStepModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolNestedToolsStepModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolNestedToolsStepModelInputResultsItem as json.
func (s WorkflowToolNestedToolsStepModelInputResultsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput.Encode(e)
	}
}

func (s WorkflowToolNestedToolsStepModelInputResultsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputWorkflowToolNestedToolsStepModelInputResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput.encodeFields(e)
	}
}

// Decode decodes WorkflowToolNestedToolsStepModelInputResultsItem from json.
func (s *WorkflowToolNestedToolsStepModelInputResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolNestedToolsStepModelInputResultsItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "credential_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_connection_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "result":
				match := ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "type":
				// Value-based discrimination: check enum value
				if typ := d.Next(); typ != jx.String {
					return d.Skip()
				}
				value, err := d.StrBytes()
				if err != nil {
					return err
				}
				switch string(value) {
				case "api_integration_webhook":
					match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "client":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "mcp":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "system":
					match := ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "webhook":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				default:
					// Unknown enum value, ignore and continue
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputWorkflowToolNestedToolsStepModelInputResultsItem
	}
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		if err := s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		if err := s.ConversationHistoryTranscriptSystemToolResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelInputResultsItem:
		if err := s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelInputWorkflowToolNestedToolsStepModelInputResultsItem:
		if err := s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelInput.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolNestedToolsStepModelInputResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolNestedToolsStepModelInputResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolNestedToolsStepModelInputType as json.
func (s WorkflowToolNestedToolsStepModelInputType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowToolNestedToolsStepModelInputType from json.
func (s *WorkflowToolNestedToolsStepModelInputType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolNestedToolsStepModelInputType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowToolNestedToolsStepModelInputType(v) {
	case WorkflowToolNestedToolsStepModelInputTypeNestedTools:
		*s = WorkflowToolNestedToolsStepModelInputTypeNestedTools
	default:
		*s = WorkflowToolNestedToolsStepModelInputType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolNestedToolsStepModelInputType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolNestedToolsStepModelInputType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowToolNestedToolsStepModelOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowToolNestedToolsStepModelOutput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_successful")
		e.Bool(s.IsSuccessful)
	}
	{
		e.FieldStart("node_id")
		e.Str(s.NodeID)
	}
	{
		e.FieldStart("requests")
		e.ArrStart()
		for _, elem := range s.Requests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("results")
		e.ArrStart()
		for _, elem := range s.Results {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("step_latency_secs")
		e.Float64(s.StepLatencySecs)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkflowToolNestedToolsStepModelOutput = [6]string{
	0: "is_successful",
	1: "node_id",
	2: "requests",
	3: "results",
	4: "step_latency_secs",
	5: "type",
}

// Decode decodes WorkflowToolNestedToolsStepModelOutput from json.
func (s *WorkflowToolNestedToolsStepModelOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolNestedToolsStepModelOutput to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_successful":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsSuccessful = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_successful\"")
			}
		case "node_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node_id\"")
			}
		case "requests":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Requests = make([]ConversationHistoryTranscriptToolCallCommonModelOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConversationHistoryTranscriptToolCallCommonModelOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Requests = append(s.Requests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		case "results":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Results = make([]WorkflowToolNestedToolsStepModelOutputResultsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowToolNestedToolsStepModelOutputResultsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "step_latency_secs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.StepLatencySecs = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step_latency_secs\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowToolNestedToolsStepModelOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkflowToolNestedToolsStepModelOutput) {
					name = jsonFieldsNameOfWorkflowToolNestedToolsStepModelOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowToolNestedToolsStepModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolNestedToolsStepModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolNestedToolsStepModelOutputResultsItem as json.
func (s WorkflowToolNestedToolsStepModelOutputResultsItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Encode(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput.Encode(e)
	}
}

func (s WorkflowToolNestedToolsStepModelOutputResultsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptOtherToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptSystemToolResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.encodeFields(e)
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputWorkflowToolNestedToolsStepModelOutputResultsItem:
		s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput.encodeFields(e)
	}
}

// Decode decodes WorkflowToolNestedToolsStepModelOutputResultsItem from json.
func (s *WorkflowToolNestedToolsStepModelOutputResultsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolNestedToolsStepModelOutputResultsItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "credential_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_connection_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "integration_id":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "result":
				match := ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "type":
				// Value-based discrimination: check enum value
				if typ := d.Next(); typ != jx.String {
					return d.Skip()
				}
				value, err := d.StrBytes()
				if err != nil {
					return err
				}
				switch string(value) {
				case "api_integration_webhook":
					match := ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "client":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "mcp":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "system":
					match := ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				case "webhook":
					match := ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem
					if found && s.Type != match {
						s.Type = ""
						return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
					}
					found = true
					s.Type = match
				default:
					// Unknown enum value, ignore and continue
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputWorkflowToolNestedToolsStepModelOutputResultsItem
	}
	switch s.Type {
	case ConversationHistoryTranscriptOtherToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		if err := s.ConversationHistoryTranscriptOtherToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptSystemToolResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		if err := s.ConversationHistoryTranscriptSystemToolResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModelWorkflowToolNestedToolsStepModelOutputResultsItem:
		if err := s.ConversationHistoryTranscriptApiIntegrationWebhookToolsResultCommonModel.Decode(d); err != nil {
			return err
		}
	case ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutputWorkflowToolNestedToolsStepModelOutputResultsItem:
		if err := s.ConversationHistoryTranscriptWorkflowToolsResultCommonModelOutput.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolNestedToolsStepModelOutputResultsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolNestedToolsStepModelOutputResultsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolNestedToolsStepModelOutputType as json.
func (s WorkflowToolNestedToolsStepModelOutputType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkflowToolNestedToolsStepModelOutputType from json.
func (s *WorkflowToolNestedToolsStepModelOutputType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolNestedToolsStepModelOutputType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkflowToolNestedToolsStepModelOutputType(v) {
	case WorkflowToolNestedToolsStepModelOutputTypeNestedTools:
		*s = WorkflowToolNestedToolsStepModelOutputTypeNestedTools
	default:
		*s = WorkflowToolNestedToolsStepModelOutputType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolNestedToolsStepModelOutputType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolNestedToolsStepModelOutputType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowToolResponseModelInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowToolResponseModelInput) encodeFields(e *jx.Encoder) {
	{
		if s.Steps != nil {
			e.FieldStart("steps")
			e.ArrStart()
			for _, elem := range s.Steps {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWorkflowToolResponseModelInput = [1]string{
	0: "steps",
}

// Decode decodes WorkflowToolResponseModelInput from json.
func (s *WorkflowToolResponseModelInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolResponseModelInput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "steps":
			if err := func() error {
				s.Steps = make([]WorkflowToolResponseModelInputStepsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowToolResponseModelInputStepsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Steps = append(s.Steps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"steps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowToolResponseModelInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowToolResponseModelInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolResponseModelInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolResponseModelInputStepsItem as json.
func (s WorkflowToolResponseModelInputStepsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s WorkflowToolResponseModelInputStepsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case WorkflowToolEdgeStepModelWorkflowToolResponseModelInputStepsItem:
		e.FieldStart("type")
		e.Str("edge")
		{
			s := s.WorkflowToolEdgeStepModel
			{
				e.FieldStart("edge_id")
				e.Str(s.EdgeID)
			}
			{
				e.FieldStart("step_latency_secs")
				e.Float64(s.StepLatencySecs)
			}
			{
				e.FieldStart("target_node_id")
				e.Str(s.TargetNodeID)
			}
		}
	case WorkflowToolNestedToolsStepModelInputWorkflowToolResponseModelInputStepsItem:
		e.FieldStart("type")
		e.Str("nested_tools")
		{
			s := s.WorkflowToolNestedToolsStepModelInput
			{
				e.FieldStart("is_successful")
				e.Bool(s.IsSuccessful)
			}
			{
				e.FieldStart("node_id")
				e.Str(s.NodeID)
			}
			{
				e.FieldStart("requests")
				e.ArrStart()
				for _, elem := range s.Requests {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("results")
				e.ArrStart()
				for _, elem := range s.Results {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("step_latency_secs")
				e.Float64(s.StepLatencySecs)
			}
		}
	case WorkflowToolMaxIterationsExceededStepModelWorkflowToolResponseModelInputStepsItem:
		e.FieldStart("type")
		e.Str("max_iterations_exceeded")
		{
			s := s.WorkflowToolMaxIterationsExceededStepModel
			{
				e.FieldStart("max_iterations")
				e.Int(s.MaxIterations)
			}
			{
				e.FieldStart("step_latency_secs")
				e.Float64(s.StepLatencySecs)
			}
		}
	}
}

// Decode decodes WorkflowToolResponseModelInputStepsItem from json.
func (s *WorkflowToolResponseModelInputStepsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolResponseModelInputStepsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "edge":
					s.Type = WorkflowToolEdgeStepModelWorkflowToolResponseModelInputStepsItem
					found = true
				case "nested_tools":
					s.Type = WorkflowToolNestedToolsStepModelInputWorkflowToolResponseModelInputStepsItem
					found = true
				case "max_iterations_exceeded":
					s.Type = WorkflowToolMaxIterationsExceededStepModelWorkflowToolResponseModelInputStepsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case WorkflowToolEdgeStepModelWorkflowToolResponseModelInputStepsItem:
		if err := s.WorkflowToolEdgeStepModel.Decode(d); err != nil {
			return err
		}
	case WorkflowToolNestedToolsStepModelInputWorkflowToolResponseModelInputStepsItem:
		if err := s.WorkflowToolNestedToolsStepModelInput.Decode(d); err != nil {
			return err
		}
	case WorkflowToolMaxIterationsExceededStepModelWorkflowToolResponseModelInputStepsItem:
		if err := s.WorkflowToolMaxIterationsExceededStepModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolResponseModelInputStepsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolResponseModelInputStepsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkflowToolResponseModelOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkflowToolResponseModelOutput) encodeFields(e *jx.Encoder) {
	{
		if s.Steps != nil {
			e.FieldStart("steps")
			e.ArrStart()
			for _, elem := range s.Steps {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfWorkflowToolResponseModelOutput = [1]string{
	0: "steps",
}

// Decode decodes WorkflowToolResponseModelOutput from json.
func (s *WorkflowToolResponseModelOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolResponseModelOutput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "steps":
			if err := func() error {
				s.Steps = make([]WorkflowToolResponseModelOutputStepsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkflowToolResponseModelOutputStepsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Steps = append(s.Steps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"steps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkflowToolResponseModelOutput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkflowToolResponseModelOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolResponseModelOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkflowToolResponseModelOutputStepsItem as json.
func (s WorkflowToolResponseModelOutputStepsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s WorkflowToolResponseModelOutputStepsItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case WorkflowToolEdgeStepModelWorkflowToolResponseModelOutputStepsItem:
		e.FieldStart("type")
		e.Str("edge")
		{
			s := s.WorkflowToolEdgeStepModel
			{
				e.FieldStart("edge_id")
				e.Str(s.EdgeID)
			}
			{
				e.FieldStart("step_latency_secs")
				e.Float64(s.StepLatencySecs)
			}
			{
				e.FieldStart("target_node_id")
				e.Str(s.TargetNodeID)
			}
		}
	case WorkflowToolNestedToolsStepModelOutputWorkflowToolResponseModelOutputStepsItem:
		e.FieldStart("type")
		e.Str("nested_tools")
		{
			s := s.WorkflowToolNestedToolsStepModelOutput
			{
				e.FieldStart("is_successful")
				e.Bool(s.IsSuccessful)
			}
			{
				e.FieldStart("node_id")
				e.Str(s.NodeID)
			}
			{
				e.FieldStart("requests")
				e.ArrStart()
				for _, elem := range s.Requests {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("results")
				e.ArrStart()
				for _, elem := range s.Results {
					elem.Encode(e)
				}
				e.ArrEnd()
			}
			{
				e.FieldStart("step_latency_secs")
				e.Float64(s.StepLatencySecs)
			}
		}
	case WorkflowToolMaxIterationsExceededStepModelWorkflowToolResponseModelOutputStepsItem:
		e.FieldStart("type")
		e.Str("max_iterations_exceeded")
		{
			s := s.WorkflowToolMaxIterationsExceededStepModel
			{
				e.FieldStart("max_iterations")
				e.Int(s.MaxIterations)
			}
			{
				e.FieldStart("step_latency_secs")
				e.Float64(s.StepLatencySecs)
			}
		}
	}
}

// Decode decodes WorkflowToolResponseModelOutputStepsItem from json.
func (s *WorkflowToolResponseModelOutputStepsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkflowToolResponseModelOutputStepsItem to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "edge":
					s.Type = WorkflowToolEdgeStepModelWorkflowToolResponseModelOutputStepsItem
					found = true
				case "nested_tools":
					s.Type = WorkflowToolNestedToolsStepModelOutputWorkflowToolResponseModelOutputStepsItem
					found = true
				case "max_iterations_exceeded":
					s.Type = WorkflowToolMaxIterationsExceededStepModelWorkflowToolResponseModelOutputStepsItem
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case WorkflowToolEdgeStepModelWorkflowToolResponseModelOutputStepsItem:
		if err := s.WorkflowToolEdgeStepModel.Decode(d); err != nil {
			return err
		}
	case WorkflowToolNestedToolsStepModelOutputWorkflowToolResponseModelOutputStepsItem:
		if err := s.WorkflowToolNestedToolsStepModelOutput.Decode(d); err != nil {
			return err
		}
	case WorkflowToolMaxIterationsExceededStepModelWorkflowToolResponseModelOutputStepsItem:
		if err := s.WorkflowToolMaxIterationsExceededStepModel.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkflowToolResponseModelOutputStepsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkflowToolResponseModelOutputStepsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceApiKeyListResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceApiKeyListResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("api-keys")
		e.ArrStart()
		for _, elem := range s.APIMinusKeys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfWorkspaceApiKeyListResponseModel = [1]string{
	0: "api-keys",
}

// Decode decodes WorkspaceApiKeyListResponseModel from json.
func (s *WorkspaceApiKeyListResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceApiKeyListResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "api-keys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.APIMinusKeys = make([]WorkspaceApiKeyResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkspaceApiKeyResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.APIMinusKeys = append(s.APIMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api-keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceApiKeyListResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceApiKeyListResponseModel) {
					name = jsonFieldsNameOfWorkspaceApiKeyListResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceApiKeyListResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceApiKeyListResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceApiKeyResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceApiKeyResponseModel) encodeFields(e *jx.Encoder) {
	{
		if s.CharacterCount.Set {
			e.FieldStart("character_count")
			s.CharacterCount.Encode(e)
		}
	}
	{
		if s.CharacterLimit.Set {
			e.FieldStart("character_limit")
			s.CharacterLimit.Encode(e)
		}
	}
	{
		if s.CreatedAtUnix.Set {
			e.FieldStart("created_at_unix")
			s.CreatedAtUnix.Encode(e)
		}
	}
	{
		e.FieldStart("hint")
		e.Str(s.Hint)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("is_disabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		e.FieldStart("key_id")
		e.Str(s.KeyID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		e.FieldStart("service_account_user_id")
		e.Str(s.ServiceAccountUserID)
	}
}

var jsonFieldsNameOfWorkspaceApiKeyResponseModel = [9]string{
	0: "character_count",
	1: "character_limit",
	2: "created_at_unix",
	3: "hint",
	4: "is_disabled",
	5: "key_id",
	6: "name",
	7: "permissions",
	8: "service_account_user_id",
}

// Decode decodes WorkspaceApiKeyResponseModel from json.
func (s *WorkspaceApiKeyResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceApiKeyResponseModel to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "character_count":
			if err := func() error {
				s.CharacterCount.Reset()
				if err := s.CharacterCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_count\"")
			}
		case "character_limit":
			if err := func() error {
				s.CharacterLimit.Reset()
				if err := s.CharacterLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"character_limit\"")
			}
		case "created_at_unix":
			if err := func() error {
				s.CreatedAtUnix.Reset()
				if err := s.CreatedAtUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "hint":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Hint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hint\"")
			}
		case "is_disabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_disabled\"")
			}
		case "key_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "service_account_user_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServiceAccountUserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_account_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceApiKeyResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01101000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceApiKeyResponseModel) {
					name = jsonFieldsNameOfWorkspaceApiKeyResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceApiKeyResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceApiKeyResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkspaceApiKeyResponseModelPermissionsItem as json.
func (s WorkspaceApiKeyResponseModelPermissionsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkspaceApiKeyResponseModelPermissionsItem from json.
func (s *WorkspaceApiKeyResponseModelPermissionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceApiKeyResponseModelPermissionsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkspaceApiKeyResponseModelPermissionsItem(v) {
	case WorkspaceApiKeyResponseModelPermissionsItemTextToSpeech:
		*s = WorkspaceApiKeyResponseModelPermissionsItemTextToSpeech
	case WorkspaceApiKeyResponseModelPermissionsItemSpeechToSpeech:
		*s = WorkspaceApiKeyResponseModelPermissionsItemSpeechToSpeech
	case WorkspaceApiKeyResponseModelPermissionsItemSpeechToText:
		*s = WorkspaceApiKeyResponseModelPermissionsItemSpeechToText
	case WorkspaceApiKeyResponseModelPermissionsItemModelsRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemModelsRead
	case WorkspaceApiKeyResponseModelPermissionsItemModelsWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemModelsWrite
	case WorkspaceApiKeyResponseModelPermissionsItemVoicesRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemVoicesRead
	case WorkspaceApiKeyResponseModelPermissionsItemVoicesWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemVoicesWrite
	case WorkspaceApiKeyResponseModelPermissionsItemSpeechHistoryRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemSpeechHistoryRead
	case WorkspaceApiKeyResponseModelPermissionsItemSpeechHistoryWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemSpeechHistoryWrite
	case WorkspaceApiKeyResponseModelPermissionsItemSoundGeneration:
		*s = WorkspaceApiKeyResponseModelPermissionsItemSoundGeneration
	case WorkspaceApiKeyResponseModelPermissionsItemAudioIsolation:
		*s = WorkspaceApiKeyResponseModelPermissionsItemAudioIsolation
	case WorkspaceApiKeyResponseModelPermissionsItemVoiceGeneration:
		*s = WorkspaceApiKeyResponseModelPermissionsItemVoiceGeneration
	case WorkspaceApiKeyResponseModelPermissionsItemDubbingRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemDubbingRead
	case WorkspaceApiKeyResponseModelPermissionsItemDubbingWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemDubbingWrite
	case WorkspaceApiKeyResponseModelPermissionsItemPronunciationDictionariesRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemPronunciationDictionariesRead
	case WorkspaceApiKeyResponseModelPermissionsItemPronunciationDictionariesWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemPronunciationDictionariesWrite
	case WorkspaceApiKeyResponseModelPermissionsItemUserRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemUserRead
	case WorkspaceApiKeyResponseModelPermissionsItemUserWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemUserWrite
	case WorkspaceApiKeyResponseModelPermissionsItemProjectsRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemProjectsRead
	case WorkspaceApiKeyResponseModelPermissionsItemProjectsWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemProjectsWrite
	case WorkspaceApiKeyResponseModelPermissionsItemAudioNativeRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemAudioNativeRead
	case WorkspaceApiKeyResponseModelPermissionsItemAudioNativeWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemAudioNativeWrite
	case WorkspaceApiKeyResponseModelPermissionsItemWorkspaceRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemWorkspaceRead
	case WorkspaceApiKeyResponseModelPermissionsItemWorkspaceWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemWorkspaceWrite
	case WorkspaceApiKeyResponseModelPermissionsItemForcedAlignment:
		*s = WorkspaceApiKeyResponseModelPermissionsItemForcedAlignment
	case WorkspaceApiKeyResponseModelPermissionsItemConvaiRead:
		*s = WorkspaceApiKeyResponseModelPermissionsItemConvaiRead
	case WorkspaceApiKeyResponseModelPermissionsItemConvaiWrite:
		*s = WorkspaceApiKeyResponseModelPermissionsItemConvaiWrite
	case WorkspaceApiKeyResponseModelPermissionsItemMusicGeneration:
		*s = WorkspaceApiKeyResponseModelPermissionsItemMusicGeneration
	default:
		*s = WorkspaceApiKeyResponseModelPermissionsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkspaceApiKeyResponseModelPermissionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceApiKeyResponseModelPermissionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceBatchCallsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceBatchCallsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("batch_calls")
		e.ArrStart()
		for _, elem := range s.BatchCalls {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.HasMore.Set {
			e.FieldStart("has_more")
			s.HasMore.Encode(e)
		}
	}
	{
		if s.NextDoc.Set {
			e.FieldStart("next_doc")
			s.NextDoc.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceBatchCallsResponse = [3]string{
	0: "batch_calls",
	1: "has_more",
	2: "next_doc",
}

// Decode decodes WorkspaceBatchCallsResponse from json.
func (s *WorkspaceBatchCallsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceBatchCallsResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "batch_calls":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.BatchCalls = make([]BatchCallResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BatchCallResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BatchCalls = append(s.BatchCalls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batch_calls\"")
			}
		case "has_more":
			if err := func() error {
				s.HasMore.Reset()
				if err := s.HasMore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_more\"")
			}
		case "next_doc":
			if err := func() error {
				s.NextDoc.Reset()
				if err := s.NextDoc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next_doc\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceBatchCallsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceBatchCallsResponse) {
					name = jsonFieldsNameOfWorkspaceBatchCallsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceBatchCallsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceBatchCallsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceCreateApiKeyResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceCreateApiKeyResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key_id")
		e.Str(s.KeyID)
	}
	{
		e.FieldStart("xi-api-key")
		e.Str(s.XiMinusAPIMinusKey)
	}
}

var jsonFieldsNameOfWorkspaceCreateApiKeyResponseModel = [2]string{
	0: "key_id",
	1: "xi-api-key",
}

// Decode decodes WorkspaceCreateApiKeyResponseModel from json.
func (s *WorkspaceCreateApiKeyResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceCreateApiKeyResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.KeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_id\"")
			}
		case "xi-api-key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.XiMinusAPIMinusKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xi-api-key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceCreateApiKeyResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceCreateApiKeyResponseModel) {
					name = jsonFieldsNameOfWorkspaceCreateApiKeyResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceCreateApiKeyResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceCreateApiKeyResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceCreateWebhookResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceCreateWebhookResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("webhook_id")
		e.Str(s.WebhookID)
	}
	{
		if s.WebhookSecret.Set {
			e.FieldStart("webhook_secret")
			s.WebhookSecret.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceCreateWebhookResponseModel = [2]string{
	0: "webhook_id",
	1: "webhook_secret",
}

// Decode decodes WorkspaceCreateWebhookResponseModel from json.
func (s *WorkspaceCreateWebhookResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceCreateWebhookResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "webhook_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WebhookID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_id\"")
			}
		case "webhook_secret":
			if err := func() error {
				s.WebhookSecret.Reset()
				if err := s.WebhookSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceCreateWebhookResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceCreateWebhookResponseModel) {
					name = jsonFieldsNameOfWorkspaceCreateWebhookResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceCreateWebhookResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceCreateWebhookResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceGroupByNameResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceGroupByNameResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("members_emails")
		e.ArrStart()
		for _, elem := range s.MembersEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfWorkspaceGroupByNameResponseModel = [3]string{
	0: "id",
	1: "members_emails",
	2: "name",
}

// Decode decodes WorkspaceGroupByNameResponseModel from json.
func (s *WorkspaceGroupByNameResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceGroupByNameResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "members_emails":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.MembersEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.MembersEmails = append(s.MembersEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members_emails\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceGroupByNameResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceGroupByNameResponseModel) {
					name = jsonFieldsNameOfWorkspaceGroupByNameResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceGroupByNameResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceGroupByNameResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkspaceResourceType as json.
func (s WorkspaceResourceType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes WorkspaceResourceType from json.
func (s *WorkspaceResourceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceResourceType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch WorkspaceResourceType(v) {
	case WorkspaceResourceTypeVoice:
		*s = WorkspaceResourceTypeVoice
	case WorkspaceResourceTypeVoiceCollection:
		*s = WorkspaceResourceTypeVoiceCollection
	case WorkspaceResourceTypePronunciationDictionary:
		*s = WorkspaceResourceTypePronunciationDictionary
	case WorkspaceResourceTypeDubbing:
		*s = WorkspaceResourceTypeDubbing
	case WorkspaceResourceTypeProject:
		*s = WorkspaceResourceTypeProject
	case WorkspaceResourceTypeConvaiAgents:
		*s = WorkspaceResourceTypeConvaiAgents
	case WorkspaceResourceTypeConvaiKnowledgeBaseDocuments:
		*s = WorkspaceResourceTypeConvaiKnowledgeBaseDocuments
	case WorkspaceResourceTypeConvaiTools:
		*s = WorkspaceResourceTypeConvaiTools
	case WorkspaceResourceTypeConvaiSettings:
		*s = WorkspaceResourceTypeConvaiSettings
	case WorkspaceResourceTypeConvaiSecrets:
		*s = WorkspaceResourceTypeConvaiSecrets
	case WorkspaceResourceTypeWorkspaceAuthConnections:
		*s = WorkspaceResourceTypeWorkspaceAuthConnections
	case WorkspaceResourceTypeConvaiPhoneNumbers:
		*s = WorkspaceResourceTypeConvaiPhoneNumbers
	case WorkspaceResourceTypeConvaiMcpServers:
		*s = WorkspaceResourceTypeConvaiMcpServers
	case WorkspaceResourceTypeConvaiAPIIntegrationConnections:
		*s = WorkspaceResourceTypeConvaiAPIIntegrationConnections
	case WorkspaceResourceTypeConvaiAPIIntegrationTriggerConnections:
		*s = WorkspaceResourceTypeConvaiAPIIntegrationTriggerConnections
	case WorkspaceResourceTypeConvaiBatchCalls:
		*s = WorkspaceResourceTypeConvaiBatchCalls
	case WorkspaceResourceTypeConvaiAgentResponseTests:
		*s = WorkspaceResourceTypeConvaiAgentResponseTests
	case WorkspaceResourceTypeConvaiTestSuiteInvocations:
		*s = WorkspaceResourceTypeConvaiTestSuiteInvocations
	case WorkspaceResourceTypeConvaiCrawlJobs:
		*s = WorkspaceResourceTypeConvaiCrawlJobs
	case WorkspaceResourceTypeConvaiCrawlTasks:
		*s = WorkspaceResourceTypeConvaiCrawlTasks
	case WorkspaceResourceTypeConvaiWhatsappAccounts:
		*s = WorkspaceResourceTypeConvaiWhatsappAccounts
	case WorkspaceResourceTypeConvaiAgentVersions:
		*s = WorkspaceResourceTypeConvaiAgentVersions
	case WorkspaceResourceTypeConvaiAgentBranches:
		*s = WorkspaceResourceTypeConvaiAgentBranches
	case WorkspaceResourceTypeConvaiAgentVersionsDeployments:
		*s = WorkspaceResourceTypeConvaiAgentVersionsDeployments
	case WorkspaceResourceTypeDashboard:
		*s = WorkspaceResourceTypeDashboard
	case WorkspaceResourceTypeDashboardConfiguration:
		*s = WorkspaceResourceTypeDashboardConfiguration
	case WorkspaceResourceTypeConvaiAgentDrafts:
		*s = WorkspaceResourceTypeConvaiAgentDrafts
	case WorkspaceResourceTypeResourceLocators:
		*s = WorkspaceResourceTypeResourceLocators
	default:
		*s = WorkspaceResourceType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s WorkspaceResourceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceResourceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceServiceAccountListResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceServiceAccountListResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("service-accounts")
		e.ArrStart()
		for _, elem := range s.ServiceMinusAccounts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfWorkspaceServiceAccountListResponseModel = [1]string{
	0: "service-accounts",
}

// Decode decodes WorkspaceServiceAccountListResponseModel from json.
func (s *WorkspaceServiceAccountListResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceServiceAccountListResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service-accounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ServiceMinusAccounts = make([]WorkspaceServiceAccountResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkspaceServiceAccountResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ServiceMinusAccounts = append(s.ServiceMinusAccounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service-accounts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceServiceAccountListResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceServiceAccountListResponseModel) {
					name = jsonFieldsNameOfWorkspaceServiceAccountListResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceServiceAccountListResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceServiceAccountListResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceServiceAccountResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceServiceAccountResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("api-keys")
		e.ArrStart()
		for _, elem := range s.APIMinusKeys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.CreatedAtUnix.Set {
			e.FieldStart("created_at_unix")
			s.CreatedAtUnix.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("service_account_user_id")
		e.Str(s.ServiceAccountUserID)
	}
}

var jsonFieldsNameOfWorkspaceServiceAccountResponseModel = [4]string{
	0: "api-keys",
	1: "created_at_unix",
	2: "name",
	3: "service_account_user_id",
}

// Decode decodes WorkspaceServiceAccountResponseModel from json.
func (s *WorkspaceServiceAccountResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceServiceAccountResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "api-keys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.APIMinusKeys = make([]WorkspaceApiKeyResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkspaceApiKeyResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.APIMinusKeys = append(s.APIMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api-keys\"")
			}
		case "created_at_unix":
			if err := func() error {
				s.CreatedAtUnix.Reset()
				if err := s.CreatedAtUnix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "service_account_user_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ServiceAccountUserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_account_user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceServiceAccountResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceServiceAccountResponseModel) {
					name = jsonFieldsNameOfWorkspaceServiceAccountResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceServiceAccountResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceServiceAccountResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceWebhookListResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceWebhookListResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("webhooks")
		e.ArrStart()
		for _, elem := range s.Webhooks {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfWorkspaceWebhookListResponseModel = [1]string{
	0: "webhooks",
}

// Decode decodes WorkspaceWebhookListResponseModel from json.
func (s *WorkspaceWebhookListResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceWebhookListResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "webhooks":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Webhooks = make([]WorkspaceWebhookResponseModel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WorkspaceWebhookResponseModel
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Webhooks = append(s.Webhooks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhooks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceWebhookListResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceWebhookListResponseModel) {
					name = jsonFieldsNameOfWorkspaceWebhookListResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceWebhookListResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceWebhookListResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceWebhookResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceWebhookResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("auth_type")
		s.AuthType.Encode(e)
	}
	{
		e.FieldStart("created_at_unix")
		e.Int(s.CreatedAtUnix)
	}
	{
		e.FieldStart("is_auto_disabled")
		e.Bool(s.IsAutoDisabled)
	}
	{
		e.FieldStart("is_disabled")
		e.Bool(s.IsDisabled)
	}
	{
		if s.MostRecentFailureErrorCode.Set {
			e.FieldStart("most_recent_failure_error_code")
			s.MostRecentFailureErrorCode.Encode(e)
		}
	}
	{
		if s.MostRecentFailureTimestamp.Set {
			e.FieldStart("most_recent_failure_timestamp")
			s.MostRecentFailureTimestamp.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		e.FieldStart("webhook_id")
		e.Str(s.WebhookID)
	}
	{
		e.FieldStart("webhook_url")
		e.Str(s.WebhookURL)
	}
}

var jsonFieldsNameOfWorkspaceWebhookResponseModel = [10]string{
	0: "auth_type",
	1: "created_at_unix",
	2: "is_auto_disabled",
	3: "is_disabled",
	4: "most_recent_failure_error_code",
	5: "most_recent_failure_timestamp",
	6: "name",
	7: "usage",
	8: "webhook_id",
	9: "webhook_url",
}

// Decode decodes WorkspaceWebhookResponseModel from json.
func (s *WorkspaceWebhookResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceWebhookResponseModel to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "auth_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_type\"")
			}
		case "created_at_unix":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.CreatedAtUnix = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at_unix\"")
			}
		case "is_auto_disabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsAutoDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_auto_disabled\"")
			}
		case "is_disabled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_disabled\"")
			}
		case "most_recent_failure_error_code":
			if err := func() error {
				s.MostRecentFailureErrorCode.Reset()
				if err := s.MostRecentFailureErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_failure_error_code\"")
			}
		case "most_recent_failure_timestamp":
			if err := func() error {
				s.MostRecentFailureTimestamp.Reset()
				if err := s.MostRecentFailureTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"most_recent_failure_timestamp\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "webhook_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.WebhookID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_id\"")
			}
		case "webhook_url":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WebhookURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceWebhookResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01001111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceWebhookResponseModel) {
					name = jsonFieldsNameOfWorkspaceWebhookResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceWebhookResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceWebhookResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceWebhookUsageResponseModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceWebhookUsageResponseModel) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("usage_type")
		s.UsageType.Encode(e)
	}
}

var jsonFieldsNameOfWorkspaceWebhookUsageResponseModel = [1]string{
	0: "usage_type",
}

// Decode decodes WorkspaceWebhookUsageResponseModel from json.
func (s *WorkspaceWebhookUsageResponseModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceWebhookUsageResponseModel to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "usage_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.UsageType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceWebhookUsageResponseModel")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceWebhookUsageResponseModel) {
					name = jsonFieldsNameOfWorkspaceWebhookUsageResponseModel[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceWebhookUsageResponseModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceWebhookUsageResponseModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ZendeskConversationInitiationTrigger) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ZendeskConversationInitiationTrigger) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ticket_id")
		e.Int(s.TicketID)
	}
	{
		if s.TriggerType.Set {
			e.FieldStart("trigger_type")
			s.TriggerType.Encode(e)
		}
	}
}

var jsonFieldsNameOfZendeskConversationInitiationTrigger = [2]string{
	0: "ticket_id",
	1: "trigger_type",
}

// Decode decodes ZendeskConversationInitiationTrigger from json.
func (s *ZendeskConversationInitiationTrigger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ZendeskConversationInitiationTrigger to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ticket_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.TicketID = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ticket_id\"")
			}
		case "trigger_type":
			if err := func() error {
				s.TriggerType.Reset()
				if err := s.TriggerType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trigger_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ZendeskConversationInitiationTrigger")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfZendeskConversationInitiationTrigger) {
					name = jsonFieldsNameOfZendeskConversationInitiationTrigger[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ZendeskConversationInitiationTrigger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ZendeskConversationInitiationTrigger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ZendeskConversationInitiationTriggerTriggerType as json.
func (s ZendeskConversationInitiationTriggerTriggerType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ZendeskConversationInitiationTriggerTriggerType from json.
func (s *ZendeskConversationInitiationTriggerTriggerType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ZendeskConversationInitiationTriggerTriggerType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ZendeskConversationInitiationTriggerTriggerType(v) {
	case ZendeskConversationInitiationTriggerTriggerTypeZendesk:
		*s = ZendeskConversationInitiationTriggerTriggerTypeZendesk
	default:
		*s = ZendeskConversationInitiationTriggerTriggerType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ZendeskConversationInitiationTriggerTriggerType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ZendeskConversationInitiationTriggerTriggerType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
