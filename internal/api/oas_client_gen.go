// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddDocumentationToKnowledgeBase invokes add_documentation_to_knowledge_base operation.
	//
	// Uploads a file or reference a webpage to use as part of the shared knowledge base.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// POST /v1/convai/knowledge-base
	AddDocumentationToKnowledgeBase(ctx context.Context, request OptBodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostMultipart, params AddDocumentationToKnowledgeBaseParams) (AddDocumentationToKnowledgeBaseRes, error)
	// AddFromFile invokes add_from_file operation.
	//
	// Creates a new pronunciation dictionary from a lexicon .PLS file.
	//
	// POST /v1/pronunciation-dictionaries/add-from-file
	AddFromFile(ctx context.Context, request *BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostMultipart, params AddFromFileParams) (AddFromFileRes, error)
	// AddLanguage invokes add_language operation.
	//
	// Adds the given ElevenLab Turbo V2/V2.5 language code to the resource. Does not automatically
	// generate transcripts/translations/audio.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/language
	AddLanguage(ctx context.Context, request *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost, params AddLanguageParams) (AddLanguageRes, error)
	// AddMember invokes add_member operation.
	//
	// Adds a member of your workspace to the specified group. This endpoint may only be called by
	// workspace administrators.
	//
	// POST /v1/workspace/groups/{group_id}/members
	AddMember(ctx context.Context, request *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost, params AddMemberParams) (AddMemberRes, error)
	// AddProject invokes add_project operation.
	//
	// Creates a new Studio project, it can be either initialized as blank, from a document or from a URL.
	//
	// POST /v1/studio/projects
	AddProject(ctx context.Context, request *BodyCreateStudioProjectV1StudioProjectsPostMultipart, params AddProjectParams) (AddProjectRes, error)
	// AddPvcVoiceSamples invokes add_pvc_voice_samples operation.
	//
	// Add audio samples to a PVC voice.
	//
	// POST /v1/voices/pvc/{voice_id}/samples
	AddPvcVoiceSamples(ctx context.Context, request *BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIDSamplesPostMultipart, params AddPvcVoiceSamplesParams) (AddPvcVoiceSamplesRes, error)
	// AddSharingVoice invokes add_sharing_voice operation.
	//
	// Add a shared voice to your collection of voices.
	//
	// POST /v1/voices/add/{public_user_id}/{voice_id}
	AddSharingVoice(ctx context.Context, request *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost, params AddSharingVoiceParams) (AddSharingVoiceRes, error)
	// AddVoice invokes add_voice operation.
	//
	// Add a new voice to your collection of voices in VoiceLab.
	//
	// POST /v1/voices/add
	AddVoice(ctx context.Context, request *BodyAddVoiceV1VoicesAddPostMultipart, params AddVoiceParams) (AddVoiceRes, error)
	// AudioIsolation invokes audio_isolation operation.
	//
	// Removes background noise from audio.
	//
	// POST /v1/audio-isolation
	AudioIsolation(ctx context.Context, request *BodyAudioIsolationV1AudioIsolationPostMultipart, params AudioIsolationParams) (AudioIsolationRes, error)
	// AudioIsolationStream invokes audio_isolation_stream operation.
	//
	// Removes background noise from audio and streams the result.
	//
	// POST /v1/audio-isolation/stream
	AudioIsolationStream(ctx context.Context, request *BodyAudioIsolationStreamV1AudioIsolationStreamPostMultipart, params AudioIsolationStreamParams) (AudioIsolationStreamRes, error)
	// AudioNativeProjectUpdateContentEndpoint invokes audio_native_project_update_content_endpoint operation.
	//
	// Updates content for the specific AudioNative Project.
	//
	// POST /v1/audio-native/{project_id}/content
	AudioNativeProjectUpdateContentEndpoint(ctx context.Context, request OptBodyUpdateAudioNativeProjectContentV1AudioNativeProjectIDContentPostMultipart, params AudioNativeProjectUpdateContentEndpointParams) (AudioNativeProjectUpdateContentEndpointRes, error)
	// CancelBatchCall invokes cancel_batch_call operation.
	//
	// Cancel a running batch call and set all recipients to cancelled status.
	//
	// POST /v1/convai/batch-calling/{batch_id}/cancel
	CancelBatchCall(ctx context.Context, params CancelBatchCallParams) (CancelBatchCallRes, error)
	// ComposeDetailed invokes compose_detailed operation.
	//
	// Compose a song from a prompt or a composition plan.
	//
	// POST /v1/music/detailed
	ComposeDetailed(ctx context.Context, request OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost, params ComposeDetailedParams) (ComposeDetailedRes, error)
	// ComposePlan invokes compose_plan operation.
	//
	// Generate a composition plan from a prompt.
	//
	// POST /v1/music/plan
	ComposePlan(ctx context.Context, request *BodyGenerateCompositionPlanV1MusicPlanPost, params ComposePlanParams) (ComposePlanRes, error)
	// ConvertChapterEndpoint invokes convert_chapter_endpoint operation.
	//
	// Starts conversion of a specific chapter.
	//
	// POST /v1/studio/projects/{project_id}/chapters/{chapter_id}/convert
	ConvertChapterEndpoint(ctx context.Context, params ConvertChapterEndpointParams) (ConvertChapterEndpointRes, error)
	// ConvertProjectEndpoint invokes convert_project_endpoint operation.
	//
	// Starts conversion of a Studio project and all of its chapters.
	//
	// POST /v1/studio/projects/{project_id}/convert
	ConvertProjectEndpoint(ctx context.Context, params ConvertProjectEndpointParams) (ConvertProjectEndpointRes, error)
	// CreateAgentResponseTestRoute invokes create_agent_response_test_route operation.
	//
	// Creates a new agent response test.
	//
	// POST /v1/convai/agent-testing/create
	CreateAgentResponseTestRoute(ctx context.Context, request *CreateUnitTestRequest, params CreateAgentResponseTestRouteParams) (CreateAgentResponseTestRouteRes, error)
	// CreateAudioNativeProject invokes create_audio_native_project operation.
	//
	// Creates Audio Native enabled project, optionally starts conversion and returns project ID and
	// embeddable HTML snippet.
	//
	// POST /v1/audio-native
	CreateAudioNativeProject(ctx context.Context, request *BodyCreatesAudioNativeEnabledProjectV1AudioNativePostMultipart, params CreateAudioNativeProjectParams) (CreateAudioNativeProjectRes, error)
	// CreateBatchCall invokes create_batch_call operation.
	//
	// Submit a batch call request to schedule calls for multiple recipients.
	//
	// POST /v1/convai/batch-calling/submit
	CreateBatchCall(ctx context.Context, request *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost, params CreateBatchCallParams) (CreateBatchCallRes, error)
	// CreateClip invokes create_clip operation.
	//
	// Creates a new segment in dubbing resource with a start and end time for the speaker in every
	// available language. Does not automatically generate transcripts/translations/audio.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/segment
	CreateClip(ctx context.Context, request *SegmentCreatePayload, params CreateClipParams) (CreateClipRes, error)
	// CreateDubbing invokes create_dubbing operation.
	//
	// Dubs a provided audio or video file into given language.
	//
	// POST /v1/dubbing
	CreateDubbing(ctx context.Context, request OptBodyDubAVideoOrAnAudioFileV1DubbingPostMultipart, params CreateDubbingParams) (CreateDubbingRes, error)
	// CreateFileDocumentRoute invokes create_file_document_route operation.
	//
	// Create a knowledge base document generated form the uploaded file.
	//
	// POST /v1/convai/knowledge-base/file
	CreateFileDocumentRoute(ctx context.Context, request *BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostMultipart, params CreateFileDocumentRouteParams) (CreateFileDocumentRouteRes, error)
	// CreatePvcVoice invokes create_pvc_voice operation.
	//
	// Creates a new PVC voice with metadata but no samples.
	//
	// POST /v1/voices/pvc
	CreatePvcVoice(ctx context.Context, request *BodyCreatePVCVoiceV1VoicesPvcPost, params CreatePvcVoiceParams) (CreatePvcVoiceRes, error)
	// CreateSecretRoute invokes create_secret_route operation.
	//
	// Create a new secret for the workspace.
	//
	// POST /v1/convai/secrets
	CreateSecretRoute(ctx context.Context, request *PostWorkspaceSecretRequest, params CreateSecretRouteParams) (CreateSecretRouteRes, error)
	// CreateServiceAccountAPIKey invokes create_service_account_api_key operation.
	//
	// Create a new API key for a service account.
	//
	// POST /v1/service-accounts/{service_account_user_id}/api-keys
	CreateServiceAccountAPIKey(ctx context.Context, request *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost, params CreateServiceAccountAPIKeyParams) (CreateServiceAccountAPIKeyRes, error)
	// CreateSpeaker invokes create_speaker operation.
	//
	// Create A New Speaker.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/speaker
	CreateSpeaker(ctx context.Context, request OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost, params CreateSpeakerParams) (CreateSpeakerRes, error)
	// CreateTextDocumentRoute invokes create_text_document_route operation.
	//
	// Create a knowledge base document containing the provided text.
	//
	// POST /v1/convai/knowledge-base/text
	CreateTextDocumentRoute(ctx context.Context, request *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost, params CreateTextDocumentRouteParams) (CreateTextDocumentRouteRes, error)
	// CreateURLDocumentRoute invokes create_url_document_route operation.
	//
	// Create a knowledge base document generated by scraping the given webpage.
	//
	// POST /v1/convai/knowledge-base/url
	CreateURLDocumentRoute(ctx context.Context, request *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost, params CreateURLDocumentRouteParams) (CreateURLDocumentRouteRes, error)
	// CreateVoice invokes create_voice operation.
	//
	// Create a voice from previously generated voice preview. This endpoint should be called after you
	// fetched a generated_voice_id using POST /v1/text-to-voice/design or POST
	// /v1/text-to-voice/:voice_id/remix.
	//
	// POST /v1/text-to-voice
	CreateVoice(ctx context.Context, request *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost, params CreateVoiceParams) (CreateVoiceRes, error)
	// CreateVoiceOld invokes create_voice_old operation.
	//
	// Create a previously generated voice. This endpoint should be called after you fetched a
	// generated_voice_id using /v1/voice-generation/generate-voice.
	//
	// POST /v1/voice-generation/create-voice
	CreateVoiceOld(ctx context.Context, request *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost, params CreateVoiceOldParams) (CreateVoiceOldRes, error)
	// CreateWorkspaceWebhookRoute invokes create_workspace_webhook_route operation.
	//
	// Create a new webhook for the workspace with the specified authentication type.
	//
	// POST /v1/workspace/webhooks
	CreateWorkspaceWebhookRoute(ctx context.Context, request *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost, params CreateWorkspaceWebhookRouteParams) (CreateWorkspaceWebhookRouteRes, error)
	// DeleteAgentRoute invokes delete_agent_route operation.
	//
	// Delete an agent.
	//
	// DELETE /v1/convai/agents/{agent_id}
	DeleteAgentRoute(ctx context.Context, params DeleteAgentRouteParams) (DeleteAgentRouteRes, error)
	// DeleteChapterEndpoint invokes delete_chapter_endpoint operation.
	//
	// Deletes a chapter.
	//
	// DELETE /v1/studio/projects/{project_id}/chapters/{chapter_id}
	DeleteChapterEndpoint(ctx context.Context, params DeleteChapterEndpointParams) (DeleteChapterEndpointRes, error)
	// DeleteChatResponseTestRoute invokes delete_chat_response_test_route operation.
	//
	// Deletes an agent response test by ID.
	//
	// DELETE /v1/convai/agent-testing/{test_id}
	DeleteChatResponseTestRoute(ctx context.Context, params DeleteChatResponseTestRouteParams) (DeleteChatResponseTestRouteRes, error)
	// DeleteConversationRoute invokes delete_conversation_route operation.
	//
	// Delete a particular conversation.
	//
	// DELETE /v1/convai/conversations/{conversation_id}
	DeleteConversationRoute(ctx context.Context, params DeleteConversationRouteParams) (DeleteConversationRouteRes, error)
	// DeleteDubbing invokes delete_dubbing operation.
	//
	// Deletes a dubbing project.
	//
	// DELETE /v1/dubbing/{dubbing_id}
	DeleteDubbing(ctx context.Context, params DeleteDubbingParams) (DeleteDubbingRes, error)
	// DeleteInvite invokes delete_invite operation.
	//
	// Invalidates an existing email invitation. The invitation will still show up in the inbox it has
	// been delivered to, but activating it to join the workspace won't work. This endpoint may only be
	// called by workspace administrators.
	//
	// DELETE /v1/workspace/invites
	DeleteInvite(ctx context.Context, request *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete, params DeleteInviteParams) (DeleteInviteRes, error)
	// DeleteKnowledgeBaseDocument invokes delete_knowledge_base_document operation.
	//
	// Delete a document from the knowledge base.
	//
	// DELETE /v1/convai/knowledge-base/{documentation_id}
	DeleteKnowledgeBaseDocument(ctx context.Context, params DeleteKnowledgeBaseDocumentParams) (DeleteKnowledgeBaseDocumentRes, error)
	// DeleteMcpServerRoute invokes delete_mcp_server_route operation.
	//
	// Delete a specific MCP server configuration from the workspace.
	//
	// DELETE /v1/convai/mcp-servers/{mcp_server_id}
	DeleteMcpServerRoute(ctx context.Context, params DeleteMcpServerRouteParams) (DeleteMcpServerRouteRes, error)
	// DeletePhoneNumberRoute invokes delete_phone_number_route operation.
	//
	// Delete Phone Number by ID.
	//
	// DELETE /v1/convai/phone-numbers/{phone_number_id}
	DeletePhoneNumberRoute(ctx context.Context, params DeletePhoneNumberRouteParams) (DeletePhoneNumberRouteRes, error)
	// DeleteProject invokes delete_project operation.
	//
	// Deletes a Studio project.
	//
	// DELETE /v1/studio/projects/{project_id}
	DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error)
	// DeletePvcVoiceSample invokes delete_pvc_voice_sample operation.
	//
	// Delete a sample from a PVC voice.
	//
	// DELETE /v1/voices/pvc/{voice_id}/samples/{sample_id}
	DeletePvcVoiceSample(ctx context.Context, params DeletePvcVoiceSampleParams) (DeletePvcVoiceSampleRes, error)
	// DeleteRagIndex invokes delete_rag_index operation.
	//
	// Delete RAG index for the knowledgebase document.
	//
	// DELETE /v1/convai/knowledge-base/{documentation_id}/rag-index/{rag_index_id}
	DeleteRagIndex(ctx context.Context, params DeleteRagIndexParams) (DeleteRagIndexRes, error)
	// DeleteSample invokes delete_sample operation.
	//
	// Removes a sample by its ID.
	//
	// DELETE /v1/voices/{voice_id}/samples/{sample_id}
	DeleteSample(ctx context.Context, params DeleteSampleParams) (DeleteSampleRes, error)
	// DeleteSecretRoute invokes delete_secret_route operation.
	//
	// Delete a workspace secret if it's not in use.
	//
	// DELETE /v1/convai/secrets/{secret_id}
	DeleteSecretRoute(ctx context.Context, params DeleteSecretRouteParams) (DeleteSecretRouteRes, error)
	// DeleteSegment invokes delete_segment operation.
	//
	// Deletes a single segment from the dubbing.
	//
	// DELETE /v1/dubbing/resource/{dubbing_id}/segment/{segment_id}
	DeleteSegment(ctx context.Context, params DeleteSegmentParams) (DeleteSegmentRes, error)
	// DeleteServiceAccountAPIKey invokes delete_service_account_api_key operation.
	//
	// Delete an existing API key for a service account.
	//
	// DELETE /v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}
	DeleteServiceAccountAPIKey(ctx context.Context, params DeleteServiceAccountAPIKeyParams) (DeleteServiceAccountAPIKeyRes, error)
	// DeleteSpeechHistoryItem invokes delete_speech_history_item operation.
	//
	// Delete a history item by its ID.
	//
	// DELETE /v1/history/{history_item_id}
	DeleteSpeechHistoryItem(ctx context.Context, params DeleteSpeechHistoryItemParams) (DeleteSpeechHistoryItemRes, error)
	// DeleteToolRoute invokes delete_tool_route operation.
	//
	// Delete tool from the workspace.
	//
	// DELETE /v1/convai/tools/{tool_id}
	DeleteToolRoute(ctx context.Context, params DeleteToolRouteParams) (DeleteToolRouteRes, error)
	// DeleteTranscriptByID invokes delete_transcript_by_id operation.
	//
	// Delete a previously generated transcript by its ID.
	//
	// DELETE /v1/speech-to-text/transcripts/{transcription_id}
	DeleteTranscriptByID(ctx context.Context, params DeleteTranscriptByIDParams) (DeleteTranscriptByIDRes, error)
	// DeleteVoice invokes delete_voice operation.
	//
	// Deletes a voice by its ID.
	//
	// DELETE /v1/voices/{voice_id}
	DeleteVoice(ctx context.Context, params DeleteVoiceParams) (DeleteVoiceRes, error)
	// DeleteWhatsappAccount invokes delete_whatsapp_account operation.
	//
	// Delete a WhatsApp account.
	//
	// DELETE /v1/convai/whatsapp-accounts/{phone_number_id}
	DeleteWhatsappAccount(ctx context.Context, params DeleteWhatsappAccountParams) (DeleteWhatsappAccountRes, error)
	// DeleteWorkspaceWebhookRoute invokes delete_workspace_webhook_route operation.
	//
	// Delete the specified workspace webhook.
	//
	// DELETE /v1/workspace/webhooks/{webhook_id}
	DeleteWorkspaceWebhookRoute(ctx context.Context, params DeleteWorkspaceWebhookRouteParams) (DeleteWorkspaceWebhookRouteRes, error)
	// DownloadSpeechHistoryItems invokes download_speech_history_items operation.
	//
	// Download one or more history items. If one history item ID is provided, we will return a single
	// audio file. If more than one history item IDs are provided, we will provide the history items
	// packed into a .zip file.
	//
	// POST /v1/history/download
	DownloadSpeechHistoryItems(ctx context.Context, request *BodyDownloadHistoryItemsV1HistoryDownloadPost, params DownloadSpeechHistoryItemsParams) (DownloadSpeechHistoryItemsRes, error)
	// Dub invokes dub operation.
	//
	// Regenerate the dubs for either the entire resource or the specified segments/languages. Will
	// automatically transcribe and translate any missing transcriptions and translations.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/dub
	Dub(ctx context.Context, request *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost, params DubParams) (DubRes, error)
	// DuplicateAgentRoute invokes duplicate_agent_route operation.
	//
	// Create a new agent by duplicating an existing one.
	//
	// POST /v1/convai/agents/{agent_id}/duplicate
	DuplicateAgentRoute(ctx context.Context, request OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost, params DuplicateAgentRouteParams) (DuplicateAgentRouteRes, error)
	// EditProject invokes edit_project operation.
	//
	// Updates the specified Studio project by setting the values of the parameters passed.
	//
	// POST /v1/studio/projects/{project_id}
	EditProject(ctx context.Context, request *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost, params EditProjectParams) (EditProjectRes, error)
	// EditProjectContent invokes edit_project_content operation.
	//
	// Updates Studio project content.
	//
	// POST /v1/studio/projects/{project_id}/content
	EditProjectContent(ctx context.Context, request OptBodyUpdateStudioProjectContentV1StudioProjectsProjectIDContentPostMultipart, params EditProjectContentParams) (EditProjectContentRes, error)
	// EditPvcVoice invokes edit_pvc_voice operation.
	//
	// Edit PVC voice metadata.
	//
	// POST /v1/voices/pvc/{voice_id}
	EditPvcVoice(ctx context.Context, request OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost, params EditPvcVoiceParams) (EditPvcVoiceRes, error)
	// EditPvcVoiceSample invokes edit_pvc_voice_sample operation.
	//
	// Update a PVC voice sample - apply noise removal, select speaker, change trim times or file name.
	//
	// POST /v1/voices/pvc/{voice_id}/samples/{sample_id}
	EditPvcVoiceSample(ctx context.Context, request OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost, params EditPvcVoiceSampleParams) (EditPvcVoiceSampleRes, error)
	// EditServiceAccountAPIKey invokes edit_service_account_api_key operation.
	//
	// Update an existing API key for a service account.
	//
	// PATCH /v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}
	EditServiceAccountAPIKey(ctx context.Context, request *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch, params EditServiceAccountAPIKeyParams) (EditServiceAccountAPIKeyRes, error)
	// EditVoice invokes edit_voice operation.
	//
	// Edit a voice created by you.
	//
	// POST /v1/voices/{voice_id}/edit
	EditVoice(ctx context.Context, request *BodyEditVoiceV1VoicesVoiceIDEditPostMultipart, params EditVoiceParams) (EditVoiceRes, error)
	// EditVoiceSettings invokes edit_voice_settings operation.
	//
	// Edit your settings for a specific voice. "similarity_boost" corresponds to "Clarity + Similarity
	// Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
	//
	// POST /v1/voices/{voice_id}/settings/edit
	EditVoiceSettings(ctx context.Context, request *VoiceSettingsResponseModel, params EditVoiceSettingsParams) (EditVoiceSettingsRes, error)
	// EditWorkspaceWebhookRoute invokes edit_workspace_webhook_route operation.
	//
	// Update the specified workspace webhook.
	//
	// PATCH /v1/workspace/webhooks/{webhook_id}
	EditWorkspaceWebhookRoute(ctx context.Context, request *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch, params EditWorkspaceWebhookRouteParams) (EditWorkspaceWebhookRouteRes, error)
	// ForcedAlignment invokes forced_alignment operation.
	//
	// Force align an audio file to text. Use this endpoint to get the timing information for each
	// character and word in an audio file based on a provided text transcript.
	//
	// POST /v1/forced-alignment
	ForcedAlignment(ctx context.Context, request *BodyCreateForcedAlignmentV1ForcedAlignmentPostMultipart, params ForcedAlignmentParams) (ForcedAlignmentRes, error)
	// Generate invokes generate operation.
	//
	// Compose a song from a prompt or a composition plan.
	//
	// POST /v1/music
	Generate(ctx context.Context, request OptBodyComposeMusicV1MusicPost, params GenerateParams) (GenerateRes, error)
	// GenerateRandomVoice invokes generate_random_voice operation.
	//
	// Generate a random voice based on parameters. This method returns a generated_voice_id in the
	// response header, and a sample of the voice in the body. If you like the generated voice call
	// /v1/voice-generation/create-voice with the generated_voice_id to create the voice.
	//
	// POST /v1/voice-generation/generate-voice
	GenerateRandomVoice(ctx context.Context, request *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost, params GenerateRandomVoiceParams) (GenerateRandomVoiceRes, error)
	// GetAgentKnowledgeBaseSize invokes get_agent_knowledge_base_size operation.
	//
	// Returns the number of pages in the agent's knowledge base.
	//
	// GET /v1/convai/agent/{agent_id}/knowledge-base/size
	GetAgentKnowledgeBaseSize(ctx context.Context, params GetAgentKnowledgeBaseSizeParams) (GetAgentKnowledgeBaseSizeRes, error)
	// GetAgentKnowledgeBaseSummariesRoute invokes get_agent_knowledge_base_summaries_route operation.
	//
	// Gets multiple knowledge base document summaries by their IDs.
	//
	// GET /v1/convai/knowledge-base/summaries
	GetAgentKnowledgeBaseSummariesRoute(ctx context.Context, params GetAgentKnowledgeBaseSummariesRouteParams) (GetAgentKnowledgeBaseSummariesRouteRes, error)
	// GetAgentLinkRoute invokes get_agent_link_route operation.
	//
	// Get the current link used to share the agent with others.
	//
	// GET /v1/convai/agents/{agent_id}/link
	GetAgentLinkRoute(ctx context.Context, params GetAgentLinkRouteParams) (GetAgentLinkRouteRes, error)
	// GetAgentLlmExpectedCostCalculation invokes get_agent_llm_expected_cost_calculation operation.
	//
	// Calculates expected number of LLM tokens needed for the specified agent.
	//
	// POST /v1/convai/agent/{agent_id}/llm-usage/calculate
	GetAgentLlmExpectedCostCalculation(ctx context.Context, request *LLMUsageCalculatorRequestModel, params GetAgentLlmExpectedCostCalculationParams) (GetAgentLlmExpectedCostCalculationRes, error)
	// GetAgentResponseTestRoute invokes get_agent_response_test_route operation.
	//
	// Gets an agent response test by ID.
	//
	// GET /v1/convai/agent-testing/{test_id}
	GetAgentResponseTestRoute(ctx context.Context, params GetAgentResponseTestRouteParams) (GetAgentResponseTestRouteRes, error)
	// GetAgentResponseTestsSummariesRoute invokes get_agent_response_tests_summaries_route operation.
	//
	// Gets multiple agent response tests by their IDs. Returns a dictionary mapping test IDs to test
	// summaries.
	//
	// POST /v1/convai/agent-testing/summaries
	GetAgentResponseTestsSummariesRoute(ctx context.Context, request *ListTestsByIdsRequestModel, params GetAgentResponseTestsSummariesRouteParams) (GetAgentResponseTestsSummariesRouteRes, error)
	// GetAgentsRoute invokes get_agents_route operation.
	//
	// Returns a list of your agents and their metadata.
	//
	// GET /v1/convai/agents
	GetAgentsRoute(ctx context.Context, params GetAgentsRouteParams) (GetAgentsRouteRes, error)
	// GetAudioFromSample invokes get_audio_from_sample operation.
	//
	// Returns the audio corresponding to a sample attached to a voice.
	//
	// GET /v1/voices/{voice_id}/samples/{sample_id}/audio
	GetAudioFromSample(ctx context.Context, params GetAudioFromSampleParams) (GetAudioFromSampleRes, error)
	// GetAudioFullFromSpeechHistoryItem invokes get_audio_full_from_speech_history_item operation.
	//
	// Returns the audio of an history item.
	//
	// GET /v1/history/{history_item_id}/audio
	GetAudioFullFromSpeechHistoryItem(ctx context.Context, params GetAudioFullFromSpeechHistoryItemParams) (GetAudioFullFromSpeechHistoryItemRes, error)
	// GetAudioNativeProjectSettingsEndpoint invokes get_audio_native_project_settings_endpoint operation.
	//
	// Get player settings for the specific project.
	//
	// GET /v1/audio-native/{project_id}/settings
	GetAudioNativeProjectSettingsEndpoint(ctx context.Context, params GetAudioNativeProjectSettingsEndpointParams) (GetAudioNativeProjectSettingsEndpointRes, error)
	// GetBatchCall invokes get_batch_call operation.
	//
	// Get detailed information about a batch call including all recipients.
	//
	// GET /v1/convai/batch-calling/{batch_id}
	GetBatchCall(ctx context.Context, params GetBatchCallParams) (GetBatchCallRes, error)
	// GetChapterSnapshotEndpoint invokes get_chapter_snapshot_endpoint operation.
	//
	// Returns the chapter snapshot.
	//
	// GET /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}
	GetChapterSnapshotEndpoint(ctx context.Context, params GetChapterSnapshotEndpointParams) (GetChapterSnapshotEndpointRes, error)
	// GetChapterSnapshots invokes get_chapter_snapshots operation.
	//
	// Gets information about all the snapshots of a chapter. Each snapshot can be downloaded as audio.
	// Whenever a chapter is converted a snapshot will automatically be created.
	//
	// GET /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots
	GetChapterSnapshots(ctx context.Context, params GetChapterSnapshotsParams) (GetChapterSnapshotsRes, error)
	// GetChapters invokes get_chapters operation.
	//
	// Returns a list of a Studio project's chapters.
	//
	// GET /v1/studio/projects/{project_id}/chapters
	GetChapters(ctx context.Context, params GetChaptersParams) (GetChaptersRes, error)
	// GetConversationAudioRoute invokes get_conversation_audio_route operation.
	//
	// Get the audio recording of a particular conversation.
	//
	// GET /v1/convai/conversations/{conversation_id}/audio
	GetConversationAudioRoute(ctx context.Context, params GetConversationAudioRouteParams) (GetConversationAudioRouteRes, error)
	// GetConversationHistoriesRoute invokes get_conversation_histories_route operation.
	//
	// Get all conversations of agents that user owns. With option to restrict to a specific agent.
	//
	// GET /v1/convai/conversations
	GetConversationHistoriesRoute(ctx context.Context, params GetConversationHistoriesRouteParams) (GetConversationHistoriesRouteRes, error)
	// GetConversationHistoryRoute invokes get_conversation_history_route operation.
	//
	// Get the details of a particular conversation.
	//
	// GET /v1/convai/conversations/{conversation_id}
	GetConversationHistoryRoute(ctx context.Context, params GetConversationHistoryRouteParams) (GetConversationHistoryRouteRes, error)
	// GetConversationSignedLink invokes get_conversation_signed_link operation.
	//
	// Get a signed url to start a conversation with an agent with an agent that requires authorization.
	//
	// GET /v1/convai/conversation/get-signed-url
	GetConversationSignedLink(ctx context.Context, params GetConversationSignedLinkParams) (GetConversationSignedLinkRes, error)
	// GetDashboardSettingsRoute invokes get_dashboard_settings_route operation.
	//
	// Retrieve Convai dashboard settings for the workspace.
	//
	// GET /v1/convai/settings/dashboard
	GetDashboardSettingsRoute(ctx context.Context, params GetDashboardSettingsRouteParams) (GetDashboardSettingsRouteRes, error)
	// GetDocumentationChunkFromKnowledgeBase invokes get_documentation_chunk_from_knowledge_base operation.
	//
	// Get details about a specific documentation part used by RAG.
	//
	// GET /v1/convai/knowledge-base/{documentation_id}/chunk/{chunk_id}
	GetDocumentationChunkFromKnowledgeBase(ctx context.Context, params GetDocumentationChunkFromKnowledgeBaseParams) (GetDocumentationChunkFromKnowledgeBaseRes, error)
	// GetDocumentationFromKnowledgeBase invokes get_documentation_from_knowledge_base operation.
	//
	// Get details about a specific documentation making up the agent's knowledge base.
	//
	// GET /v1/convai/knowledge-base/{documentation_id}
	GetDocumentationFromKnowledgeBase(ctx context.Context, params GetDocumentationFromKnowledgeBaseParams) (GetDocumentationFromKnowledgeBaseRes, error)
	// GetDubbedFile invokes get_dubbed_file operation.
	//
	// Returns dub as a streamed MP3 or MP4 file. If this dub has been edited using Dubbing Studio you
	// need to use the resource render endpoint as this endpoint only returns the original automatic dub
	// result.
	//
	// GET /v1/dubbing/{dubbing_id}/audio/{language_code}
	GetDubbedFile(ctx context.Context, params GetDubbedFileParams) (GetDubbedFileRes, error)
	// GetDubbedMetadata invokes get_dubbed_metadata operation.
	//
	// Returns metadata about a dubbing project, including whether it's still in progress or not.
	//
	// GET /v1/dubbing/{dubbing_id}
	GetDubbedMetadata(ctx context.Context, params GetDubbedMetadataParams) (GetDubbedMetadataRes, error)
	// GetDubbedTranscriptFile invokes get_dubbed_transcript_file operation.
	//
	// Returns transcript for the dub as an SRT or WEBVTT file.
	//
	// GET /v1/dubbing/{dubbing_id}/transcript/{language_code}
	GetDubbedTranscriptFile(ctx context.Context, params GetDubbedTranscriptFileParams) (GetDubbedTranscriptFileRes, error)
	// GetDubbingResource invokes get_dubbing_resource operation.
	//
	// Given a dubbing ID generated from the '/v1/dubbing' endpoint with studio enabled, returns the
	// dubbing resource.
	//
	// GET /v1/dubbing/resource/{dubbing_id}
	GetDubbingResource(ctx context.Context, params GetDubbingResourceParams) (GetDubbingResourceRes, error)
	// GetGenerateVoiceParameters invokes get_generate_voice_parameters operation.
	//
	// Get possible parameters for the /v1/voice-generation/generate-voice endpoint.
	//
	// GET /v1/voice-generation/generate-voice/parameters
	GetGenerateVoiceParameters(ctx context.Context) (*VoiceGenerationParameterResponseModel, error)
	// GetKnowledgeBaseContent invokes get_knowledge_base_content operation.
	//
	// Get the entire content of a document from the knowledge base.
	//
	// GET /v1/convai/knowledge-base/{documentation_id}/content
	GetKnowledgeBaseContent(ctx context.Context, params GetKnowledgeBaseContentParams) (GetKnowledgeBaseContentRes, error)
	// GetKnowledgeBaseDependentAgents invokes get_knowledge_base_dependent_agents operation.
	//
	// Get a list of agents depending on this knowledge base document.
	//
	// GET /v1/convai/knowledge-base/{documentation_id}/dependent-agents
	GetKnowledgeBaseDependentAgents(ctx context.Context, params GetKnowledgeBaseDependentAgentsParams) (GetKnowledgeBaseDependentAgentsRes, error)
	// GetKnowledgeBaseListRoute invokes get_knowledge_base_list_route operation.
	//
	// Get a list of available knowledge base documents.
	//
	// GET /v1/convai/knowledge-base
	GetKnowledgeBaseListRoute(ctx context.Context, params GetKnowledgeBaseListRouteParams) (GetKnowledgeBaseListRouteRes, error)
	// GetLibraryVoices invokes get_library_voices operation.
	//
	// Retrieves a list of shared voices.
	//
	// GET /v1/shared-voices
	GetLibraryVoices(ctx context.Context, params GetLibraryVoicesParams) (GetLibraryVoicesRes, error)
	// GetLiveCount invokes get_live_count operation.
	//
	// Get the live count of the ongoing conversations.
	//
	// GET /v1/convai/analytics/live-count
	GetLiveCount(ctx context.Context, params GetLiveCountParams) (GetLiveCountRes, error)
	// GetLivekitToken invokes get_livekit_token operation.
	//
	// Get a WebRTC session token for real-time communication.
	//
	// GET /v1/convai/conversation/token
	GetLivekitToken(ctx context.Context, params GetLivekitTokenParams) (GetLivekitTokenRes, error)
	// GetMcpToolConfigOverrideRoute invokes get_mcp_tool_config_override_route operation.
	//
	// Retrieve configuration overrides for a specific MCP tool.
	//
	// GET /v1/convai/mcp-servers/{mcp_server_id}/tool-configs/{tool_name}
	GetMcpToolConfigOverrideRoute(ctx context.Context, params GetMcpToolConfigOverrideRouteParams) (GetMcpToolConfigOverrideRouteRes, error)
	// GetModels invokes get_models operation.
	//
	// Gets a list of available models.
	//
	// GET /v1/models
	GetModels(ctx context.Context, params GetModelsParams) (GetModelsRes, error)
	// GetOrCreateRagIndexes invokes get_or_create_rag_indexes operation.
	//
	// Retrieves and/or creates RAG indexes for multiple knowledge base documents in a single request.
	//
	// POST /v1/convai/knowledge-base/rag-index
	GetOrCreateRagIndexes(ctx context.Context, request *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost, params GetOrCreateRagIndexesParams) (GetOrCreateRagIndexesRes, error)
	// GetPhoneNumberRoute invokes get_phone_number_route operation.
	//
	// Retrieve Phone Number details by ID.
	//
	// GET /v1/convai/phone-numbers/{phone_number_id}
	GetPhoneNumberRoute(ctx context.Context, params GetPhoneNumberRouteParams) (GetPhoneNumberRouteRes, error)
	// GetProjectSnapshotEndpoint invokes get_project_snapshot_endpoint operation.
	//
	// Returns the project snapshot.
	//
	// GET /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}
	GetProjectSnapshotEndpoint(ctx context.Context, params GetProjectSnapshotEndpointParams) (GetProjectSnapshotEndpointRes, error)
	// GetProjectSnapshots invokes get_project_snapshots operation.
	//
	// Retrieves a list of snapshots for a Studio project.
	//
	// GET /v1/studio/projects/{project_id}/snapshots
	GetProjectSnapshots(ctx context.Context, params GetProjectSnapshotsParams) (GetProjectSnapshotsRes, error)
	// GetProjects invokes get_projects operation.
	//
	// Returns a list of your Studio projects with metadata.
	//
	// GET /v1/studio/projects
	GetProjects(ctx context.Context, params GetProjectsParams) (GetProjectsRes, error)
	// GetPronunciationDictionariesMetadata invokes get_pronunciation_dictionaries_metadata operation.
	//
	// Get a list of the pronunciation dictionaries you have access to and their metadata.
	//
	// GET /v1/pronunciation-dictionaries
	GetPronunciationDictionariesMetadata(ctx context.Context, params GetPronunciationDictionariesMetadataParams) (GetPronunciationDictionariesMetadataRes, error)
	// GetPronunciationDictionaryMetadata invokes get_pronunciation_dictionary_metadata operation.
	//
	// Get metadata for a pronunciation dictionary.
	//
	// GET /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}
	GetPronunciationDictionaryMetadata(ctx context.Context, params GetPronunciationDictionaryMetadataParams) (GetPronunciationDictionaryMetadataRes, error)
	// GetPronunciationDictionaryVersionPls invokes get_pronunciation_dictionary_version_pls operation.
	//
	// Get a PLS file with a pronunciation dictionary version rules.
	//
	// GET /v1/pronunciation-dictionaries/{dictionary_id}/{version_id}/download
	GetPronunciationDictionaryVersionPls(ctx context.Context, params GetPronunciationDictionaryVersionPlsParams) (GetPronunciationDictionaryVersionPlsRes, error)
	// GetPublicLlmExpectedCostCalculation invokes get_public_llm_expected_cost_calculation operation.
	//
	// Returns a list of LLM models and the expected cost for using them based on the provided values.
	//
	// POST /v1/convai/llm-usage/calculate
	GetPublicLlmExpectedCostCalculation(ctx context.Context, request *LLMUsageCalculatorPublicRequestModel) (GetPublicLlmExpectedCostCalculationRes, error)
	// GetPvcSampleAudio invokes get_pvc_sample_audio operation.
	//
	// Retrieve the first 30 seconds of voice sample audio with or without noise removal.
	//
	// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/audio
	GetPvcSampleAudio(ctx context.Context, params GetPvcSampleAudioParams) (GetPvcSampleAudioRes, error)
	// GetPvcSampleSpeakers invokes get_pvc_sample_speakers operation.
	//
	// Retrieve the status of the speaker separation process and the list of detected speakers if
	// complete.
	//
	// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers
	GetPvcSampleSpeakers(ctx context.Context, params GetPvcSampleSpeakersParams) (GetPvcSampleSpeakersRes, error)
	// GetPvcSampleVisualWaveform invokes get_pvc_sample_visual_waveform operation.
	//
	// Retrieve the visual waveform of a voice sample.
	//
	// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/waveform
	GetPvcSampleVisualWaveform(ctx context.Context, params GetPvcSampleVisualWaveformParams) (GetPvcSampleVisualWaveformRes, error)
	// GetPvcVoiceCaptcha invokes get_pvc_voice_captcha operation.
	//
	// Get captcha for PVC voice verification.
	//
	// GET /v1/voices/pvc/{voice_id}/captcha
	GetPvcVoiceCaptcha(ctx context.Context, params GetPvcVoiceCaptchaParams) (GetPvcVoiceCaptchaRes, error)
	// GetRagIndexOverview invokes get_rag_index_overview operation.
	//
	// Provides total size and other information of RAG indexes used by knowledgebase documents.
	//
	// GET /v1/convai/knowledge-base/rag-index
	GetRagIndexOverview(ctx context.Context, params GetRagIndexOverviewParams) (GetRagIndexOverviewRes, error)
	// GetRagIndexes invokes get_rag_indexes operation.
	//
	// Provides information about all RAG indexes of the specified knowledgebase document.
	//
	// GET /v1/convai/knowledge-base/{documentation_id}/rag-index
	GetRagIndexes(ctx context.Context, params GetRagIndexesParams) (GetRagIndexesRes, error)
	// GetResourceMetadata invokes get_resource_metadata operation.
	//
	// Gets the metadata of a resource by ID.
	//
	// GET /v1/workspace/resources/{resource_id}
	GetResourceMetadata(ctx context.Context, params GetResourceMetadataParams) (GetResourceMetadataRes, error)
	// GetSecretsRoute invokes get_secrets_route operation.
	//
	// Get all workspace secrets for the user.
	//
	// GET /v1/convai/secrets
	GetSecretsRoute(ctx context.Context, params GetSecretsRouteParams) (GetSecretsRouteRes, error)
	// GetServiceAccountAPIKeysRoute invokes get_service_account_api_keys_route operation.
	//
	// Get all API keys for a service account.
	//
	// GET /v1/service-accounts/{service_account_user_id}/api-keys
	GetServiceAccountAPIKeysRoute(ctx context.Context, params GetServiceAccountAPIKeysRouteParams) (GetServiceAccountAPIKeysRouteRes, error)
	// GetSettingsRoute invokes get_settings_route operation.
	//
	// Retrieve Convai settings for the workspace.
	//
	// GET /v1/convai/settings
	GetSettingsRoute(ctx context.Context, params GetSettingsRouteParams) (GetSettingsRouteRes, error)
	// GetSignedURLDeprecated invokes get_signed_url_deprecated operation.
	//
	// Get a signed url to start a conversation with an agent with an agent that requires authorization.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /v1/convai/conversation/get_signed_url
	GetSignedURLDeprecated(ctx context.Context, params GetSignedURLDeprecatedParams) (GetSignedURLDeprecatedRes, error)
	// GetSimilarLibraryVoices invokes get_similar_library_voices operation.
	//
	// Returns a list of shared voices similar to the provided audio sample. If neither
	// similarity_threshold nor top_k is provided, we will apply default values.
	//
	// POST /v1/similar-voices
	GetSimilarLibraryVoices(ctx context.Context, request OptBodyGetSimilarLibraryVoicesV1SimilarVoicesPostMultipart, params GetSimilarLibraryVoicesParams) (GetSimilarLibraryVoicesRes, error)
	// GetSimilarVoicesForSpeaker invokes get_similar_voices_for_speaker operation.
	//
	// Fetch the top 10 similar voices to a speaker, including the voice IDs, names, descriptions, and,
	// where possible, a sample audio recording.
	//
	// GET /v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/similar-voices
	GetSimilarVoicesForSpeaker(ctx context.Context, params GetSimilarVoicesForSpeakerParams) (GetSimilarVoicesForSpeakerRes, error)
	// GetSingleUseToken invokes get_single_use_token operation.
	//
	// Generate a time limited single-use token with embedded authentication for frontend clients.
	//
	// POST /v1/single-use-token/{token_type}
	GetSingleUseToken(ctx context.Context, params GetSingleUseTokenParams) (GetSingleUseTokenRes, error)
	// GetSpeakerAudio invokes get_speaker_audio operation.
	//
	// Retrieve the separated audio for a specific speaker.
	//
	// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers/{speaker_id}/audio
	GetSpeakerAudio(ctx context.Context, params GetSpeakerAudioParams) (GetSpeakerAudioRes, error)
	// GetSpeechHistory invokes get_speech_history operation.
	//
	// Returns a list of your generated audio.
	//
	// GET /v1/history
	GetSpeechHistory(ctx context.Context, params GetSpeechHistoryParams) (GetSpeechHistoryRes, error)
	// GetSpeechHistoryItemByID invokes get_speech_history_item_by_id operation.
	//
	// Retrieves a history item.
	//
	// GET /v1/history/{history_item_id}
	GetSpeechHistoryItemByID(ctx context.Context, params GetSpeechHistoryItemByIDParams) (GetSpeechHistoryItemByIDRes, error)
	// GetTestInvocationRoute invokes get_test_invocation_route operation.
	//
	// Gets a test invocation by ID.
	//
	// GET /v1/convai/test-invocations/{test_invocation_id}
	GetTestInvocationRoute(ctx context.Context, params GetTestInvocationRouteParams) (GetTestInvocationRouteRes, error)
	// GetToolDependentAgentsRoute invokes get_tool_dependent_agents_route operation.
	//
	// Get a list of agents depending on this tool.
	//
	// GET /v1/convai/tools/{tool_id}/dependent-agents
	GetToolDependentAgentsRoute(ctx context.Context, params GetToolDependentAgentsRouteParams) (GetToolDependentAgentsRouteRes, error)
	// GetTranscriptByID invokes get_transcript_by_id operation.
	//
	// Retrieve a previously generated transcript by its ID.
	//
	// GET /v1/speech-to-text/transcripts/{transcription_id}
	GetTranscriptByID(ctx context.Context, params GetTranscriptByIDParams) (GetTranscriptByIDRes, error)
	// GetUserInfo invokes get_user_info operation.
	//
	// Gets information about the user.
	//
	// GET /v1/user
	GetUserInfo(ctx context.Context, params GetUserInfoParams) (GetUserInfoRes, error)
	// GetUserVoicesV2 invokes get_user_voices_v2 operation.
	//
	// Gets a list of all available voices for a user with search, filtering and pagination.
	//
	// GET /v2/voices
	GetUserVoicesV2(ctx context.Context, params GetUserVoicesV2Params) (GetUserVoicesV2Res, error)
	// GetVoiceByID invokes get_voice_by_id operation.
	//
	// Returns metadata about a specific voice.
	//
	// GET /v1/voices/{voice_id}
	GetVoiceByID(ctx context.Context, params GetVoiceByIDParams) (GetVoiceByIDRes, error)
	// GetVoiceSettings invokes get_voice_settings operation.
	//
	// Returns the settings for a specific voice. "similarity_boost" corresponds to"Clarity + Similarity
	// Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
	//
	// GET /v1/voices/{voice_id}/settings
	GetVoiceSettings(ctx context.Context, params GetVoiceSettingsParams) (GetVoiceSettingsRes, error)
	// GetVoiceSettingsDefault invokes get_voice_settings_default operation.
	//
	// Gets the default settings for voices. "similarity_boost" corresponds to"Clarity + Similarity
	// Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
	//
	// GET /v1/voices/settings/default
	GetVoiceSettingsDefault(ctx context.Context) (*VoiceSettingsResponseModel, error)
	// GetVoices invokes get_voices operation.
	//
	// Returns a list of all available voices for a user.
	//
	// GET /v1/voices
	GetVoices(ctx context.Context, params GetVoicesParams) (GetVoicesRes, error)
	// GetWhatsappAccount invokes get_whatsapp_account operation.
	//
	// Get a WhatsApp account.
	//
	// GET /v1/convai/whatsapp-accounts/{phone_number_id}
	GetWhatsappAccount(ctx context.Context, params GetWhatsappAccountParams) (GetWhatsappAccountRes, error)
	// GetWorkspaceBatchCalls invokes get_workspace_batch_calls operation.
	//
	// Get all batch calls for the current workspace.
	//
	// GET /v1/convai/batch-calling/workspace
	GetWorkspaceBatchCalls(ctx context.Context, params GetWorkspaceBatchCallsParams) (GetWorkspaceBatchCallsRes, error)
	// GetWorkspaceServiceAccounts invokes get_workspace_service_accounts operation.
	//
	// List all service accounts in the workspace.
	//
	// GET /v1/service-accounts
	GetWorkspaceServiceAccounts(ctx context.Context, params GetWorkspaceServiceAccountsParams) (GetWorkspaceServiceAccountsRes, error)
	// GetWorkspaceWebhooksRoute invokes get_workspace_webhooks_route operation.
	//
	// List all webhooks for a workspace.
	//
	// GET /v1/workspace/webhooks
	GetWorkspaceWebhooksRoute(ctx context.Context, params GetWorkspaceWebhooksRouteParams) (GetWorkspaceWebhooksRouteRes, error)
	// HandleSipTrunkOutboundCall invokes handle_sip_trunk_outbound_call operation.
	//
	// Handle an outbound call via SIP trunk.
	//
	// POST /v1/convai/sip-trunk/outbound-call
	HandleSipTrunkOutboundCall(ctx context.Context, request *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost, params HandleSipTrunkOutboundCallParams) (HandleSipTrunkOutboundCallRes, error)
	// HandleTwilioOutboundCall invokes handle_twilio_outbound_call operation.
	//
	// Handle an outbound call via Twilio.
	//
	// POST /v1/convai/twilio/outbound-call
	HandleTwilioOutboundCall(ctx context.Context, request *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost, params HandleTwilioOutboundCallParams) (HandleTwilioOutboundCallRes, error)
	// ImportWhatsappAccount invokes import_whatsapp_account operation.
	//
	// Import a WhatsApp account.
	//
	// POST /v1/convai/whatsapp-accounts
	ImportWhatsappAccount(ctx context.Context, request *ImportWhatsAppAccountRequest, params ImportWhatsappAccountParams) (ImportWhatsappAccountRes, error)
	// InviteUser invokes invite_user operation.
	//
	// Sends an email invitation to join your workspace to the provided email. If the user doesn't have
	// an account they will be prompted to create one. If the user accepts this invite they will be added
	// as a user to your workspace and your subscription using one of your seats. This endpoint may only
	// be called by workspace administrators. If the user is already in the workspace a 400 error will be
	// returned.
	//
	// POST /v1/workspace/invites/add
	InviteUser(ctx context.Context, request *BodyInviteUserV1WorkspaceInvitesAddPost, params InviteUserParams) (InviteUserRes, error)
	// InviteUsersBulk invokes invite_users_bulk operation.
	//
	// Sends email invitations to join your workspace to the provided emails. Requires all email
	// addresses to be part of a verified domain. If the users don't have an account they will be
	// prompted to create one. If the users accept these invites they will be added as users to your
	// workspace and your subscription using one of your seats. This endpoint may only be called by
	// workspace administrators.
	//
	// POST /v1/workspace/invites/add-bulk
	InviteUsersBulk(ctx context.Context, request *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost, params InviteUsersBulkParams) (InviteUsersBulkRes, error)
	// ListChatResponseTestsRoute invokes list_chat_response_tests_route operation.
	//
	// Lists all agent response tests with pagination support and optional search filtering.
	//
	// GET /v1/convai/agent-testing
	ListChatResponseTestsRoute(ctx context.Context, params ListChatResponseTestsRouteParams) (ListChatResponseTestsRouteRes, error)
	// ListDubs invokes list_dubs operation.
	//
	// List the dubs you have access to.
	//
	// GET /v1/dubbing
	ListDubs(ctx context.Context, params ListDubsParams) (ListDubsRes, error)
	// ListMcpServerToolsRoute invokes list_mcp_server_tools_route operation.
	//
	// Retrieve all tools available for a specific MCP server configuration.
	//
	// GET /v1/convai/mcp-servers/{mcp_server_id}/tools
	ListMcpServerToolsRoute(ctx context.Context, params ListMcpServerToolsRouteParams) (ListMcpServerToolsRouteRes, error)
	// ListPhoneNumbersRoute invokes list_phone_numbers_route operation.
	//
	// Retrieve all Phone Numbers.
	//
	// GET /v1/convai/phone-numbers
	ListPhoneNumbersRoute(ctx context.Context, params ListPhoneNumbersRouteParams) (ListPhoneNumbersRouteRes, error)
	// ListTestInvocationsRoute invokes list_test_invocations_route operation.
	//
	// Lists all test invocations with pagination support and optional search filtering.
	//
	// GET /v1/convai/test-invocations
	ListTestInvocationsRoute(ctx context.Context, params ListTestInvocationsRouteParams) (ListTestInvocationsRouteRes, error)
	// ListWhatsappAccounts invokes list_whatsapp_accounts operation.
	//
	// List all WhatsApp accounts.
	//
	// GET /v1/convai/whatsapp-accounts
	ListWhatsappAccounts(ctx context.Context, params ListWhatsappAccountsParams) (ListWhatsappAccountsRes, error)
	// MigrateSegments invokes migrate_segments operation.
	//
	// Change the attribution of one or more segments to a different speaker.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/migrate-segments
	MigrateSegments(ctx context.Context, request *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost, params MigrateSegmentsParams) (MigrateSegmentsRes, error)
	// PatchPronunciationDictionary invokes patch_pronunciation_dictionary operation.
	//
	// Partially update the pronunciation dictionary without changing the version.
	//
	// PATCH /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}
	PatchPronunciationDictionary(ctx context.Context, request OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch, params PatchPronunciationDictionaryParams) (PatchPronunciationDictionaryRes, error)
	// PostAgentAvatarRoute invokes post_agent_avatar_route operation.
	//
	// Sets the avatar for an agent displayed in the widget.
	//
	// POST /v1/convai/agents/{agent_id}/avatar
	PostAgentAvatarRoute(ctx context.Context, request *BodyPostAgentAvatarV1ConvaiAgentsAgentIDAvatarPostMultipart, params PostAgentAvatarRouteParams) (PostAgentAvatarRouteRes, error)
	// PostConversationFeedbackRoute invokes post_conversation_feedback_route operation.
	//
	// Send the feedback for the given conversation.
	//
	// POST /v1/convai/conversations/{conversation_id}/feedback
	PostConversationFeedbackRoute(ctx context.Context, request *ConversationFeedbackRequestModel, params PostConversationFeedbackRouteParams) (PostConversationFeedbackRouteRes, error)
	// RagIndexStatus invokes rag_index_status operation.
	//
	// In case the document is not RAG indexed, it triggers rag indexing task, otherwise it just returns
	// the current status.
	//
	// POST /v1/convai/knowledge-base/{documentation_id}/rag-index
	RagIndexStatus(ctx context.Context, request *RAGIndexRequestModel, params RagIndexStatusParams) (RagIndexStatusRes, error)
	// RedirectToMintlify invokes redirect_to_mintlify operation.
	//
	// Redirect To Mintlify.
	//
	// GET /docs
	RedirectToMintlify(ctx context.Context) (jx.Raw, error)
	// RegisterTwilioCall invokes register_twilio_call operation.
	//
	// Register a Twilio call and return TwiML to connect the call.
	//
	// POST /v1/convai/twilio/register-call
	RegisterTwilioCall(ctx context.Context, request *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost, params RegisterTwilioCallParams) (RegisterTwilioCallRes, error)
	// RemoveMember invokes remove_member operation.
	//
	// Removes a member from the specified group. This endpoint may only be called by workspace
	// administrators.
	//
	// POST /v1/workspace/groups/{group_id}/members/remove
	RemoveMember(ctx context.Context, request *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost, params RemoveMemberParams) (RemoveMemberRes, error)
	// RemoveRules invokes remove_rules operation.
	//
	// Remove rules from the pronunciation dictionary.
	//
	// POST /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/remove-rules
	RemoveRules(ctx context.Context, request *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost, params RemoveRulesParams) (RemoveRulesRes, error)
	// RequestPvcManualVerification invokes request_pvc_manual_verification operation.
	//
	// Request manual verification for a PVC voice.
	//
	// POST /v1/voices/pvc/{voice_id}/verification
	RequestPvcManualVerification(ctx context.Context, request *BodyRequestManualVerificationV1VoicesPvcVoiceIDVerificationPostMultipart, params RequestPvcManualVerificationParams) (RequestPvcManualVerificationRes, error)
	// RetryBatchCall invokes retry_batch_call operation.
	//
	// Retry a batch call, calling failed and no-response recipients again.
	//
	// POST /v1/convai/batch-calling/{batch_id}/retry
	RetryBatchCall(ctx context.Context, params RetryBatchCallParams) (RetryBatchCallRes, error)
	// RunPvcVoiceTraining invokes run_pvc_voice_training operation.
	//
	// Start PVC training process for a voice.
	//
	// POST /v1/voices/pvc/{voice_id}/train
	RunPvcVoiceTraining(ctx context.Context, request OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost, params RunPvcVoiceTrainingParams) (RunPvcVoiceTrainingRes, error)
	// SearchGroups invokes search_groups operation.
	//
	// Searches for user groups in the workspace. Multiple or no groups may be returned.
	//
	// GET /v1/workspace/groups/search
	SearchGroups(ctx context.Context, params SearchGroupsParams) (SearchGroupsRes, error)
	// SeparateSongStems invokes separate_song_stems operation.
	//
	// Separate an audio file into individual stems. This endpoint might have high latency, depending on
	// the length of the audio file.
	//
	// POST /v1/music/stem-separation
	SeparateSongStems(ctx context.Context, request *BodyStemSeparationV1MusicStemSeparationPostMultipart, params SeparateSongStemsParams) (SeparateSongStemsRes, error)
	// ShareResourceEndpoint invokes share_resource_endpoint operation.
	//
	// Grants a role on a workspace resource to a user or a group. It overrides any existing role this
	// user/service account/group/workspace api key has on the resource. To target a user or service
	// account, pass only the user email. The user must be in your workspace. To target a group, pass
	// only the group id. To target a workspace api key, pass the api key id. The resource will be shared
	// with the service account associated with the api key. You must have admin access to the resource
	// to share it.
	//
	// POST /v1/workspace/resources/{resource_id}/share
	ShareResourceEndpoint(ctx context.Context, request *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost, params ShareResourceEndpointParams) (ShareResourceEndpointRes, error)
	// SoundGeneration invokes sound_generation operation.
	//
	// Turn text into sound effects for your videos, voice-overs or video games using the most advanced
	// sound effects models in the world.
	//
	// POST /v1/sound-generation
	SoundGeneration(ctx context.Context, request *BodySoundGenerationV1SoundGenerationPost, params SoundGenerationParams) (SoundGenerationRes, error)
	// SpeechToSpeechFull invokes speech_to_speech_full operation.
	//
	// Transform audio from one voice to another. Maintain full control over emotion, timing and delivery.
	//
	// POST /v1/speech-to-speech/{voice_id}
	SpeechToSpeechFull(ctx context.Context, request *BodySpeechToSpeechV1SpeechToSpeechVoiceIDPostMultipart, params SpeechToSpeechFullParams) (SpeechToSpeechFullRes, error)
	// SpeechToSpeechStream invokes speech_to_speech_stream operation.
	//
	// Stream audio from one voice to another. Maintain full control over emotion, timing and delivery.
	//
	// POST /v1/speech-to-speech/{voice_id}/stream
	SpeechToSpeechStream(ctx context.Context, request *BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIDStreamPostMultipart, params SpeechToSpeechStreamParams) (SpeechToSpeechStreamRes, error)
	// SpeechToText invokes speech_to_text operation.
	//
	// Transcribe an audio or video file. If webhook is set to true, the request will be processed
	// asynchronously and results sent to configured webhooks. When use_multi_channel is true and the
	// provided audio has multiple channels, a 'transcripts' object with separate transcripts for each
	// channel is returned. Otherwise, returns a single transcript. The optional webhook_metadata
	// parameter allows you to attach custom data that will be included in webhook responses for request
	// correlation and tracking.
	//
	// POST /v1/speech-to-text
	SpeechToText(ctx context.Context, request *BodySpeechToTextV1SpeechToTextPostMultipart, params SpeechToTextParams) (SpeechToTextRes, error)
	// StartSpeakerSeparation invokes start_speaker_separation operation.
	//
	// Start speaker separation process for a sample.
	//
	// POST /v1/voices/pvc/{voice_id}/samples/{sample_id}/separate-speakers
	StartSpeakerSeparation(ctx context.Context, params StartSpeakerSeparationParams) (StartSpeakerSeparationRes, error)
	// StreamChapterSnapshotAudio invokes stream_chapter_snapshot_audio operation.
	//
	// Stream the audio from a chapter snapshot. Use `GET
	// /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots` to return the snapshots of a
	// chapter.
	//
	// POST /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream
	StreamChapterSnapshotAudio(ctx context.Context, request OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost, params StreamChapterSnapshotAudioParams) (StreamChapterSnapshotAudioRes, error)
	// StreamCompose invokes stream_compose operation.
	//
	// Stream a composed song from a prompt or a composition plan.
	//
	// POST /v1/music/stream
	StreamCompose(ctx context.Context, request OptBodyStreamComposedMusicV1MusicStreamPost, params StreamComposeParams) (StreamComposeRes, error)
	// StreamProjectSnapshotArchiveEndpoint invokes stream_project_snapshot_archive_endpoint operation.
	//
	// Returns a compressed archive of the Studio project's audio.
	//
	// POST /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/archive
	StreamProjectSnapshotArchiveEndpoint(ctx context.Context, params StreamProjectSnapshotArchiveEndpointParams) (StreamProjectSnapshotArchiveEndpointRes, error)
	// StreamProjectSnapshotAudioEndpoint invokes stream_project_snapshot_audio_endpoint operation.
	//
	// Stream the audio from a Studio project snapshot.
	//
	// POST /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/stream
	StreamProjectSnapshotAudioEndpoint(ctx context.Context, request OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost, params StreamProjectSnapshotAudioEndpointParams) (StreamProjectSnapshotAudioEndpointRes, error)
	// TextToDialogue invokes text_to_dialogue operation.
	//
	// Converts a list of text and voice ID pairs into speech (dialogue) and returns audio.
	//
	// POST /v1/text-to-dialogue
	TextToDialogue(ctx context.Context, request *BodyTextToDialogueMultiVoiceV1TextToDialoguePost, params TextToDialogueParams) (TextToDialogueRes, error)
	// TextToDialogueFullWithTimestamps invokes text_to_dialogue_full_with_timestamps operation.
	//
	// Generate dialogue from text with precise character-level timing information for audio-text
	// synchronization.
	//
	// POST /v1/text-to-dialogue/with-timestamps
	TextToDialogueFullWithTimestamps(ctx context.Context, request *BodyTextToDialogueFullWithTimestamps, params TextToDialogueFullWithTimestampsParams) (TextToDialogueFullWithTimestampsRes, error)
	// TextToDialogueStream invokes text_to_dialogue_stream operation.
	//
	// Converts a list of text and voice ID pairs into speech (dialogue) and returns an audio stream.
	//
	// POST /v1/text-to-dialogue/stream
	TextToDialogueStream(ctx context.Context, request *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost, params TextToDialogueStreamParams) (TextToDialogueStreamRes, error)
	// TextToDialogueStreamWithTimestamps invokes text_to_dialogue_stream_with_timestamps operation.
	//
	// Converts a list of text and voice ID pairs into speech (dialogue) and returns a stream of JSON
	// blobs containing audio as a base64 encoded string and timestamps.
	//
	// POST /v1/text-to-dialogue/stream/with-timestamps
	TextToDialogueStreamWithTimestamps(ctx context.Context, request *BodyTextToDialogueStreamWithTimestamps, params TextToDialogueStreamWithTimestampsParams) (TextToDialogueStreamWithTimestampsRes, error)
	// TextToSpeechFull invokes text_to_speech_full operation.
	//
	// Converts text into speech using a voice of your choice and returns audio.
	//
	// POST /v1/text-to-speech/{voice_id}
	TextToSpeechFull(ctx context.Context, request *BodyTextToSpeechFull, params TextToSpeechFullParams) (TextToSpeechFullRes, error)
	// TextToSpeechFullWithTimestamps invokes text_to_speech_full_with_timestamps operation.
	//
	// Generate speech from text with precise character-level timing information for audio-text
	// synchronization.
	//
	// POST /v1/text-to-speech/{voice_id}/with-timestamps
	TextToSpeechFullWithTimestamps(ctx context.Context, request *BodyTextToSpeechFullWithTimestamps, params TextToSpeechFullWithTimestampsParams) (TextToSpeechFullWithTimestampsRes, error)
	// TextToSpeechStream invokes text_to_speech_stream operation.
	//
	// Converts text into speech using a voice of your choice and returns audio as an audio stream.
	//
	// POST /v1/text-to-speech/{voice_id}/stream
	TextToSpeechStream(ctx context.Context, request *BodyTextToSpeechStream, params TextToSpeechStreamParams) (TextToSpeechStreamRes, error)
	// TextToSpeechStreamWithTimestamps invokes text_to_speech_stream_with_timestamps operation.
	//
	// Converts text into speech using a voice of your choice and returns a stream of JSONs containing
	// audio as a base64 encoded string together with information on when which character was spoken.
	//
	// POST /v1/text-to-speech/{voice_id}/stream/with-timestamps
	TextToSpeechStreamWithTimestamps(ctx context.Context, request *BodyTextToSpeechStreamWithTimestamps, params TextToSpeechStreamWithTimestampsParams) (TextToSpeechStreamWithTimestampsRes, error)
	// TextToVoice invokes text_to_voice operation.
	//
	// Generate a custom voice based on voice description. This method returns a list of voice previews.
	// Each preview has a generated_voice_id and a sample of the voice as base64 encoded mp3 audio. If
	// you like the a voice previewand want to create the voice call
	// /v1/text-to-voice/create-voice-from-preview with the generated_voice_id to create the voice.
	//
	// POST /v1/text-to-voice/create-previews
	TextToVoice(ctx context.Context, request *VoicePreviewsRequestModel, params TextToVoiceParams) (TextToVoiceRes, error)
	// TextToVoiceDesign invokes text_to_voice_design operation.
	//
	// Design a voice via a prompt. This method returns a list of voice previews. Each preview has a
	// generated_voice_id and a sample of the voice as base64 encoded mp3 audio. To create a voice use
	// the generated_voice_id of the preferred preview with the /v1/text-to-voice endpoint.
	//
	// POST /v1/text-to-voice/design
	TextToVoiceDesign(ctx context.Context, request *VoiceDesignRequestModel, params TextToVoiceDesignParams) (TextToVoiceDesignRes, error)
	// TextToVoicePreviewStream invokes text_to_voice_preview_stream operation.
	//
	// Stream a voice preview that was created via the /v1/text-to-voice/design endpoint.
	//
	// GET /v1/text-to-voice/{generated_voice_id}/stream
	TextToVoicePreviewStream(ctx context.Context, params TextToVoicePreviewStreamParams) (TextToVoicePreviewStreamRes, error)
	// TextToVoiceRemix invokes text_to_voice_remix operation.
	//
	// Remix an existing voice via a prompt. This method returns a list of voice previews. Each preview
	// has a generated_voice_id and a sample of the voice as base64 encoded mp3 audio. To create a voice
	// use the generated_voice_id of the preferred preview with the /v1/text-to-voice endpoint.
	//
	// POST /v1/text-to-voice/{voice_id}/remix
	TextToVoiceRemix(ctx context.Context, request *VoiceRemixRequestModel, params TextToVoiceRemixParams) (TextToVoiceRemixRes, error)
	// Transcribe invokes transcribe operation.
	//
	// Regenerate the transcriptions for the specified segments. Does not automatically regenerate
	// translations or dubs.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/transcribe
	Transcribe(ctx context.Context, request *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost, params TranscribeParams) (TranscribeRes, error)
	// Translate invokes translate operation.
	//
	// Regenerate the translations for either the entire resource or the specified segments/languages.
	// Will automatically transcribe missing transcriptions. Will not automatically regenerate the dubs.
	//
	// POST /v1/dubbing/resource/{dubbing_id}/translate
	Translate(ctx context.Context, request *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost, params TranslateParams) (TranslateRes, error)
	// UnshareResourceEndpoint invokes unshare_resource_endpoint operation.
	//
	// Removes any existing role on a workspace resource from a user, service account, group or workspace
	// api key. To target a user or service account, pass only the user email. The user must be in your
	// workspace. To target a group, pass only the group id. To target a workspace api key, pass the api
	// key id. The resource will be unshared from the service account associated with the api key. You
	// must have admin access to the resource to unshare it. You cannot remove permissions from the user
	// who created the resource.
	//
	// POST /v1/workspace/resources/{resource_id}/unshare
	UnshareResourceEndpoint(ctx context.Context, request *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost, params UnshareResourceEndpointParams) (UnshareResourceEndpointRes, error)
	// UpdateAgentResponseTestRoute invokes update_agent_response_test_route operation.
	//
	// Updates an agent response test by ID.
	//
	// PUT /v1/convai/agent-testing/{test_id}
	UpdateAgentResponseTestRoute(ctx context.Context, request *UpdateUnitTestRequest, params UpdateAgentResponseTestRouteParams) (UpdateAgentResponseTestRouteRes, error)
	// UpdateDashboardSettingsRoute invokes update_dashboard_settings_route operation.
	//
	// Update Convai dashboard settings for the workspace.
	//
	// PATCH /v1/convai/settings/dashboard
	UpdateDashboardSettingsRoute(ctx context.Context, request *PatchConvAIDashboardSettingsRequest, params UpdateDashboardSettingsRouteParams) (UpdateDashboardSettingsRouteRes, error)
	// UpdateDocumentRoute invokes update_document_route operation.
	//
	// Update the name of a document.
	//
	// PATCH /v1/convai/knowledge-base/{documentation_id}
	UpdateDocumentRoute(ctx context.Context, request *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch, params UpdateDocumentRouteParams) (UpdateDocumentRouteRes, error)
	// UpdatePhoneNumberRoute invokes update_phone_number_route operation.
	//
	// Update assigned agent of a phone number.
	//
	// PATCH /v1/convai/phone-numbers/{phone_number_id}
	UpdatePhoneNumberRoute(ctx context.Context, request *UpdatePhoneNumberRequest, params UpdatePhoneNumberRouteParams) (UpdatePhoneNumberRouteRes, error)
	// UpdatePronunciationDictionaries invokes update_pronunciation_dictionaries operation.
	//
	// Create a set of pronunciation dictionaries acting on a project. This will automatically mark text
	// within this project as requiring reconverting where the new dictionary would apply or the old one
	// no longer does.
	//
	// POST /v1/studio/projects/{project_id}/pronunciation-dictionaries
	UpdatePronunciationDictionaries(ctx context.Context, request *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost, params UpdatePronunciationDictionariesParams) (UpdatePronunciationDictionariesRes, error)
	// UpdateSecretRoute invokes update_secret_route operation.
	//
	// Update an existing secret for the workspace.
	//
	// PATCH /v1/convai/secrets/{secret_id}
	UpdateSecretRoute(ctx context.Context, request *PatchWorkspaceSecretRequest, params UpdateSecretRouteParams) (UpdateSecretRouteRes, error)
	// UpdateSegmentLanguage invokes update_segment_language operation.
	//
	// Modifies a single segment with new text and/or start/end times. Will update the values for only a
	// specific language of a segment. Does not automatically regenerate the dub.
	//
	// PATCH /v1/dubbing/resource/{dubbing_id}/segment/{segment_id}/{language}
	UpdateSegmentLanguage(ctx context.Context, request *SegmentUpdatePayload, params UpdateSegmentLanguageParams) (UpdateSegmentLanguageRes, error)
	// UpdateSettingsRoute invokes update_settings_route operation.
	//
	// Update Convai settings for the workspace.
	//
	// PATCH /v1/convai/settings
	UpdateSettingsRoute(ctx context.Context, request *PatchConvAISettingsRequest, params UpdateSettingsRouteParams) (UpdateSettingsRouteRes, error)
	// UpdateSpeaker invokes update_speaker operation.
	//
	// Amend the metadata associated with a speaker, such as their voice. Both voice cloning and using
	// voices from the ElevenLabs library are supported.
	//
	// PATCH /v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}
	UpdateSpeaker(ctx context.Context, request OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch, params UpdateSpeakerParams) (UpdateSpeakerRes, error)
	// UpdateWhatsappAccount invokes update_whatsapp_account operation.
	//
	// Update a WhatsApp account.
	//
	// PATCH /v1/convai/whatsapp-accounts/{phone_number_id}
	UpdateWhatsappAccount(ctx context.Context, request *UpdateWhatsAppAccountRequest, params UpdateWhatsappAccountParams) (UpdateWhatsappAccountRes, error)
	// UpdateWorkspaceMember invokes update_workspace_member operation.
	//
	// Updates attributes of a workspace member. Apart from the email identifier, all parameters will
	// remain unchanged unless specified. This endpoint may only be called by workspace administrators.
	//
	// POST /v1/workspace/members
	UpdateWorkspaceMember(ctx context.Context, request *BodyUpdateMemberV1WorkspaceMembersPost, params UpdateWorkspaceMemberParams) (UpdateWorkspaceMemberRes, error)
	// UsageCharacters invokes usage_characters operation.
	//
	// Returns the usage metrics for the current user or the entire workspace they are part of. The
	// response provides a time axis based on the specified aggregation interval (default: day), with
	// usage values for each interval along that axis. Usage is broken down by the selected breakdown
	// type. For example, breakdown type "voice" will return the usage of each voice for each interval
	// along the time axis.
	//
	// GET /v1/usage/character-stats
	UsageCharacters(ctx context.Context, params UsageCharactersParams) (UsageCharactersRes, error)
	// VerifyPvcVoiceCaptcha invokes verify_pvc_voice_captcha operation.
	//
	// Submit captcha verification for PVC voice.
	//
	// POST /v1/voices/pvc/{voice_id}/captcha
	VerifyPvcVoiceCaptcha(ctx context.Context, request *BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIDCaptchaPostMultipart, params VerifyPvcVoiceCaptchaParams) (VerifyPvcVoiceCaptchaRes, error)
	// WhatsappOutboundCall invokes whatsapp_outbound_call operation.
	//
	// Make an outbound call via WhatsApp.
	//
	// POST /v1/convai/whatsapp/outbound-call
	WhatsappOutboundCall(ctx context.Context, request *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost, params WhatsappOutboundCallParams) (WhatsappOutboundCallRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddDocumentationToKnowledgeBase invokes add_documentation_to_knowledge_base operation.
//
// Uploads a file or reference a webpage to use as part of the shared knowledge base.
//
// Deprecated: schema marks this operation as deprecated.
//
// POST /v1/convai/knowledge-base
func (c *Client) AddDocumentationToKnowledgeBase(ctx context.Context, request OptBodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostMultipart, params AddDocumentationToKnowledgeBaseParams) (AddDocumentationToKnowledgeBaseRes, error) {
	res, err := c.sendAddDocumentationToKnowledgeBase(ctx, request, params)
	return res, err
}

func (c *Client) sendAddDocumentationToKnowledgeBase(ctx context.Context, request OptBodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostMultipart, params AddDocumentationToKnowledgeBaseParams) (res AddDocumentationToKnowledgeBaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_documentation_to_knowledge_base"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddDocumentationToKnowledgeBaseOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AgentID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddDocumentationToKnowledgeBaseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddDocumentationToKnowledgeBaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddFromFile invokes add_from_file operation.
//
// Creates a new pronunciation dictionary from a lexicon .PLS file.
//
// POST /v1/pronunciation-dictionaries/add-from-file
func (c *Client) AddFromFile(ctx context.Context, request *BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostMultipart, params AddFromFileParams) (AddFromFileRes, error) {
	res, err := c.sendAddFromFile(ctx, request, params)
	return res, err
}

func (c *Client) sendAddFromFile(ctx context.Context, request *BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostMultipart, params AddFromFileParams) (res AddFromFileRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_from_file"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/pronunciation-dictionaries/add-from-file"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddFromFileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/pronunciation-dictionaries/add-from-file"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddFromFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddFromFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddLanguage invokes add_language operation.
//
// Adds the given ElevenLab Turbo V2/V2.5 language code to the resource. Does not automatically
// generate transcripts/translations/audio.
//
// POST /v1/dubbing/resource/{dubbing_id}/language
func (c *Client) AddLanguage(ctx context.Context, request *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost, params AddLanguageParams) (AddLanguageRes, error) {
	res, err := c.sendAddLanguage(ctx, request, params)
	return res, err
}

func (c *Client) sendAddLanguage(ctx context.Context, request *BodyAddALanguageToTheResourceV1DubbingResourceDubbingIDLanguagePost, params AddLanguageParams) (res AddLanguageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_language"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/language"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddLanguageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/language"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddLanguageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddLanguageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMember invokes add_member operation.
//
// Adds a member of your workspace to the specified group. This endpoint may only be called by
// workspace administrators.
//
// POST /v1/workspace/groups/{group_id}/members
func (c *Client) AddMember(ctx context.Context, request *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost, params AddMemberParams) (AddMemberRes, error) {
	res, err := c.sendAddMember(ctx, request, params)
	return res, err
}

func (c *Client) sendAddMember(ctx context.Context, request *BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIDMembersPost, params AddMemberParams) (res AddMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_member"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/groups/{group_id}/members"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/workspace/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddProject invokes add_project operation.
//
// Creates a new Studio project, it can be either initialized as blank, from a document or from a URL.
//
// POST /v1/studio/projects
func (c *Client) AddProject(ctx context.Context, request *BodyCreateStudioProjectV1StudioProjectsPostMultipart, params AddProjectParams) (AddProjectRes, error) {
	res, err := c.sendAddProject(ctx, request, params)
	return res, err
}

func (c *Client) sendAddProject(ctx context.Context, request *BodyCreateStudioProjectV1StudioProjectsPostMultipart, params AddProjectParams) (res AddProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_project"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/studio/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddPvcVoiceSamples invokes add_pvc_voice_samples operation.
//
// Add audio samples to a PVC voice.
//
// POST /v1/voices/pvc/{voice_id}/samples
func (c *Client) AddPvcVoiceSamples(ctx context.Context, request *BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIDSamplesPostMultipart, params AddPvcVoiceSamplesParams) (AddPvcVoiceSamplesRes, error) {
	res, err := c.sendAddPvcVoiceSamples(ctx, request, params)
	return res, err
}

func (c *Client) sendAddPvcVoiceSamples(ctx context.Context, request *BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIDSamplesPostMultipart, params AddPvcVoiceSamplesParams) (res AddPvcVoiceSamplesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_pvc_voice_samples"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddPvcVoiceSamplesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddPvcVoiceSamplesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddPvcVoiceSamplesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddSharingVoice invokes add_sharing_voice operation.
//
// Add a shared voice to your collection of voices.
//
// POST /v1/voices/add/{public_user_id}/{voice_id}
func (c *Client) AddSharingVoice(ctx context.Context, request *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost, params AddSharingVoiceParams) (AddSharingVoiceRes, error) {
	res, err := c.sendAddSharingVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendAddSharingVoice(ctx context.Context, request *BodyAddSharedVoiceV1VoicesAddPublicUserIDVoiceIDPost, params AddSharingVoiceParams) (res AddSharingVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_sharing_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/add/{public_user_id}/{voice_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddSharingVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/voices/add/"
	{
		// Encode "public_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "public_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PublicUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddSharingVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddSharingVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddVoice invokes add_voice operation.
//
// Add a new voice to your collection of voices in VoiceLab.
//
// POST /v1/voices/add
func (c *Client) AddVoice(ctx context.Context, request *BodyAddVoiceV1VoicesAddPostMultipart, params AddVoiceParams) (AddVoiceRes, error) {
	res, err := c.sendAddVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendAddVoice(ctx context.Context, request *BodyAddVoiceV1VoicesAddPostMultipart, params AddVoiceParams) (res AddVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("add_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/add"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AddVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voices/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAddVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AudioIsolation invokes audio_isolation operation.
//
// Removes background noise from audio.
//
// POST /v1/audio-isolation
func (c *Client) AudioIsolation(ctx context.Context, request *BodyAudioIsolationV1AudioIsolationPostMultipart, params AudioIsolationParams) (AudioIsolationRes, error) {
	res, err := c.sendAudioIsolation(ctx, request, params)
	return res, err
}

func (c *Client) sendAudioIsolation(ctx context.Context, request *BodyAudioIsolationV1AudioIsolationPostMultipart, params AudioIsolationParams) (res AudioIsolationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("audio_isolation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/audio-isolation"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AudioIsolationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/audio-isolation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAudioIsolationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAudioIsolationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AudioIsolationStream invokes audio_isolation_stream operation.
//
// Removes background noise from audio and streams the result.
//
// POST /v1/audio-isolation/stream
func (c *Client) AudioIsolationStream(ctx context.Context, request *BodyAudioIsolationStreamV1AudioIsolationStreamPostMultipart, params AudioIsolationStreamParams) (AudioIsolationStreamRes, error) {
	res, err := c.sendAudioIsolationStream(ctx, request, params)
	return res, err
}

func (c *Client) sendAudioIsolationStream(ctx context.Context, request *BodyAudioIsolationStreamV1AudioIsolationStreamPostMultipart, params AudioIsolationStreamParams) (res AudioIsolationStreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("audio_isolation_stream"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/audio-isolation/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AudioIsolationStreamOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/audio-isolation/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAudioIsolationStreamRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAudioIsolationStreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AudioNativeProjectUpdateContentEndpoint invokes audio_native_project_update_content_endpoint operation.
//
// Updates content for the specific AudioNative Project.
//
// POST /v1/audio-native/{project_id}/content
func (c *Client) AudioNativeProjectUpdateContentEndpoint(ctx context.Context, request OptBodyUpdateAudioNativeProjectContentV1AudioNativeProjectIDContentPostMultipart, params AudioNativeProjectUpdateContentEndpointParams) (AudioNativeProjectUpdateContentEndpointRes, error) {
	res, err := c.sendAudioNativeProjectUpdateContentEndpoint(ctx, request, params)
	return res, err
}

func (c *Client) sendAudioNativeProjectUpdateContentEndpoint(ctx context.Context, request OptBodyUpdateAudioNativeProjectContentV1AudioNativeProjectIDContentPostMultipart, params AudioNativeProjectUpdateContentEndpointParams) (res AudioNativeProjectUpdateContentEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("audio_native_project_update_content_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/audio-native/{project_id}/content"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AudioNativeProjectUpdateContentEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/audio-native/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/content"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAudioNativeProjectUpdateContentEndpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAudioNativeProjectUpdateContentEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelBatchCall invokes cancel_batch_call operation.
//
// Cancel a running batch call and set all recipients to cancelled status.
//
// POST /v1/convai/batch-calling/{batch_id}/cancel
func (c *Client) CancelBatchCall(ctx context.Context, params CancelBatchCallParams) (CancelBatchCallRes, error) {
	res, err := c.sendCancelBatchCall(ctx, params)
	return res, err
}

func (c *Client) sendCancelBatchCall(ctx context.Context, params CancelBatchCallParams) (res CancelBatchCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cancel_batch_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/batch-calling/{batch_id}/cancel"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CancelBatchCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/batch-calling/"
	{
		// Encode "batch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "batch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BatchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCancelBatchCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComposeDetailed invokes compose_detailed operation.
//
// Compose a song from a prompt or a composition plan.
//
// POST /v1/music/detailed
func (c *Client) ComposeDetailed(ctx context.Context, request OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost, params ComposeDetailedParams) (ComposeDetailedRes, error) {
	res, err := c.sendComposeDetailed(ctx, request, params)
	return res, err
}

func (c *Client) sendComposeDetailed(ctx context.Context, request OptBodyComposeMusicWithADetailedResponseV1MusicDetailedPost, params ComposeDetailedParams) (res ComposeDetailedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("compose_detailed"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/music/detailed"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ComposeDetailedOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/music/detailed"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComposeDetailedRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComposeDetailedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComposePlan invokes compose_plan operation.
//
// Generate a composition plan from a prompt.
//
// POST /v1/music/plan
func (c *Client) ComposePlan(ctx context.Context, request *BodyGenerateCompositionPlanV1MusicPlanPost, params ComposePlanParams) (ComposePlanRes, error) {
	res, err := c.sendComposePlan(ctx, request, params)
	return res, err
}

func (c *Client) sendComposePlan(ctx context.Context, request *BodyGenerateCompositionPlanV1MusicPlanPost, params ComposePlanParams) (res ComposePlanRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("compose_plan"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/music/plan"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ComposePlanOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/music/plan"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComposePlanRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComposePlanResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConvertChapterEndpoint invokes convert_chapter_endpoint operation.
//
// Starts conversion of a specific chapter.
//
// POST /v1/studio/projects/{project_id}/chapters/{chapter_id}/convert
func (c *Client) ConvertChapterEndpoint(ctx context.Context, params ConvertChapterEndpointParams) (ConvertChapterEndpointRes, error) {
	res, err := c.sendConvertChapterEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendConvertChapterEndpoint(ctx context.Context, params ConvertChapterEndpointParams) (res ConvertChapterEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("convert_chapter_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/chapters/{chapter_id}/convert"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConvertChapterEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chapters/"
	{
		// Encode "chapter_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/convert"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeConvertChapterEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConvertProjectEndpoint invokes convert_project_endpoint operation.
//
// Starts conversion of a Studio project and all of its chapters.
//
// POST /v1/studio/projects/{project_id}/convert
func (c *Client) ConvertProjectEndpoint(ctx context.Context, params ConvertProjectEndpointParams) (ConvertProjectEndpointRes, error) {
	res, err := c.sendConvertProjectEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendConvertProjectEndpoint(ctx context.Context, params ConvertProjectEndpointParams) (res ConvertProjectEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("convert_project_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/convert"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConvertProjectEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/convert"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeConvertProjectEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAgentResponseTestRoute invokes create_agent_response_test_route operation.
//
// Creates a new agent response test.
//
// POST /v1/convai/agent-testing/create
func (c *Client) CreateAgentResponseTestRoute(ctx context.Context, request *CreateUnitTestRequest, params CreateAgentResponseTestRouteParams) (CreateAgentResponseTestRouteRes, error) {
	res, err := c.sendCreateAgentResponseTestRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateAgentResponseTestRoute(ctx context.Context, request *CreateUnitTestRequest, params CreateAgentResponseTestRouteParams) (res CreateAgentResponseTestRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_agent_response_test_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/agent-testing/create"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAgentResponseTestRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/agent-testing/create"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAgentResponseTestRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAgentResponseTestRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAudioNativeProject invokes create_audio_native_project operation.
//
// Creates Audio Native enabled project, optionally starts conversion and returns project ID and
// embeddable HTML snippet.
//
// POST /v1/audio-native
func (c *Client) CreateAudioNativeProject(ctx context.Context, request *BodyCreatesAudioNativeEnabledProjectV1AudioNativePostMultipart, params CreateAudioNativeProjectParams) (CreateAudioNativeProjectRes, error) {
	res, err := c.sendCreateAudioNativeProject(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateAudioNativeProject(ctx context.Context, request *BodyCreatesAudioNativeEnabledProjectV1AudioNativePostMultipart, params CreateAudioNativeProjectParams) (res CreateAudioNativeProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_audio_native_project"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/audio-native"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateAudioNativeProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/audio-native"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAudioNativeProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateAudioNativeProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBatchCall invokes create_batch_call operation.
//
// Submit a batch call request to schedule calls for multiple recipients.
//
// POST /v1/convai/batch-calling/submit
func (c *Client) CreateBatchCall(ctx context.Context, request *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost, params CreateBatchCallParams) (CreateBatchCallRes, error) {
	res, err := c.sendCreateBatchCall(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateBatchCall(ctx context.Context, request *BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost, params CreateBatchCallParams) (res CreateBatchCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_batch_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/batch-calling/submit"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateBatchCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/batch-calling/submit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBatchCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateBatchCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateClip invokes create_clip operation.
//
// Creates a new segment in dubbing resource with a start and end time for the speaker in every
// available language. Does not automatically generate transcripts/translations/audio.
//
// POST /v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/segment
func (c *Client) CreateClip(ctx context.Context, request *SegmentCreatePayload, params CreateClipParams) (CreateClipRes, error) {
	res, err := c.sendCreateClip(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateClip(ctx context.Context, request *SegmentCreatePayload, params CreateClipParams) (res CreateClipRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_clip"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/segment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateClipOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/speaker/"
	{
		// Encode "speaker_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "speaker_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SpeakerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/segment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateClipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDubbing invokes create_dubbing operation.
//
// Dubs a provided audio or video file into given language.
//
// POST /v1/dubbing
func (c *Client) CreateDubbing(ctx context.Context, request OptBodyDubAVideoOrAnAudioFileV1DubbingPostMultipart, params CreateDubbingParams) (CreateDubbingRes, error) {
	res, err := c.sendCreateDubbing(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDubbing(ctx context.Context, request OptBodyDubAVideoOrAnAudioFileV1DubbingPostMultipart, params CreateDubbingParams) (res CreateDubbingRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_dubbing"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateDubbingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/dubbing"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDubbingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateDubbingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFileDocumentRoute invokes create_file_document_route operation.
//
// Create a knowledge base document generated form the uploaded file.
//
// POST /v1/convai/knowledge-base/file
func (c *Client) CreateFileDocumentRoute(ctx context.Context, request *BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostMultipart, params CreateFileDocumentRouteParams) (CreateFileDocumentRouteRes, error) {
	res, err := c.sendCreateFileDocumentRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateFileDocumentRoute(ctx context.Context, request *BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostMultipart, params CreateFileDocumentRouteParams) (res CreateFileDocumentRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_file_document_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/file"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateFileDocumentRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base/file"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFileDocumentRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateFileDocumentRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePvcVoice invokes create_pvc_voice operation.
//
// Creates a new PVC voice with metadata but no samples.
//
// POST /v1/voices/pvc
func (c *Client) CreatePvcVoice(ctx context.Context, request *BodyCreatePVCVoiceV1VoicesPvcPost, params CreatePvcVoiceParams) (CreatePvcVoiceRes, error) {
	res, err := c.sendCreatePvcVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendCreatePvcVoice(ctx context.Context, request *BodyCreatePVCVoiceV1VoicesPvcPost, params CreatePvcVoiceParams) (res CreatePvcVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_pvc_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreatePvcVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voices/pvc"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePvcVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreatePvcVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSecretRoute invokes create_secret_route operation.
//
// Create a new secret for the workspace.
//
// POST /v1/convai/secrets
func (c *Client) CreateSecretRoute(ctx context.Context, request *PostWorkspaceSecretRequest, params CreateSecretRouteParams) (CreateSecretRouteRes, error) {
	res, err := c.sendCreateSecretRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateSecretRoute(ctx context.Context, request *PostWorkspaceSecretRequest, params CreateSecretRouteParams) (res CreateSecretRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_secret_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/secrets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateSecretRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSecretRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSecretRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateServiceAccountAPIKey invokes create_service_account_api_key operation.
//
// Create a new API key for a service account.
//
// POST /v1/service-accounts/{service_account_user_id}/api-keys
func (c *Client) CreateServiceAccountAPIKey(ctx context.Context, request *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost, params CreateServiceAccountAPIKeyParams) (CreateServiceAccountAPIKeyRes, error) {
	res, err := c.sendCreateServiceAccountAPIKey(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateServiceAccountAPIKey(ctx context.Context, request *BodyCreateServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysPost, params CreateServiceAccountAPIKeyParams) (res CreateServiceAccountAPIKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_service_account_api_key"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/service-accounts/{service_account_user_id}/api-keys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateServiceAccountAPIKeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/service-accounts/"
	{
		// Encode "service_account_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_account_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceAccountUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateServiceAccountAPIKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateServiceAccountAPIKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSpeaker invokes create_speaker operation.
//
// Create A New Speaker.
//
// POST /v1/dubbing/resource/{dubbing_id}/speaker
func (c *Client) CreateSpeaker(ctx context.Context, request OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost, params CreateSpeakerParams) (CreateSpeakerRes, error) {
	res, err := c.sendCreateSpeaker(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateSpeaker(ctx context.Context, request OptBodyCreateANewSpeakerV1DubbingResourceDubbingIDSpeakerPost, params CreateSpeakerParams) (res CreateSpeakerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_speaker"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/speaker"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateSpeakerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/speaker"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSpeakerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateSpeakerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTextDocumentRoute invokes create_text_document_route operation.
//
// Create a knowledge base document containing the provided text.
//
// POST /v1/convai/knowledge-base/text
func (c *Client) CreateTextDocumentRoute(ctx context.Context, request *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost, params CreateTextDocumentRouteParams) (CreateTextDocumentRouteRes, error) {
	res, err := c.sendCreateTextDocumentRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateTextDocumentRoute(ctx context.Context, request *BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost, params CreateTextDocumentRouteParams) (res CreateTextDocumentRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_text_document_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/text"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateTextDocumentRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base/text"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTextDocumentRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTextDocumentRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateURLDocumentRoute invokes create_url_document_route operation.
//
// Create a knowledge base document generated by scraping the given webpage.
//
// POST /v1/convai/knowledge-base/url
func (c *Client) CreateURLDocumentRoute(ctx context.Context, request *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost, params CreateURLDocumentRouteParams) (CreateURLDocumentRouteRes, error) {
	res, err := c.sendCreateURLDocumentRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateURLDocumentRoute(ctx context.Context, request *BodyCreateURLDocumentV1ConvaiKnowledgeBaseURLPost, params CreateURLDocumentRouteParams) (res CreateURLDocumentRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_url_document_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/url"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateURLDocumentRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base/url"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateURLDocumentRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateURLDocumentRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVoice invokes create_voice operation.
//
// Create a voice from previously generated voice preview. This endpoint should be called after you
// fetched a generated_voice_id using POST /v1/text-to-voice/design or POST
// /v1/text-to-voice/:voice_id/remix.
//
// POST /v1/text-to-voice
func (c *Client) CreateVoice(ctx context.Context, request *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost, params CreateVoiceParams) (CreateVoiceRes, error) {
	res, err := c.sendCreateVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVoice(ctx context.Context, request *BodyCreateANewVoiceFromVoicePreviewV1TextToVoicePost, params CreateVoiceParams) (res CreateVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-voice"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-voice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVoiceOld invokes create_voice_old operation.
//
// Create a previously generated voice. This endpoint should be called after you fetched a
// generated_voice_id using /v1/voice-generation/generate-voice.
//
// POST /v1/voice-generation/create-voice
func (c *Client) CreateVoiceOld(ctx context.Context, request *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost, params CreateVoiceOldParams) (CreateVoiceOldRes, error) {
	res, err := c.sendCreateVoiceOld(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVoiceOld(ctx context.Context, request *BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost, params CreateVoiceOldParams) (res CreateVoiceOldRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_voice_old"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voice-generation/create-voice"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateVoiceOldOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voice-generation/create-voice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVoiceOldRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateVoiceOldResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateWorkspaceWebhookRoute invokes create_workspace_webhook_route operation.
//
// Create a new webhook for the workspace with the specified authentication type.
//
// POST /v1/workspace/webhooks
func (c *Client) CreateWorkspaceWebhookRoute(ctx context.Context, request *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost, params CreateWorkspaceWebhookRouteParams) (CreateWorkspaceWebhookRouteRes, error) {
	res, err := c.sendCreateWorkspaceWebhookRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateWorkspaceWebhookRoute(ctx context.Context, request *BodyCreateWorkspaceWebhookV1WorkspaceWebhooksPost, params CreateWorkspaceWebhookRouteParams) (res CreateWorkspaceWebhookRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_workspace_webhook_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/webhooks"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateWorkspaceWebhookRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/webhooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateWorkspaceWebhookRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateWorkspaceWebhookRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAgentRoute invokes delete_agent_route operation.
//
// Delete an agent.
//
// DELETE /v1/convai/agents/{agent_id}
func (c *Client) DeleteAgentRoute(ctx context.Context, params DeleteAgentRouteParams) (DeleteAgentRouteRes, error) {
	res, err := c.sendDeleteAgentRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAgentRoute(ctx context.Context, params DeleteAgentRouteParams) (res DeleteAgentRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_agent_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/agents/{agent_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteAgentRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/agents/"
	{
		// Encode "agent_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agent_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteAgentRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChapterEndpoint invokes delete_chapter_endpoint operation.
//
// Deletes a chapter.
//
// DELETE /v1/studio/projects/{project_id}/chapters/{chapter_id}
func (c *Client) DeleteChapterEndpoint(ctx context.Context, params DeleteChapterEndpointParams) (DeleteChapterEndpointRes, error) {
	res, err := c.sendDeleteChapterEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendDeleteChapterEndpoint(ctx context.Context, params DeleteChapterEndpointParams) (res DeleteChapterEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_chapter_endpoint"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/chapters/{chapter_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChapterEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chapters/"
	{
		// Encode "chapter_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChapterEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatResponseTestRoute invokes delete_chat_response_test_route operation.
//
// Deletes an agent response test by ID.
//
// DELETE /v1/convai/agent-testing/{test_id}
func (c *Client) DeleteChatResponseTestRoute(ctx context.Context, params DeleteChatResponseTestRouteParams) (DeleteChatResponseTestRouteRes, error) {
	res, err := c.sendDeleteChatResponseTestRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteChatResponseTestRoute(ctx context.Context, params DeleteChatResponseTestRouteParams) (res DeleteChatResponseTestRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_chat_response_test_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/agent-testing/{test_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChatResponseTestRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/agent-testing/"
	{
		// Encode "test_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "test_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TestID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChatResponseTestRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteConversationRoute invokes delete_conversation_route operation.
//
// Delete a particular conversation.
//
// DELETE /v1/convai/conversations/{conversation_id}
func (c *Client) DeleteConversationRoute(ctx context.Context, params DeleteConversationRouteParams) (DeleteConversationRouteRes, error) {
	res, err := c.sendDeleteConversationRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteConversationRoute(ctx context.Context, params DeleteConversationRouteParams) (res DeleteConversationRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_conversation_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/conversations/{conversation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteConversationRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/conversations/"
	{
		// Encode "conversation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conversation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConversationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteConversationRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDubbing invokes delete_dubbing operation.
//
// Deletes a dubbing project.
//
// DELETE /v1/dubbing/{dubbing_id}
func (c *Client) DeleteDubbing(ctx context.Context, params DeleteDubbingParams) (DeleteDubbingRes, error) {
	res, err := c.sendDeleteDubbing(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDubbing(ctx context.Context, params DeleteDubbingParams) (res DeleteDubbingRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_dubbing"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/dubbing/{dubbing_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteDubbingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/dubbing/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteDubbingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteInvite invokes delete_invite operation.
//
// Invalidates an existing email invitation. The invitation will still show up in the inbox it has
// been delivered to, but activating it to join the workspace won't work. This endpoint may only be
// called by workspace administrators.
//
// DELETE /v1/workspace/invites
func (c *Client) DeleteInvite(ctx context.Context, request *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete, params DeleteInviteParams) (DeleteInviteRes, error) {
	res, err := c.sendDeleteInvite(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteInvite(ctx context.Context, request *BodyDeleteExistingInvitationV1WorkspaceInvitesDelete, params DeleteInviteParams) (res DeleteInviteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_invite"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/workspace/invites"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteInviteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/invites"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteInviteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteInviteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteKnowledgeBaseDocument invokes delete_knowledge_base_document operation.
//
// Delete a document from the knowledge base.
//
// DELETE /v1/convai/knowledge-base/{documentation_id}
func (c *Client) DeleteKnowledgeBaseDocument(ctx context.Context, params DeleteKnowledgeBaseDocumentParams) (DeleteKnowledgeBaseDocumentRes, error) {
	res, err := c.sendDeleteKnowledgeBaseDocument(ctx, params)
	return res, err
}

func (c *Client) sendDeleteKnowledgeBaseDocument(ctx context.Context, params DeleteKnowledgeBaseDocumentParams) (res DeleteKnowledgeBaseDocumentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_knowledge_base_document"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteKnowledgeBaseDocumentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "force" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "force",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Force.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteKnowledgeBaseDocumentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMcpServerRoute invokes delete_mcp_server_route operation.
//
// Delete a specific MCP server configuration from the workspace.
//
// DELETE /v1/convai/mcp-servers/{mcp_server_id}
func (c *Client) DeleteMcpServerRoute(ctx context.Context, params DeleteMcpServerRouteParams) (DeleteMcpServerRouteRes, error) {
	res, err := c.sendDeleteMcpServerRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteMcpServerRoute(ctx context.Context, params DeleteMcpServerRouteParams) (res DeleteMcpServerRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_mcp_server_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/mcp-servers/{mcp_server_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteMcpServerRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/mcp-servers/"
	{
		// Encode "mcp_server_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcp_server_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.McpServerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMcpServerRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePhoneNumberRoute invokes delete_phone_number_route operation.
//
// Delete Phone Number by ID.
//
// DELETE /v1/convai/phone-numbers/{phone_number_id}
func (c *Client) DeletePhoneNumberRoute(ctx context.Context, params DeletePhoneNumberRouteParams) (DeletePhoneNumberRouteRes, error) {
	res, err := c.sendDeletePhoneNumberRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeletePhoneNumberRoute(ctx context.Context, params DeletePhoneNumberRouteParams) (res DeletePhoneNumberRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_phone_number_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/phone-numbers/{phone_number_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeletePhoneNumberRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/phone-numbers/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePhoneNumberRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProject invokes delete_project operation.
//
// Deletes a Studio project.
//
// DELETE /v1/studio/projects/{project_id}
func (c *Client) DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error) {
	res, err := c.sendDeleteProject(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProject(ctx context.Context, params DeleteProjectParams) (res DeleteProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_project"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePvcVoiceSample invokes delete_pvc_voice_sample operation.
//
// Delete a sample from a PVC voice.
//
// DELETE /v1/voices/pvc/{voice_id}/samples/{sample_id}
func (c *Client) DeletePvcVoiceSample(ctx context.Context, params DeletePvcVoiceSampleParams) (DeletePvcVoiceSampleRes, error) {
	res, err := c.sendDeletePvcVoiceSample(ctx, params)
	return res, err
}

func (c *Client) sendDeletePvcVoiceSample(ctx context.Context, params DeletePvcVoiceSampleParams) (res DeletePvcVoiceSampleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_pvc_voice_sample"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeletePvcVoiceSampleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePvcVoiceSampleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRagIndex invokes delete_rag_index operation.
//
// Delete RAG index for the knowledgebase document.
//
// DELETE /v1/convai/knowledge-base/{documentation_id}/rag-index/{rag_index_id}
func (c *Client) DeleteRagIndex(ctx context.Context, params DeleteRagIndexParams) (DeleteRagIndexRes, error) {
	res, err := c.sendDeleteRagIndex(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRagIndex(ctx context.Context, params DeleteRagIndexParams) (res DeleteRagIndexRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_rag_index"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}/rag-index/{rag_index_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteRagIndexOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rag-index/"
	{
		// Encode "rag_index_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "rag_index_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RagIndexID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteRagIndexResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSample invokes delete_sample operation.
//
// Removes a sample by its ID.
//
// DELETE /v1/voices/{voice_id}/samples/{sample_id}
func (c *Client) DeleteSample(ctx context.Context, params DeleteSampleParams) (DeleteSampleRes, error) {
	res, err := c.sendDeleteSample(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSample(ctx context.Context, params DeleteSampleParams) (res DeleteSampleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_sample"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}/samples/{sample_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSampleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSampleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSecretRoute invokes delete_secret_route operation.
//
// Delete a workspace secret if it's not in use.
//
// DELETE /v1/convai/secrets/{secret_id}
func (c *Client) DeleteSecretRoute(ctx context.Context, params DeleteSecretRouteParams) (DeleteSecretRouteRes, error) {
	res, err := c.sendDeleteSecretRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSecretRoute(ctx context.Context, params DeleteSecretRouteParams) (res DeleteSecretRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_secret_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/secrets/{secret_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSecretRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/secrets/"
	{
		// Encode "secret_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSecretRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSegment invokes delete_segment operation.
//
// Deletes a single segment from the dubbing.
//
// DELETE /v1/dubbing/resource/{dubbing_id}/segment/{segment_id}
func (c *Client) DeleteSegment(ctx context.Context, params DeleteSegmentParams) (DeleteSegmentRes, error) {
	res, err := c.sendDeleteSegment(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSegment(ctx context.Context, params DeleteSegmentParams) (res DeleteSegmentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_segment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/segment/{segment_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSegmentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/segment/"
	{
		// Encode "segment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "segment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SegmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSegmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteServiceAccountAPIKey invokes delete_service_account_api_key operation.
//
// Delete an existing API key for a service account.
//
// DELETE /v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}
func (c *Client) DeleteServiceAccountAPIKey(ctx context.Context, params DeleteServiceAccountAPIKeyParams) (DeleteServiceAccountAPIKeyRes, error) {
	res, err := c.sendDeleteServiceAccountAPIKey(ctx, params)
	return res, err
}

func (c *Client) sendDeleteServiceAccountAPIKey(ctx context.Context, params DeleteServiceAccountAPIKeyParams) (res DeleteServiceAccountAPIKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_service_account_api_key"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteServiceAccountAPIKeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/service-accounts/"
	{
		// Encode "service_account_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_account_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceAccountUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/api-keys/"
	{
		// Encode "api_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "api_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.APIKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteServiceAccountAPIKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteSpeechHistoryItem invokes delete_speech_history_item operation.
//
// Delete a history item by its ID.
//
// DELETE /v1/history/{history_item_id}
func (c *Client) DeleteSpeechHistoryItem(ctx context.Context, params DeleteSpeechHistoryItemParams) (DeleteSpeechHistoryItemRes, error) {
	res, err := c.sendDeleteSpeechHistoryItem(ctx, params)
	return res, err
}

func (c *Client) sendDeleteSpeechHistoryItem(ctx context.Context, params DeleteSpeechHistoryItemParams) (res DeleteSpeechHistoryItemRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_speech_history_item"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/history/{history_item_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteSpeechHistoryItemOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/history/"
	{
		// Encode "history_item_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "history_item_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.HistoryItemID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteSpeechHistoryItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteToolRoute invokes delete_tool_route operation.
//
// Delete tool from the workspace.
//
// DELETE /v1/convai/tools/{tool_id}
func (c *Client) DeleteToolRoute(ctx context.Context, params DeleteToolRouteParams) (DeleteToolRouteRes, error) {
	res, err := c.sendDeleteToolRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteToolRoute(ctx context.Context, params DeleteToolRouteParams) (res DeleteToolRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_tool_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/tools/{tool_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteToolRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/tools/"
	{
		// Encode "tool_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tool_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ToolID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteToolRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTranscriptByID invokes delete_transcript_by_id operation.
//
// Delete a previously generated transcript by its ID.
//
// DELETE /v1/speech-to-text/transcripts/{transcription_id}
func (c *Client) DeleteTranscriptByID(ctx context.Context, params DeleteTranscriptByIDParams) (DeleteTranscriptByIDRes, error) {
	res, err := c.sendDeleteTranscriptByID(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTranscriptByID(ctx context.Context, params DeleteTranscriptByIDParams) (res DeleteTranscriptByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_transcript_by_id"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/speech-to-text/transcripts/{transcription_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTranscriptByIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/speech-to-text/transcripts/"
	{
		// Encode "transcription_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transcription_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TranscriptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTranscriptByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVoice invokes delete_voice operation.
//
// Deletes a voice by its ID.
//
// DELETE /v1/voices/{voice_id}
func (c *Client) DeleteVoice(ctx context.Context, params DeleteVoiceParams) (DeleteVoiceRes, error) {
	res, err := c.sendDeleteVoice(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVoice(ctx context.Context, params DeleteVoiceParams) (res DeleteVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_voice"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWhatsappAccount invokes delete_whatsapp_account operation.
//
// Delete a WhatsApp account.
//
// DELETE /v1/convai/whatsapp-accounts/{phone_number_id}
func (c *Client) DeleteWhatsappAccount(ctx context.Context, params DeleteWhatsappAccountParams) (DeleteWhatsappAccountRes, error) {
	res, err := c.sendDeleteWhatsappAccount(ctx, params)
	return res, err
}

func (c *Client) sendDeleteWhatsappAccount(ctx context.Context, params DeleteWhatsappAccountParams) (res DeleteWhatsappAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_whatsapp_account"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/convai/whatsapp-accounts/{phone_number_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteWhatsappAccountOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/whatsapp-accounts/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteWhatsappAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWorkspaceWebhookRoute invokes delete_workspace_webhook_route operation.
//
// Delete the specified workspace webhook.
//
// DELETE /v1/workspace/webhooks/{webhook_id}
func (c *Client) DeleteWorkspaceWebhookRoute(ctx context.Context, params DeleteWorkspaceWebhookRouteParams) (DeleteWorkspaceWebhookRouteRes, error) {
	res, err := c.sendDeleteWorkspaceWebhookRoute(ctx, params)
	return res, err
}

func (c *Client) sendDeleteWorkspaceWebhookRoute(ctx context.Context, params DeleteWorkspaceWebhookRouteParams) (res DeleteWorkspaceWebhookRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_workspace_webhook_route"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/v1/workspace/webhooks/{webhook_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteWorkspaceWebhookRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/workspace/webhooks/"
	{
		// Encode "webhook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WebhookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteWorkspaceWebhookRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DownloadSpeechHistoryItems invokes download_speech_history_items operation.
//
// Download one or more history items. If one history item ID is provided, we will return a single
// audio file. If more than one history item IDs are provided, we will provide the history items
// packed into a .zip file.
//
// POST /v1/history/download
func (c *Client) DownloadSpeechHistoryItems(ctx context.Context, request *BodyDownloadHistoryItemsV1HistoryDownloadPost, params DownloadSpeechHistoryItemsParams) (DownloadSpeechHistoryItemsRes, error) {
	res, err := c.sendDownloadSpeechHistoryItems(ctx, request, params)
	return res, err
}

func (c *Client) sendDownloadSpeechHistoryItems(ctx context.Context, request *BodyDownloadHistoryItemsV1HistoryDownloadPost, params DownloadSpeechHistoryItemsParams) (res DownloadSpeechHistoryItemsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("download_speech_history_items"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/history/download"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DownloadSpeechHistoryItemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/history/download"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDownloadSpeechHistoryItemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDownloadSpeechHistoryItemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Dub invokes dub operation.
//
// Regenerate the dubs for either the entire resource or the specified segments/languages. Will
// automatically transcribe and translate any missing transcriptions and translations.
//
// POST /v1/dubbing/resource/{dubbing_id}/dub
func (c *Client) Dub(ctx context.Context, request *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost, params DubParams) (DubRes, error) {
	res, err := c.sendDub(ctx, request, params)
	return res, err
}

func (c *Client) sendDub(ctx context.Context, request *BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDDubPost, params DubParams) (res DubRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("dub"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/dub"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DubOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dub"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDubRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDubResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DuplicateAgentRoute invokes duplicate_agent_route operation.
//
// Create a new agent by duplicating an existing one.
//
// POST /v1/convai/agents/{agent_id}/duplicate
func (c *Client) DuplicateAgentRoute(ctx context.Context, request OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost, params DuplicateAgentRouteParams) (DuplicateAgentRouteRes, error) {
	res, err := c.sendDuplicateAgentRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendDuplicateAgentRoute(ctx context.Context, request OptBodyDuplicateAgentV1ConvaiAgentsAgentIDDuplicatePost, params DuplicateAgentRouteParams) (res DuplicateAgentRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("duplicate_agent_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/agents/{agent_id}/duplicate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DuplicateAgentRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/agents/"
	{
		// Encode "agent_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agent_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/duplicate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDuplicateAgentRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDuplicateAgentRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditProject invokes edit_project operation.
//
// Updates the specified Studio project by setting the values of the parameters passed.
//
// POST /v1/studio/projects/{project_id}
func (c *Client) EditProject(ctx context.Context, request *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost, params EditProjectParams) (EditProjectRes, error) {
	res, err := c.sendEditProject(ctx, request, params)
	return res, err
}

func (c *Client) sendEditProject(ctx context.Context, request *BodyUpdateStudioProjectV1StudioProjectsProjectIDPost, params EditProjectParams) (res EditProjectRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_project"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditProjectOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditProjectContent invokes edit_project_content operation.
//
// Updates Studio project content.
//
// POST /v1/studio/projects/{project_id}/content
func (c *Client) EditProjectContent(ctx context.Context, request OptBodyUpdateStudioProjectContentV1StudioProjectsProjectIDContentPostMultipart, params EditProjectContentParams) (EditProjectContentRes, error) {
	res, err := c.sendEditProjectContent(ctx, request, params)
	return res, err
}

func (c *Client) sendEditProjectContent(ctx context.Context, request OptBodyUpdateStudioProjectContentV1StudioProjectsProjectIDContentPostMultipart, params EditProjectContentParams) (res EditProjectContentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_project_content"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/content"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditProjectContentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/content"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditProjectContentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditProjectContentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditPvcVoice invokes edit_pvc_voice operation.
//
// Edit PVC voice metadata.
//
// POST /v1/voices/pvc/{voice_id}
func (c *Client) EditPvcVoice(ctx context.Context, request OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost, params EditPvcVoiceParams) (EditPvcVoiceRes, error) {
	res, err := c.sendEditPvcVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendEditPvcVoice(ctx context.Context, request OptBodyEditPVCVoiceV1VoicesPvcVoiceIDPost, params EditPvcVoiceParams) (res EditPvcVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_pvc_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditPvcVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditPvcVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditPvcVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditPvcVoiceSample invokes edit_pvc_voice_sample operation.
//
// Update a PVC voice sample - apply noise removal, select speaker, change trim times or file name.
//
// POST /v1/voices/pvc/{voice_id}/samples/{sample_id}
func (c *Client) EditPvcVoiceSample(ctx context.Context, request OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost, params EditPvcVoiceSampleParams) (EditPvcVoiceSampleRes, error) {
	res, err := c.sendEditPvcVoiceSample(ctx, request, params)
	return res, err
}

func (c *Client) sendEditPvcVoiceSample(ctx context.Context, request OptBodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIDSamplesSampleIDPost, params EditPvcVoiceSampleParams) (res EditPvcVoiceSampleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_pvc_voice_sample"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditPvcVoiceSampleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditPvcVoiceSampleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditPvcVoiceSampleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditServiceAccountAPIKey invokes edit_service_account_api_key operation.
//
// Update an existing API key for a service account.
//
// PATCH /v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}
func (c *Client) EditServiceAccountAPIKey(ctx context.Context, request *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch, params EditServiceAccountAPIKeyParams) (EditServiceAccountAPIKeyRes, error) {
	res, err := c.sendEditServiceAccountAPIKey(ctx, request, params)
	return res, err
}

func (c *Client) sendEditServiceAccountAPIKey(ctx context.Context, request *BodyEditServiceAccountAPIKeyV1ServiceAccountsServiceAccountUserIDAPIKeysAPIKeyIDPatch, params EditServiceAccountAPIKeyParams) (res EditServiceAccountAPIKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_service_account_api_key"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditServiceAccountAPIKeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/service-accounts/"
	{
		// Encode "service_account_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_account_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceAccountUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/api-keys/"
	{
		// Encode "api_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "api_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.APIKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditServiceAccountAPIKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditServiceAccountAPIKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditVoice invokes edit_voice operation.
//
// Edit a voice created by you.
//
// POST /v1/voices/{voice_id}/edit
func (c *Client) EditVoice(ctx context.Context, request *BodyEditVoiceV1VoicesVoiceIDEditPostMultipart, params EditVoiceParams) (EditVoiceRes, error) {
	res, err := c.sendEditVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendEditVoice(ctx context.Context, request *BodyEditVoiceV1VoicesVoiceIDEditPostMultipart, params EditVoiceParams) (res EditVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}/edit"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/edit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditVoiceSettings invokes edit_voice_settings operation.
//
// Edit your settings for a specific voice. "similarity_boost" corresponds to "Clarity + Similarity
// Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
//
// POST /v1/voices/{voice_id}/settings/edit
func (c *Client) EditVoiceSettings(ctx context.Context, request *VoiceSettingsResponseModel, params EditVoiceSettingsParams) (EditVoiceSettingsRes, error) {
	res, err := c.sendEditVoiceSettings(ctx, request, params)
	return res, err
}

func (c *Client) sendEditVoiceSettings(ctx context.Context, request *VoiceSettingsResponseModel, params EditVoiceSettingsParams) (res EditVoiceSettingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_voice_settings"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}/settings/edit"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditVoiceSettingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings/edit"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditVoiceSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditVoiceSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditWorkspaceWebhookRoute invokes edit_workspace_webhook_route operation.
//
// Update the specified workspace webhook.
//
// PATCH /v1/workspace/webhooks/{webhook_id}
func (c *Client) EditWorkspaceWebhookRoute(ctx context.Context, request *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch, params EditWorkspaceWebhookRouteParams) (EditWorkspaceWebhookRouteRes, error) {
	res, err := c.sendEditWorkspaceWebhookRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendEditWorkspaceWebhookRoute(ctx context.Context, request *BodyUpdateWorkspaceWebhookV1WorkspaceWebhooksWebhookIDPatch, params EditWorkspaceWebhookRouteParams) (res EditWorkspaceWebhookRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("edit_workspace_webhook_route"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/workspace/webhooks/{webhook_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, EditWorkspaceWebhookRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/workspace/webhooks/"
	{
		// Encode "webhook_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhook_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WebhookID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditWorkspaceWebhookRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeEditWorkspaceWebhookRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ForcedAlignment invokes forced_alignment operation.
//
// Force align an audio file to text. Use this endpoint to get the timing information for each
// character and word in an audio file based on a provided text transcript.
//
// POST /v1/forced-alignment
func (c *Client) ForcedAlignment(ctx context.Context, request *BodyCreateForcedAlignmentV1ForcedAlignmentPostMultipart, params ForcedAlignmentParams) (ForcedAlignmentRes, error) {
	res, err := c.sendForcedAlignment(ctx, request, params)
	return res, err
}

func (c *Client) sendForcedAlignment(ctx context.Context, request *BodyCreateForcedAlignmentV1ForcedAlignmentPostMultipart, params ForcedAlignmentParams) (res ForcedAlignmentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("forced_alignment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/forced-alignment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ForcedAlignmentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/forced-alignment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeForcedAlignmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeForcedAlignmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Generate invokes generate operation.
//
// Compose a song from a prompt or a composition plan.
//
// POST /v1/music
func (c *Client) Generate(ctx context.Context, request OptBodyComposeMusicV1MusicPost, params GenerateParams) (GenerateRes, error) {
	res, err := c.sendGenerate(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerate(ctx context.Context, request OptBodyComposeMusicV1MusicPost, params GenerateParams) (res GenerateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/music"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GenerateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/music"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateRandomVoice invokes generate_random_voice operation.
//
// Generate a random voice based on parameters. This method returns a generated_voice_id in the
// response header, and a sample of the voice in the body. If you like the generated voice call
// /v1/voice-generation/create-voice with the generated_voice_id to create the voice.
//
// POST /v1/voice-generation/generate-voice
func (c *Client) GenerateRandomVoice(ctx context.Context, request *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost, params GenerateRandomVoiceParams) (GenerateRandomVoiceRes, error) {
	res, err := c.sendGenerateRandomVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerateRandomVoice(ctx context.Context, request *BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost, params GenerateRandomVoiceParams) (res GenerateRandomVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("generate_random_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voice-generation/generate-voice"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GenerateRandomVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voice-generation/generate-voice"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateRandomVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGenerateRandomVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentKnowledgeBaseSize invokes get_agent_knowledge_base_size operation.
//
// Returns the number of pages in the agent's knowledge base.
//
// GET /v1/convai/agent/{agent_id}/knowledge-base/size
func (c *Client) GetAgentKnowledgeBaseSize(ctx context.Context, params GetAgentKnowledgeBaseSizeParams) (GetAgentKnowledgeBaseSizeRes, error) {
	res, err := c.sendGetAgentKnowledgeBaseSize(ctx, params)
	return res, err
}

func (c *Client) sendGetAgentKnowledgeBaseSize(ctx context.Context, params GetAgentKnowledgeBaseSizeParams) (res GetAgentKnowledgeBaseSizeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agent_knowledge_base_size"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/agent/{agent_id}/knowledge-base/size"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentKnowledgeBaseSizeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/agent/"
	{
		// Encode "agent_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agent_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/knowledge-base/size"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentKnowledgeBaseSizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentKnowledgeBaseSummariesRoute invokes get_agent_knowledge_base_summaries_route operation.
//
// Gets multiple knowledge base document summaries by their IDs.
//
// GET /v1/convai/knowledge-base/summaries
func (c *Client) GetAgentKnowledgeBaseSummariesRoute(ctx context.Context, params GetAgentKnowledgeBaseSummariesRouteParams) (GetAgentKnowledgeBaseSummariesRouteRes, error) {
	res, err := c.sendGetAgentKnowledgeBaseSummariesRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetAgentKnowledgeBaseSummariesRoute(ctx context.Context, params GetAgentKnowledgeBaseSummariesRouteParams) (res GetAgentKnowledgeBaseSummariesRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agent_knowledge_base_summaries_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/summaries"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentKnowledgeBaseSummariesRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base/summaries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "document_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "document_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.DocumentIds {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentKnowledgeBaseSummariesRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentLinkRoute invokes get_agent_link_route operation.
//
// Get the current link used to share the agent with others.
//
// GET /v1/convai/agents/{agent_id}/link
func (c *Client) GetAgentLinkRoute(ctx context.Context, params GetAgentLinkRouteParams) (GetAgentLinkRouteRes, error) {
	res, err := c.sendGetAgentLinkRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetAgentLinkRoute(ctx context.Context, params GetAgentLinkRouteParams) (res GetAgentLinkRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agent_link_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/agents/{agent_id}/link"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentLinkRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/agents/"
	{
		// Encode "agent_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agent_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/link"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentLinkRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentLlmExpectedCostCalculation invokes get_agent_llm_expected_cost_calculation operation.
//
// Calculates expected number of LLM tokens needed for the specified agent.
//
// POST /v1/convai/agent/{agent_id}/llm-usage/calculate
func (c *Client) GetAgentLlmExpectedCostCalculation(ctx context.Context, request *LLMUsageCalculatorRequestModel, params GetAgentLlmExpectedCostCalculationParams) (GetAgentLlmExpectedCostCalculationRes, error) {
	res, err := c.sendGetAgentLlmExpectedCostCalculation(ctx, request, params)
	return res, err
}

func (c *Client) sendGetAgentLlmExpectedCostCalculation(ctx context.Context, request *LLMUsageCalculatorRequestModel, params GetAgentLlmExpectedCostCalculationParams) (res GetAgentLlmExpectedCostCalculationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agent_llm_expected_cost_calculation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/agent/{agent_id}/llm-usage/calculate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentLlmExpectedCostCalculationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/agent/"
	{
		// Encode "agent_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agent_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/llm-usage/calculate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetAgentLlmExpectedCostCalculationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentLlmExpectedCostCalculationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentResponseTestRoute invokes get_agent_response_test_route operation.
//
// Gets an agent response test by ID.
//
// GET /v1/convai/agent-testing/{test_id}
func (c *Client) GetAgentResponseTestRoute(ctx context.Context, params GetAgentResponseTestRouteParams) (GetAgentResponseTestRouteRes, error) {
	res, err := c.sendGetAgentResponseTestRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetAgentResponseTestRoute(ctx context.Context, params GetAgentResponseTestRouteParams) (res GetAgentResponseTestRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agent_response_test_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/agent-testing/{test_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentResponseTestRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/agent-testing/"
	{
		// Encode "test_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "test_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TestID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentResponseTestRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentResponseTestsSummariesRoute invokes get_agent_response_tests_summaries_route operation.
//
// Gets multiple agent response tests by their IDs. Returns a dictionary mapping test IDs to test
// summaries.
//
// POST /v1/convai/agent-testing/summaries
func (c *Client) GetAgentResponseTestsSummariesRoute(ctx context.Context, request *ListTestsByIdsRequestModel, params GetAgentResponseTestsSummariesRouteParams) (GetAgentResponseTestsSummariesRouteRes, error) {
	res, err := c.sendGetAgentResponseTestsSummariesRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendGetAgentResponseTestsSummariesRoute(ctx context.Context, request *ListTestsByIdsRequestModel, params GetAgentResponseTestsSummariesRouteParams) (res GetAgentResponseTestsSummariesRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agent_response_tests_summaries_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/agent-testing/summaries"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentResponseTestsSummariesRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/agent-testing/summaries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetAgentResponseTestsSummariesRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentResponseTestsSummariesRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAgentsRoute invokes get_agents_route operation.
//
// Returns a list of your agents and their metadata.
//
// GET /v1/convai/agents
func (c *Client) GetAgentsRoute(ctx context.Context, params GetAgentsRouteParams) (GetAgentsRouteRes, error) {
	res, err := c.sendGetAgentsRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetAgentsRoute(ctx context.Context, params GetAgentsRouteParams) (res GetAgentsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_agents_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/agents"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAgentsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/agents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "archived" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "archived",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Archived.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "show_only_owned_agents" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "show_only_owned_agents",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ShowOnlyOwnedAgents.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAgentsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAudioFromSample invokes get_audio_from_sample operation.
//
// Returns the audio corresponding to a sample attached to a voice.
//
// GET /v1/voices/{voice_id}/samples/{sample_id}/audio
func (c *Client) GetAudioFromSample(ctx context.Context, params GetAudioFromSampleParams) (GetAudioFromSampleRes, error) {
	res, err := c.sendGetAudioFromSample(ctx, params)
	return res, err
}

func (c *Client) sendGetAudioFromSample(ctx context.Context, params GetAudioFromSampleParams) (res GetAudioFromSampleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_audio_from_sample"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}/samples/{sample_id}/audio"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAudioFromSampleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/audio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAudioFromSampleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAudioFullFromSpeechHistoryItem invokes get_audio_full_from_speech_history_item operation.
//
// Returns the audio of an history item.
//
// GET /v1/history/{history_item_id}/audio
func (c *Client) GetAudioFullFromSpeechHistoryItem(ctx context.Context, params GetAudioFullFromSpeechHistoryItemParams) (GetAudioFullFromSpeechHistoryItemRes, error) {
	res, err := c.sendGetAudioFullFromSpeechHistoryItem(ctx, params)
	return res, err
}

func (c *Client) sendGetAudioFullFromSpeechHistoryItem(ctx context.Context, params GetAudioFullFromSpeechHistoryItemParams) (res GetAudioFullFromSpeechHistoryItemRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_audio_full_from_speech_history_item"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/history/{history_item_id}/audio"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAudioFullFromSpeechHistoryItemOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/history/"
	{
		// Encode "history_item_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "history_item_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.HistoryItemID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAudioFullFromSpeechHistoryItemResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAudioNativeProjectSettingsEndpoint invokes get_audio_native_project_settings_endpoint operation.
//
// Get player settings for the specific project.
//
// GET /v1/audio-native/{project_id}/settings
func (c *Client) GetAudioNativeProjectSettingsEndpoint(ctx context.Context, params GetAudioNativeProjectSettingsEndpointParams) (GetAudioNativeProjectSettingsEndpointRes, error) {
	res, err := c.sendGetAudioNativeProjectSettingsEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendGetAudioNativeProjectSettingsEndpoint(ctx context.Context, params GetAudioNativeProjectSettingsEndpointParams) (res GetAudioNativeProjectSettingsEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_audio_native_project_settings_endpoint"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/audio-native/{project_id}/settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAudioNativeProjectSettingsEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/audio-native/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAudioNativeProjectSettingsEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBatchCall invokes get_batch_call operation.
//
// Get detailed information about a batch call including all recipients.
//
// GET /v1/convai/batch-calling/{batch_id}
func (c *Client) GetBatchCall(ctx context.Context, params GetBatchCallParams) (GetBatchCallRes, error) {
	res, err := c.sendGetBatchCall(ctx, params)
	return res, err
}

func (c *Client) sendGetBatchCall(ctx context.Context, params GetBatchCallParams) (res GetBatchCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_batch_call"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/batch-calling/{batch_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetBatchCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/batch-calling/"
	{
		// Encode "batch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "batch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BatchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetBatchCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChapterSnapshotEndpoint invokes get_chapter_snapshot_endpoint operation.
//
// Returns the chapter snapshot.
//
// GET /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}
func (c *Client) GetChapterSnapshotEndpoint(ctx context.Context, params GetChapterSnapshotEndpointParams) (GetChapterSnapshotEndpointRes, error) {
	res, err := c.sendGetChapterSnapshotEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendGetChapterSnapshotEndpoint(ctx context.Context, params GetChapterSnapshotEndpointParams) (res GetChapterSnapshotEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_chapter_snapshot_endpoint"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChapterSnapshotEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chapters/"
	{
		// Encode "chapter_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/snapshots/"
	{
		// Encode "chapter_snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterSnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChapterSnapshotEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChapterSnapshots invokes get_chapter_snapshots operation.
//
// Gets information about all the snapshots of a chapter. Each snapshot can be downloaded as audio.
// Whenever a chapter is converted a snapshot will automatically be created.
//
// GET /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots
func (c *Client) GetChapterSnapshots(ctx context.Context, params GetChapterSnapshotsParams) (GetChapterSnapshotsRes, error) {
	res, err := c.sendGetChapterSnapshots(ctx, params)
	return res, err
}

func (c *Client) sendGetChapterSnapshots(ctx context.Context, params GetChapterSnapshotsParams) (res GetChapterSnapshotsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_chapter_snapshots"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChapterSnapshotsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chapters/"
	{
		// Encode "chapter_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/snapshots"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChapterSnapshotsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChapters invokes get_chapters operation.
//
// Returns a list of a Studio project's chapters.
//
// GET /v1/studio/projects/{project_id}/chapters
func (c *Client) GetChapters(ctx context.Context, params GetChaptersParams) (GetChaptersRes, error) {
	res, err := c.sendGetChapters(ctx, params)
	return res, err
}

func (c *Client) sendGetChapters(ctx context.Context, params GetChaptersParams) (res GetChaptersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_chapters"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/chapters"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChaptersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chapters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChaptersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConversationAudioRoute invokes get_conversation_audio_route operation.
//
// Get the audio recording of a particular conversation.
//
// GET /v1/convai/conversations/{conversation_id}/audio
func (c *Client) GetConversationAudioRoute(ctx context.Context, params GetConversationAudioRouteParams) (GetConversationAudioRouteRes, error) {
	res, err := c.sendGetConversationAudioRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetConversationAudioRoute(ctx context.Context, params GetConversationAudioRouteParams) (res GetConversationAudioRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_conversation_audio_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/conversations/{conversation_id}/audio"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConversationAudioRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/conversations/"
	{
		// Encode "conversation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conversation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConversationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConversationAudioRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConversationHistoriesRoute invokes get_conversation_histories_route operation.
//
// Get all conversations of agents that user owns. With option to restrict to a specific agent.
//
// GET /v1/convai/conversations
func (c *Client) GetConversationHistoriesRoute(ctx context.Context, params GetConversationHistoriesRouteParams) (GetConversationHistoriesRouteRes, error) {
	res, err := c.sendGetConversationHistoriesRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetConversationHistoriesRoute(ctx context.Context, params GetConversationHistoriesRouteParams) (res GetConversationHistoriesRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_conversation_histories_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/conversations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConversationHistoriesRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/conversations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AgentID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_successful" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_successful",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallSuccessful.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_start_before_unix" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_start_before_unix",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallStartBeforeUnix.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_start_after_unix" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_start_after_unix",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallStartAfterUnix.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_duration_min_secs" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_duration_min_secs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallDurationMinSecs.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "call_duration_max_secs" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "call_duration_max_secs",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CallDurationMaxSecs.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "rating_max" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "rating_max",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RatingMax.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "rating_min" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "rating_min",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RatingMin.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "has_feedback_comment" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "has_feedback_comment",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HasFeedbackComment.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "user_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UserID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "evaluation_params" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "evaluation_params",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EvaluationParams.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "data_collection_params" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "data_collection_params",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DataCollectionParams.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tool_names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tool_names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToolNames.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "main_languages" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "main_languages",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MainLanguages.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "summary_mode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "summary_mode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SummaryMode.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConversationHistoriesRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConversationHistoryRoute invokes get_conversation_history_route operation.
//
// Get the details of a particular conversation.
//
// GET /v1/convai/conversations/{conversation_id}
func (c *Client) GetConversationHistoryRoute(ctx context.Context, params GetConversationHistoryRouteParams) (GetConversationHistoryRouteRes, error) {
	res, err := c.sendGetConversationHistoryRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetConversationHistoryRoute(ctx context.Context, params GetConversationHistoryRouteParams) (res GetConversationHistoryRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_conversation_history_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/conversations/{conversation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConversationHistoryRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/conversations/"
	{
		// Encode "conversation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conversation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConversationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConversationHistoryRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConversationSignedLink invokes get_conversation_signed_link operation.
//
// Get a signed url to start a conversation with an agent with an agent that requires authorization.
//
// GET /v1/convai/conversation/get-signed-url
func (c *Client) GetConversationSignedLink(ctx context.Context, params GetConversationSignedLinkParams) (GetConversationSignedLinkRes, error) {
	res, err := c.sendGetConversationSignedLink(ctx, params)
	return res, err
}

func (c *Client) sendGetConversationSignedLink(ctx context.Context, params GetConversationSignedLinkParams) (res GetConversationSignedLinkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_conversation_signed_link"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/conversation/get-signed-url"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConversationSignedLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/conversation/get-signed-url"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_conversation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_conversation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeConversationID.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConversationSignedLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDashboardSettingsRoute invokes get_dashboard_settings_route operation.
//
// Retrieve Convai dashboard settings for the workspace.
//
// GET /v1/convai/settings/dashboard
func (c *Client) GetDashboardSettingsRoute(ctx context.Context, params GetDashboardSettingsRouteParams) (GetDashboardSettingsRouteRes, error) {
	res, err := c.sendGetDashboardSettingsRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetDashboardSettingsRoute(ctx context.Context, params GetDashboardSettingsRouteParams) (res GetDashboardSettingsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_dashboard_settings_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/settings/dashboard"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDashboardSettingsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/settings/dashboard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDashboardSettingsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDocumentationChunkFromKnowledgeBase invokes get_documentation_chunk_from_knowledge_base operation.
//
// Get details about a specific documentation part used by RAG.
//
// GET /v1/convai/knowledge-base/{documentation_id}/chunk/{chunk_id}
func (c *Client) GetDocumentationChunkFromKnowledgeBase(ctx context.Context, params GetDocumentationChunkFromKnowledgeBaseParams) (GetDocumentationChunkFromKnowledgeBaseRes, error) {
	res, err := c.sendGetDocumentationChunkFromKnowledgeBase(ctx, params)
	return res, err
}

func (c *Client) sendGetDocumentationChunkFromKnowledgeBase(ctx context.Context, params GetDocumentationChunkFromKnowledgeBaseParams) (res GetDocumentationChunkFromKnowledgeBaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_documentation_chunk_from_knowledge_base"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}/chunk/{chunk_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDocumentationChunkFromKnowledgeBaseOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chunk/"
	{
		// Encode "chunk_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chunk_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChunkID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDocumentationChunkFromKnowledgeBaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDocumentationFromKnowledgeBase invokes get_documentation_from_knowledge_base operation.
//
// Get details about a specific documentation making up the agent's knowledge base.
//
// GET /v1/convai/knowledge-base/{documentation_id}
func (c *Client) GetDocumentationFromKnowledgeBase(ctx context.Context, params GetDocumentationFromKnowledgeBaseParams) (GetDocumentationFromKnowledgeBaseRes, error) {
	res, err := c.sendGetDocumentationFromKnowledgeBase(ctx, params)
	return res, err
}

func (c *Client) sendGetDocumentationFromKnowledgeBase(ctx context.Context, params GetDocumentationFromKnowledgeBaseParams) (res GetDocumentationFromKnowledgeBaseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_documentation_from_knowledge_base"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDocumentationFromKnowledgeBaseOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AgentID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDocumentationFromKnowledgeBaseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDubbedFile invokes get_dubbed_file operation.
//
// Returns dub as a streamed MP3 or MP4 file. If this dub has been edited using Dubbing Studio you
// need to use the resource render endpoint as this endpoint only returns the original automatic dub
// result.
//
// GET /v1/dubbing/{dubbing_id}/audio/{language_code}
func (c *Client) GetDubbedFile(ctx context.Context, params GetDubbedFileParams) (GetDubbedFileRes, error) {
	res, err := c.sendGetDubbedFile(ctx, params)
	return res, err
}

func (c *Client) sendGetDubbedFile(ctx context.Context, params GetDubbedFileParams) (res GetDubbedFileRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_dubbed_file"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/dubbing/{dubbing_id}/audio/{language_code}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDubbedFileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/dubbing/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/audio/"
	{
		// Encode "language_code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "language_code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LanguageCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDubbedFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDubbedMetadata invokes get_dubbed_metadata operation.
//
// Returns metadata about a dubbing project, including whether it's still in progress or not.
//
// GET /v1/dubbing/{dubbing_id}
func (c *Client) GetDubbedMetadata(ctx context.Context, params GetDubbedMetadataParams) (GetDubbedMetadataRes, error) {
	res, err := c.sendGetDubbedMetadata(ctx, params)
	return res, err
}

func (c *Client) sendGetDubbedMetadata(ctx context.Context, params GetDubbedMetadataParams) (res GetDubbedMetadataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_dubbed_metadata"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/dubbing/{dubbing_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDubbedMetadataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/dubbing/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDubbedMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDubbedTranscriptFile invokes get_dubbed_transcript_file operation.
//
// Returns transcript for the dub as an SRT or WEBVTT file.
//
// GET /v1/dubbing/{dubbing_id}/transcript/{language_code}
func (c *Client) GetDubbedTranscriptFile(ctx context.Context, params GetDubbedTranscriptFileParams) (GetDubbedTranscriptFileRes, error) {
	res, err := c.sendGetDubbedTranscriptFile(ctx, params)
	return res, err
}

func (c *Client) sendGetDubbedTranscriptFile(ctx context.Context, params GetDubbedTranscriptFileParams) (res GetDubbedTranscriptFileRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_dubbed_transcript_file"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/dubbing/{dubbing_id}/transcript/{language_code}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDubbedTranscriptFileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/dubbing/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/transcript/"
	{
		// Encode "language_code" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "language_code",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.LanguageCode))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "format_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "format_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FormatType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDubbedTranscriptFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDubbingResource invokes get_dubbing_resource operation.
//
// Given a dubbing ID generated from the '/v1/dubbing' endpoint with studio enabled, returns the
// dubbing resource.
//
// GET /v1/dubbing/resource/{dubbing_id}
func (c *Client) GetDubbingResource(ctx context.Context, params GetDubbingResourceParams) (GetDubbingResourceRes, error) {
	res, err := c.sendGetDubbingResource(ctx, params)
	return res, err
}

func (c *Client) sendGetDubbingResource(ctx context.Context, params GetDubbingResourceParams) (res GetDubbingResourceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_dubbing_resource"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDubbingResourceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDubbingResourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetGenerateVoiceParameters invokes get_generate_voice_parameters operation.
//
// Get possible parameters for the /v1/voice-generation/generate-voice endpoint.
//
// GET /v1/voice-generation/generate-voice/parameters
func (c *Client) GetGenerateVoiceParameters(ctx context.Context) (*VoiceGenerationParameterResponseModel, error) {
	res, err := c.sendGetGenerateVoiceParameters(ctx)
	return res, err
}

func (c *Client) sendGetGenerateVoiceParameters(ctx context.Context) (res *VoiceGenerationParameterResponseModel, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_generate_voice_parameters"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voice-generation/generate-voice/parameters"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetGenerateVoiceParametersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voice-generation/generate-voice/parameters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetGenerateVoiceParametersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetKnowledgeBaseContent invokes get_knowledge_base_content operation.
//
// Get the entire content of a document from the knowledge base.
//
// GET /v1/convai/knowledge-base/{documentation_id}/content
func (c *Client) GetKnowledgeBaseContent(ctx context.Context, params GetKnowledgeBaseContentParams) (GetKnowledgeBaseContentRes, error) {
	res, err := c.sendGetKnowledgeBaseContent(ctx, params)
	return res, err
}

func (c *Client) sendGetKnowledgeBaseContent(ctx context.Context, params GetKnowledgeBaseContentParams) (res GetKnowledgeBaseContentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_knowledge_base_content"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}/content"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetKnowledgeBaseContentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/content"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetKnowledgeBaseContentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetKnowledgeBaseDependentAgents invokes get_knowledge_base_dependent_agents operation.
//
// Get a list of agents depending on this knowledge base document.
//
// GET /v1/convai/knowledge-base/{documentation_id}/dependent-agents
func (c *Client) GetKnowledgeBaseDependentAgents(ctx context.Context, params GetKnowledgeBaseDependentAgentsParams) (GetKnowledgeBaseDependentAgentsRes, error) {
	res, err := c.sendGetKnowledgeBaseDependentAgents(ctx, params)
	return res, err
}

func (c *Client) sendGetKnowledgeBaseDependentAgents(ctx context.Context, params GetKnowledgeBaseDependentAgentsParams) (res GetKnowledgeBaseDependentAgentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_knowledge_base_dependent_agents"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}/dependent-agents"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetKnowledgeBaseDependentAgentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dependent-agents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "dependent_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dependent_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DependentType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetKnowledgeBaseDependentAgentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetKnowledgeBaseListRoute invokes get_knowledge_base_list_route operation.
//
// Get a list of available knowledge base documents.
//
// GET /v1/convai/knowledge-base
func (c *Client) GetKnowledgeBaseListRoute(ctx context.Context, params GetKnowledgeBaseListRouteParams) (GetKnowledgeBaseListRouteRes, error) {
	res, err := c.sendGetKnowledgeBaseListRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetKnowledgeBaseListRoute(ctx context.Context, params GetKnowledgeBaseListRouteParams) (res GetKnowledgeBaseListRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_knowledge_base_list_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetKnowledgeBaseListRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "show_only_owned_documents" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "show_only_owned_documents",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ShowOnlyOwnedDocuments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "types" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "types",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Types.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(string(item)))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "parent_folder_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "parent_folder_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ParentFolderID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ancestor_folder_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ancestor_folder_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AncestorFolderID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "folders_first" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "folders_first",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FoldersFirst.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "use_typesense" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "use_typesense",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UseTypesense.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetKnowledgeBaseListRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLibraryVoices invokes get_library_voices operation.
//
// Retrieves a list of shared voices.
//
// GET /v1/shared-voices
func (c *Client) GetLibraryVoices(ctx context.Context, params GetLibraryVoicesParams) (GetLibraryVoicesRes, error) {
	res, err := c.sendGetLibraryVoices(ctx, params)
	return res, err
}

func (c *Client) sendGetLibraryVoices(ctx context.Context, params GetLibraryVoicesParams) (res GetLibraryVoicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_library_voices"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/shared-voices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetLibraryVoicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/shared-voices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Category.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "gender" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "gender",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Gender.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "age" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "age",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Age.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "accent" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "accent",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Accent.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "language" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "language",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Language.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "locale" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "locale",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Locale.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "use_cases" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "use_cases",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UseCases.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "descriptives" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "descriptives",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Descriptives.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featured" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Featured.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "min_notice_period_days" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "min_notice_period_days",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MinNoticePeriodDays.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_custom_rates" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_custom_rates",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeCustomRates.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_live_moderated" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_live_moderated",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeLiveModerated.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "reader_app_enabled" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "reader_app_enabled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ReaderAppEnabled.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "owner_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "owner_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OwnerID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLibraryVoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLiveCount invokes get_live_count operation.
//
// Get the live count of the ongoing conversations.
//
// GET /v1/convai/analytics/live-count
func (c *Client) GetLiveCount(ctx context.Context, params GetLiveCountParams) (GetLiveCountRes, error) {
	res, err := c.sendGetLiveCount(ctx, params)
	return res, err
}

func (c *Client) sendGetLiveCount(ctx context.Context, params GetLiveCountParams) (res GetLiveCountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_live_count"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/analytics/live-count"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetLiveCountOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/analytics/live-count"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AgentID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLiveCountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLivekitToken invokes get_livekit_token operation.
//
// Get a WebRTC session token for real-time communication.
//
// GET /v1/convai/conversation/token
func (c *Client) GetLivekitToken(ctx context.Context, params GetLivekitTokenParams) (GetLivekitTokenRes, error) {
	res, err := c.sendGetLivekitToken(ctx, params)
	return res, err
}

func (c *Client) sendGetLivekitToken(ctx context.Context, params GetLivekitTokenParams) (res GetLivekitTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_livekit_token"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/conversation/token"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetLivekitTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/conversation/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "participant_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "participant_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ParticipantName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetLivekitTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMcpToolConfigOverrideRoute invokes get_mcp_tool_config_override_route operation.
//
// Retrieve configuration overrides for a specific MCP tool.
//
// GET /v1/convai/mcp-servers/{mcp_server_id}/tool-configs/{tool_name}
func (c *Client) GetMcpToolConfigOverrideRoute(ctx context.Context, params GetMcpToolConfigOverrideRouteParams) (GetMcpToolConfigOverrideRouteRes, error) {
	res, err := c.sendGetMcpToolConfigOverrideRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetMcpToolConfigOverrideRoute(ctx context.Context, params GetMcpToolConfigOverrideRouteParams) (res GetMcpToolConfigOverrideRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_mcp_tool_config_override_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/mcp-servers/{mcp_server_id}/tool-configs/{tool_name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMcpToolConfigOverrideRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/convai/mcp-servers/"
	{
		// Encode "mcp_server_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcp_server_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.McpServerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tool-configs/"
	{
		// Encode "tool_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tool_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ToolName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMcpToolConfigOverrideRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModels invokes get_models operation.
//
// Gets a list of available models.
//
// GET /v1/models
func (c *Client) GetModels(ctx context.Context, params GetModelsParams) (GetModelsRes, error) {
	res, err := c.sendGetModels(ctx, params)
	return res, err
}

func (c *Client) sendGetModels(ctx context.Context, params GetModelsParams) (res GetModelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_models"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/models"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetModelsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/models"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOrCreateRagIndexes invokes get_or_create_rag_indexes operation.
//
// Retrieves and/or creates RAG indexes for multiple knowledge base documents in a single request.
//
// POST /v1/convai/knowledge-base/rag-index
func (c *Client) GetOrCreateRagIndexes(ctx context.Context, request *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost, params GetOrCreateRagIndexesParams) (GetOrCreateRagIndexesRes, error) {
	res, err := c.sendGetOrCreateRagIndexes(ctx, request, params)
	return res, err
}

func (c *Client) sendGetOrCreateRagIndexes(ctx context.Context, request *BodyComputeRAGIndexesInBatchV1ConvaiKnowledgeBaseRagIndexPost, params GetOrCreateRagIndexesParams) (res GetOrCreateRagIndexesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_or_create_rag_indexes"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/rag-index"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOrCreateRagIndexesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base/rag-index"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetOrCreateRagIndexesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOrCreateRagIndexesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPhoneNumberRoute invokes get_phone_number_route operation.
//
// Retrieve Phone Number details by ID.
//
// GET /v1/convai/phone-numbers/{phone_number_id}
func (c *Client) GetPhoneNumberRoute(ctx context.Context, params GetPhoneNumberRouteParams) (GetPhoneNumberRouteRes, error) {
	res, err := c.sendGetPhoneNumberRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetPhoneNumberRoute(ctx context.Context, params GetPhoneNumberRouteParams) (res GetPhoneNumberRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_phone_number_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/phone-numbers/{phone_number_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPhoneNumberRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/phone-numbers/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPhoneNumberRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectSnapshotEndpoint invokes get_project_snapshot_endpoint operation.
//
// Returns the project snapshot.
//
// GET /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}
func (c *Client) GetProjectSnapshotEndpoint(ctx context.Context, params GetProjectSnapshotEndpointParams) (GetProjectSnapshotEndpointRes, error) {
	res, err := c.sendGetProjectSnapshotEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendGetProjectSnapshotEndpoint(ctx context.Context, params GetProjectSnapshotEndpointParams) (res GetProjectSnapshotEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_project_snapshot_endpoint"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectSnapshotEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots/"
	{
		// Encode "project_snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectSnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectSnapshotEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectSnapshots invokes get_project_snapshots operation.
//
// Retrieves a list of snapshots for a Studio project.
//
// GET /v1/studio/projects/{project_id}/snapshots
func (c *Client) GetProjectSnapshots(ctx context.Context, params GetProjectSnapshotsParams) (GetProjectSnapshotsRes, error) {
	res, err := c.sendGetProjectSnapshots(ctx, params)
	return res, err
}

func (c *Client) sendGetProjectSnapshots(ctx context.Context, params GetProjectSnapshotsParams) (res GetProjectSnapshotsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_project_snapshots"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/snapshots"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectSnapshotsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectSnapshotsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjects invokes get_projects operation.
//
// Returns a list of your Studio projects with metadata.
//
// GET /v1/studio/projects
func (c *Client) GetProjects(ctx context.Context, params GetProjectsParams) (GetProjectsRes, error) {
	res, err := c.sendGetProjects(ctx, params)
	return res, err
}

func (c *Client) sendGetProjects(ctx context.Context, params GetProjectsParams) (res GetProjectsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_projects"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/studio/projects"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetProjectsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/studio/projects"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPronunciationDictionariesMetadata invokes get_pronunciation_dictionaries_metadata operation.
//
// Get a list of the pronunciation dictionaries you have access to and their metadata.
//
// GET /v1/pronunciation-dictionaries
func (c *Client) GetPronunciationDictionariesMetadata(ctx context.Context, params GetPronunciationDictionariesMetadataParams) (GetPronunciationDictionariesMetadataRes, error) {
	res, err := c.sendGetPronunciationDictionariesMetadata(ctx, params)
	return res, err
}

func (c *Client) sendGetPronunciationDictionariesMetadata(ctx context.Context, params GetPronunciationDictionariesMetadataParams) (res GetPronunciationDictionariesMetadataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pronunciation_dictionaries_metadata"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/pronunciation-dictionaries"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPronunciationDictionariesMetadataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/pronunciation-dictionaries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPronunciationDictionariesMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPronunciationDictionaryMetadata invokes get_pronunciation_dictionary_metadata operation.
//
// Get metadata for a pronunciation dictionary.
//
// GET /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}
func (c *Client) GetPronunciationDictionaryMetadata(ctx context.Context, params GetPronunciationDictionaryMetadataParams) (GetPronunciationDictionaryMetadataRes, error) {
	res, err := c.sendGetPronunciationDictionaryMetadata(ctx, params)
	return res, err
}

func (c *Client) sendGetPronunciationDictionaryMetadata(ctx context.Context, params GetPronunciationDictionaryMetadataParams) (res GetPronunciationDictionaryMetadataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pronunciation_dictionary_metadata"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/pronunciation-dictionaries/{pronunciation_dictionary_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPronunciationDictionaryMetadataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/pronunciation-dictionaries/"
	{
		// Encode "pronunciation_dictionary_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pronunciation_dictionary_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PronunciationDictionaryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPronunciationDictionaryMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPronunciationDictionaryVersionPls invokes get_pronunciation_dictionary_version_pls operation.
//
// Get a PLS file with a pronunciation dictionary version rules.
//
// GET /v1/pronunciation-dictionaries/{dictionary_id}/{version_id}/download
func (c *Client) GetPronunciationDictionaryVersionPls(ctx context.Context, params GetPronunciationDictionaryVersionPlsParams) (GetPronunciationDictionaryVersionPlsRes, error) {
	res, err := c.sendGetPronunciationDictionaryVersionPls(ctx, params)
	return res, err
}

func (c *Client) sendGetPronunciationDictionaryVersionPls(ctx context.Context, params GetPronunciationDictionaryVersionPlsParams) (res GetPronunciationDictionaryVersionPlsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pronunciation_dictionary_version_pls"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/pronunciation-dictionaries/{dictionary_id}/{version_id}/download"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPronunciationDictionaryVersionPlsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/pronunciation-dictionaries/"
	{
		// Encode "dictionary_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dictionary_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DictionaryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VersionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/download"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPronunciationDictionaryVersionPlsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPublicLlmExpectedCostCalculation invokes get_public_llm_expected_cost_calculation operation.
//
// Returns a list of LLM models and the expected cost for using them based on the provided values.
//
// POST /v1/convai/llm-usage/calculate
func (c *Client) GetPublicLlmExpectedCostCalculation(ctx context.Context, request *LLMUsageCalculatorPublicRequestModel) (GetPublicLlmExpectedCostCalculationRes, error) {
	res, err := c.sendGetPublicLlmExpectedCostCalculation(ctx, request)
	return res, err
}

func (c *Client) sendGetPublicLlmExpectedCostCalculation(ctx context.Context, request *LLMUsageCalculatorPublicRequestModel) (res GetPublicLlmExpectedCostCalculationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_public_llm_expected_cost_calculation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/llm-usage/calculate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPublicLlmExpectedCostCalculationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/llm-usage/calculate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetPublicLlmExpectedCostCalculationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPublicLlmExpectedCostCalculationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPvcSampleAudio invokes get_pvc_sample_audio operation.
//
// Retrieve the first 30 seconds of voice sample audio with or without noise removal.
//
// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/audio
func (c *Client) GetPvcSampleAudio(ctx context.Context, params GetPvcSampleAudioParams) (GetPvcSampleAudioRes, error) {
	res, err := c.sendGetPvcSampleAudio(ctx, params)
	return res, err
}

func (c *Client) sendGetPvcSampleAudio(ctx context.Context, params GetPvcSampleAudioParams) (res GetPvcSampleAudioRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pvc_sample_audio"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}/audio"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPvcSampleAudioOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/audio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "remove_background_noise" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "remove_background_noise",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RemoveBackgroundNoise.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPvcSampleAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPvcSampleSpeakers invokes get_pvc_sample_speakers operation.
//
// Retrieve the status of the speaker separation process and the list of detected speakers if
// complete.
//
// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers
func (c *Client) GetPvcSampleSpeakers(ctx context.Context, params GetPvcSampleSpeakersParams) (GetPvcSampleSpeakersRes, error) {
	res, err := c.sendGetPvcSampleSpeakers(ctx, params)
	return res, err
}

func (c *Client) sendGetPvcSampleSpeakers(ctx context.Context, params GetPvcSampleSpeakersParams) (res GetPvcSampleSpeakersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pvc_sample_speakers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPvcSampleSpeakersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/speakers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPvcSampleSpeakersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPvcSampleVisualWaveform invokes get_pvc_sample_visual_waveform operation.
//
// Retrieve the visual waveform of a voice sample.
//
// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/waveform
func (c *Client) GetPvcSampleVisualWaveform(ctx context.Context, params GetPvcSampleVisualWaveformParams) (GetPvcSampleVisualWaveformRes, error) {
	res, err := c.sendGetPvcSampleVisualWaveform(ctx, params)
	return res, err
}

func (c *Client) sendGetPvcSampleVisualWaveform(ctx context.Context, params GetPvcSampleVisualWaveformParams) (res GetPvcSampleVisualWaveformRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pvc_sample_visual_waveform"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}/waveform"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPvcSampleVisualWaveformOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/waveform"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPvcSampleVisualWaveformResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPvcVoiceCaptcha invokes get_pvc_voice_captcha operation.
//
// Get captcha for PVC voice verification.
//
// GET /v1/voices/pvc/{voice_id}/captcha
func (c *Client) GetPvcVoiceCaptcha(ctx context.Context, params GetPvcVoiceCaptchaParams) (GetPvcVoiceCaptchaRes, error) {
	res, err := c.sendGetPvcVoiceCaptcha(ctx, params)
	return res, err
}

func (c *Client) sendGetPvcVoiceCaptcha(ctx context.Context, params GetPvcVoiceCaptchaParams) (res GetPvcVoiceCaptchaRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pvc_voice_captcha"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/captcha"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPvcVoiceCaptchaOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/captcha"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPvcVoiceCaptchaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRagIndexOverview invokes get_rag_index_overview operation.
//
// Provides total size and other information of RAG indexes used by knowledgebase documents.
//
// GET /v1/convai/knowledge-base/rag-index
func (c *Client) GetRagIndexOverview(ctx context.Context, params GetRagIndexOverviewParams) (GetRagIndexOverviewRes, error) {
	res, err := c.sendGetRagIndexOverview(ctx, params)
	return res, err
}

func (c *Client) sendGetRagIndexOverview(ctx context.Context, params GetRagIndexOverviewParams) (res GetRagIndexOverviewRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_rag_index_overview"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/rag-index"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetRagIndexOverviewOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/knowledge-base/rag-index"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRagIndexOverviewResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRagIndexes invokes get_rag_indexes operation.
//
// Provides information about all RAG indexes of the specified knowledgebase document.
//
// GET /v1/convai/knowledge-base/{documentation_id}/rag-index
func (c *Client) GetRagIndexes(ctx context.Context, params GetRagIndexesParams) (GetRagIndexesRes, error) {
	res, err := c.sendGetRagIndexes(ctx, params)
	return res, err
}

func (c *Client) sendGetRagIndexes(ctx context.Context, params GetRagIndexesParams) (res GetRagIndexesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_rag_indexes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}/rag-index"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetRagIndexesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rag-index"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetRagIndexesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetResourceMetadata invokes get_resource_metadata operation.
//
// Gets the metadata of a resource by ID.
//
// GET /v1/workspace/resources/{resource_id}
func (c *Client) GetResourceMetadata(ctx context.Context, params GetResourceMetadataParams) (GetResourceMetadataRes, error) {
	res, err := c.sendGetResourceMetadata(ctx, params)
	return res, err
}

func (c *Client) sendGetResourceMetadata(ctx context.Context, params GetResourceMetadataParams) (res GetResourceMetadataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_resource_metadata"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/workspace/resources/{resource_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetResourceMetadataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/workspace/resources/"
	{
		// Encode "resource_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "resource_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ResourceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "resource_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "resource_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.ResourceType)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetResourceMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSecretsRoute invokes get_secrets_route operation.
//
// Get all workspace secrets for the user.
//
// GET /v1/convai/secrets
func (c *Client) GetSecretsRoute(ctx context.Context, params GetSecretsRouteParams) (GetSecretsRouteRes, error) {
	res, err := c.sendGetSecretsRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetSecretsRoute(ctx context.Context, params GetSecretsRouteParams) (res GetSecretsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_secrets_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/secrets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSecretsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/secrets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSecretsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServiceAccountAPIKeysRoute invokes get_service_account_api_keys_route operation.
//
// Get all API keys for a service account.
//
// GET /v1/service-accounts/{service_account_user_id}/api-keys
func (c *Client) GetServiceAccountAPIKeysRoute(ctx context.Context, params GetServiceAccountAPIKeysRouteParams) (GetServiceAccountAPIKeysRouteRes, error) {
	res, err := c.sendGetServiceAccountAPIKeysRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetServiceAccountAPIKeysRoute(ctx context.Context, params GetServiceAccountAPIKeysRouteParams) (res GetServiceAccountAPIKeysRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_service_account_api_keys_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/service-accounts/{service_account_user_id}/api-keys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetServiceAccountAPIKeysRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/service-accounts/"
	{
		// Encode "service_account_user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_account_user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceAccountUserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetServiceAccountAPIKeysRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSettingsRoute invokes get_settings_route operation.
//
// Retrieve Convai settings for the workspace.
//
// GET /v1/convai/settings
func (c *Client) GetSettingsRoute(ctx context.Context, params GetSettingsRouteParams) (GetSettingsRouteRes, error) {
	res, err := c.sendGetSettingsRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetSettingsRoute(ctx context.Context, params GetSettingsRouteParams) (res GetSettingsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_settings_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSettingsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSettingsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSignedURLDeprecated invokes get_signed_url_deprecated operation.
//
// Get a signed url to start a conversation with an agent with an agent that requires authorization.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/convai/conversation/get_signed_url
func (c *Client) GetSignedURLDeprecated(ctx context.Context, params GetSignedURLDeprecatedParams) (GetSignedURLDeprecatedRes, error) {
	res, err := c.sendGetSignedURLDeprecated(ctx, params)
	return res, err
}

func (c *Client) sendGetSignedURLDeprecated(ctx context.Context, params GetSignedURLDeprecatedParams) (res GetSignedURLDeprecatedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_signed_url_deprecated"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/conversation/get_signed_url"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSignedURLDeprecatedOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/conversation/get_signed_url"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_conversation_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_conversation_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeConversationID.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSignedURLDeprecatedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSimilarLibraryVoices invokes get_similar_library_voices operation.
//
// Returns a list of shared voices similar to the provided audio sample. If neither
// similarity_threshold nor top_k is provided, we will apply default values.
//
// POST /v1/similar-voices
func (c *Client) GetSimilarLibraryVoices(ctx context.Context, request OptBodyGetSimilarLibraryVoicesV1SimilarVoicesPostMultipart, params GetSimilarLibraryVoicesParams) (GetSimilarLibraryVoicesRes, error) {
	res, err := c.sendGetSimilarLibraryVoices(ctx, request, params)
	return res, err
}

func (c *Client) sendGetSimilarLibraryVoices(ctx context.Context, request OptBodyGetSimilarLibraryVoicesV1SimilarVoicesPostMultipart, params GetSimilarLibraryVoicesParams) (res GetSimilarLibraryVoicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_similar_library_voices"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/similar-voices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSimilarLibraryVoicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/similar-voices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetSimilarLibraryVoicesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSimilarLibraryVoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSimilarVoicesForSpeaker invokes get_similar_voices_for_speaker operation.
//
// Fetch the top 10 similar voices to a speaker, including the voice IDs, names, descriptions, and,
// where possible, a sample audio recording.
//
// GET /v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/similar-voices
func (c *Client) GetSimilarVoicesForSpeaker(ctx context.Context, params GetSimilarVoicesForSpeakerParams) (GetSimilarVoicesForSpeakerRes, error) {
	res, err := c.sendGetSimilarVoicesForSpeaker(ctx, params)
	return res, err
}

func (c *Client) sendGetSimilarVoicesForSpeaker(ctx context.Context, params GetSimilarVoicesForSpeakerParams) (res GetSimilarVoicesForSpeakerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_similar_voices_for_speaker"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/similar-voices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSimilarVoicesForSpeakerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/speaker/"
	{
		// Encode "speaker_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "speaker_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SpeakerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/similar-voices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSimilarVoicesForSpeakerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSingleUseToken invokes get_single_use_token operation.
//
// Generate a time limited single-use token with embedded authentication for frontend clients.
//
// POST /v1/single-use-token/{token_type}
func (c *Client) GetSingleUseToken(ctx context.Context, params GetSingleUseTokenParams) (GetSingleUseTokenRes, error) {
	res, err := c.sendGetSingleUseToken(ctx, params)
	return res, err
}

func (c *Client) sendGetSingleUseToken(ctx context.Context, params GetSingleUseTokenParams) (res GetSingleUseTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_single_use_token"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/single-use-token/{token_type}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSingleUseTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/single-use-token/"
	{
		// Encode "token_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "token_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TokenType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSingleUseTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpeakerAudio invokes get_speaker_audio operation.
//
// Retrieve the separated audio for a specific speaker.
//
// GET /v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers/{speaker_id}/audio
func (c *Client) GetSpeakerAudio(ctx context.Context, params GetSpeakerAudioParams) (GetSpeakerAudioRes, error) {
	res, err := c.sendGetSpeakerAudio(ctx, params)
	return res, err
}

func (c *Client) sendGetSpeakerAudio(ctx context.Context, params GetSpeakerAudioParams) (res GetSpeakerAudioRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_speaker_audio"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers/{speaker_id}/audio"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpeakerAudioOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/speakers/"
	{
		// Encode "speaker_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "speaker_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SpeakerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/audio"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpeakerAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpeechHistory invokes get_speech_history operation.
//
// Returns a list of your generated audio.
//
// GET /v1/history
func (c *Client) GetSpeechHistory(ctx context.Context, params GetSpeechHistoryParams) (GetSpeechHistoryRes, error) {
	res, err := c.sendGetSpeechHistory(ctx, params)
	return res, err
}

func (c *Client) sendGetSpeechHistory(ctx context.Context, params GetSpeechHistoryParams) (res GetSpeechHistoryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_speech_history"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpeechHistoryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start_after_history_item_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_after_history_item_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.StartAfterHistoryItemID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "voice_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "voice_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoiceID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "model_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "model_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ModelID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "date_before_unix" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "date_before_unix",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateBeforeUnix.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "date_after_unix" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "date_after_unix",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DateAfterUnix.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "source" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "source",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Source.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpeechHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSpeechHistoryItemByID invokes get_speech_history_item_by_id operation.
//
// Retrieves a history item.
//
// GET /v1/history/{history_item_id}
func (c *Client) GetSpeechHistoryItemByID(ctx context.Context, params GetSpeechHistoryItemByIDParams) (GetSpeechHistoryItemByIDRes, error) {
	res, err := c.sendGetSpeechHistoryItemByID(ctx, params)
	return res, err
}

func (c *Client) sendGetSpeechHistoryItemByID(ctx context.Context, params GetSpeechHistoryItemByIDParams) (res GetSpeechHistoryItemByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_speech_history_item_by_id"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/history/{history_item_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSpeechHistoryItemByIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/history/"
	{
		// Encode "history_item_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "history_item_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.HistoryItemID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSpeechHistoryItemByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTestInvocationRoute invokes get_test_invocation_route operation.
//
// Gets a test invocation by ID.
//
// GET /v1/convai/test-invocations/{test_invocation_id}
func (c *Client) GetTestInvocationRoute(ctx context.Context, params GetTestInvocationRouteParams) (GetTestInvocationRouteRes, error) {
	res, err := c.sendGetTestInvocationRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetTestInvocationRoute(ctx context.Context, params GetTestInvocationRouteParams) (res GetTestInvocationRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_test_invocation_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/test-invocations/{test_invocation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTestInvocationRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/test-invocations/"
	{
		// Encode "test_invocation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "test_invocation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TestInvocationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTestInvocationRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetToolDependentAgentsRoute invokes get_tool_dependent_agents_route operation.
//
// Get a list of agents depending on this tool.
//
// GET /v1/convai/tools/{tool_id}/dependent-agents
func (c *Client) GetToolDependentAgentsRoute(ctx context.Context, params GetToolDependentAgentsRouteParams) (GetToolDependentAgentsRouteRes, error) {
	res, err := c.sendGetToolDependentAgentsRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetToolDependentAgentsRoute(ctx context.Context, params GetToolDependentAgentsRouteParams) (res GetToolDependentAgentsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_tool_dependent_agents_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/tools/{tool_id}/dependent-agents"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetToolDependentAgentsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/tools/"
	{
		// Encode "tool_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tool_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ToolID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dependent-agents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetToolDependentAgentsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTranscriptByID invokes get_transcript_by_id operation.
//
// Retrieve a previously generated transcript by its ID.
//
// GET /v1/speech-to-text/transcripts/{transcription_id}
func (c *Client) GetTranscriptByID(ctx context.Context, params GetTranscriptByIDParams) (GetTranscriptByIDRes, error) {
	res, err := c.sendGetTranscriptByID(ctx, params)
	return res, err
}

func (c *Client) sendGetTranscriptByID(ctx context.Context, params GetTranscriptByIDParams) (res GetTranscriptByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_transcript_by_id"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/speech-to-text/transcripts/{transcription_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTranscriptByIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/speech-to-text/transcripts/"
	{
		// Encode "transcription_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "transcription_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TranscriptionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTranscriptByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserInfo invokes get_user_info operation.
//
// Gets information about the user.
//
// GET /v1/user
func (c *Client) GetUserInfo(ctx context.Context, params GetUserInfoParams) (GetUserInfoRes, error) {
	res, err := c.sendGetUserInfo(ctx, params)
	return res, err
}

func (c *Client) sendGetUserInfo(ctx context.Context, params GetUserInfoParams) (res GetUserInfoRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_user_info"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/user"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetUserInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/user"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserVoicesV2 invokes get_user_voices_v2 operation.
//
// Gets a list of all available voices for a user with search, filtering and pagination.
//
// GET /v2/voices
func (c *Client) GetUserVoicesV2(ctx context.Context, params GetUserVoicesV2Params) (GetUserVoicesV2Res, error) {
	res, err := c.sendGetUserVoicesV2(ctx, params)
	return res, err
}

func (c *Client) sendGetUserVoicesV2(ctx context.Context, params GetUserVoicesV2Params) (res GetUserVoicesV2Res, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_user_voices_v2"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v2/voices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetUserVoicesV2Operation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v2/voices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "next_page_token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next_page_token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.NextPageToken.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort_direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort_direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SortDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "voice_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "voice_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoiceType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "category" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "category",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Category.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "fine_tuning_state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fine_tuning_state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FineTuningState.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "collection_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "collection_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CollectionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_total_count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_total_count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeTotalCount.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "voice_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "voice_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VoiceIds.Get(); ok {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range val {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetUserVoicesV2Response(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoiceByID invokes get_voice_by_id operation.
//
// Returns metadata about a specific voice.
//
// GET /v1/voices/{voice_id}
func (c *Client) GetVoiceByID(ctx context.Context, params GetVoiceByIDParams) (GetVoiceByIDRes, error) {
	res, err := c.sendGetVoiceByID(ctx, params)
	return res, err
}

func (c *Client) sendGetVoiceByID(ctx context.Context, params GetVoiceByIDParams) (res GetVoiceByIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_voice_by_id"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetVoiceByIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "with_settings" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_settings",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithSettings.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoiceByIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoiceSettings invokes get_voice_settings operation.
//
// Returns the settings for a specific voice. "similarity_boost" corresponds to"Clarity + Similarity
// Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
//
// GET /v1/voices/{voice_id}/settings
func (c *Client) GetVoiceSettings(ctx context.Context, params GetVoiceSettingsParams) (GetVoiceSettingsRes, error) {
	res, err := c.sendGetVoiceSettings(ctx, params)
	return res, err
}

func (c *Client) sendGetVoiceSettings(ctx context.Context, params GetVoiceSettingsParams) (res GetVoiceSettingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_voice_settings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/{voice_id}/settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetVoiceSettingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoiceSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoiceSettingsDefault invokes get_voice_settings_default operation.
//
// Gets the default settings for voices. "similarity_boost" corresponds to"Clarity + Similarity
// Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
//
// GET /v1/voices/settings/default
func (c *Client) GetVoiceSettingsDefault(ctx context.Context) (*VoiceSettingsResponseModel, error) {
	res, err := c.sendGetVoiceSettingsDefault(ctx)
	return res, err
}

func (c *Client) sendGetVoiceSettingsDefault(ctx context.Context) (res *VoiceSettingsResponseModel, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_voice_settings_default"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices/settings/default"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetVoiceSettingsDefaultOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voices/settings/default"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoiceSettingsDefaultResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVoices invokes get_voices operation.
//
// Returns a list of all available voices for a user.
//
// GET /v1/voices
func (c *Client) GetVoices(ctx context.Context, params GetVoicesParams) (GetVoicesRes, error) {
	res, err := c.sendGetVoices(ctx, params)
	return res, err
}

func (c *Client) sendGetVoices(ctx context.Context, params GetVoicesParams) (res GetVoicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_voices"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/voices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetVoicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/voices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "show_legacy" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "show_legacy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ShowLegacy.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetVoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWhatsappAccount invokes get_whatsapp_account operation.
//
// Get a WhatsApp account.
//
// GET /v1/convai/whatsapp-accounts/{phone_number_id}
func (c *Client) GetWhatsappAccount(ctx context.Context, params GetWhatsappAccountParams) (GetWhatsappAccountRes, error) {
	res, err := c.sendGetWhatsappAccount(ctx, params)
	return res, err
}

func (c *Client) sendGetWhatsappAccount(ctx context.Context, params GetWhatsappAccountParams) (res GetWhatsappAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_whatsapp_account"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/whatsapp-accounts/{phone_number_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWhatsappAccountOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/whatsapp-accounts/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWhatsappAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkspaceBatchCalls invokes get_workspace_batch_calls operation.
//
// Get all batch calls for the current workspace.
//
// GET /v1/convai/batch-calling/workspace
func (c *Client) GetWorkspaceBatchCalls(ctx context.Context, params GetWorkspaceBatchCallsParams) (GetWorkspaceBatchCallsRes, error) {
	res, err := c.sendGetWorkspaceBatchCalls(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkspaceBatchCalls(ctx context.Context, params GetWorkspaceBatchCallsParams) (res GetWorkspaceBatchCallsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_workspace_batch_calls"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/batch-calling/workspace"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkspaceBatchCallsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/batch-calling/workspace"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "last_doc" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "last_doc",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastDoc.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkspaceBatchCallsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkspaceServiceAccounts invokes get_workspace_service_accounts operation.
//
// List all service accounts in the workspace.
//
// GET /v1/service-accounts
func (c *Client) GetWorkspaceServiceAccounts(ctx context.Context, params GetWorkspaceServiceAccountsParams) (GetWorkspaceServiceAccountsRes, error) {
	res, err := c.sendGetWorkspaceServiceAccounts(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkspaceServiceAccounts(ctx context.Context, params GetWorkspaceServiceAccountsParams) (res GetWorkspaceServiceAccountsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_workspace_service_accounts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/service-accounts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkspaceServiceAccountsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/service-accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkspaceServiceAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWorkspaceWebhooksRoute invokes get_workspace_webhooks_route operation.
//
// List all webhooks for a workspace.
//
// GET /v1/workspace/webhooks
func (c *Client) GetWorkspaceWebhooksRoute(ctx context.Context, params GetWorkspaceWebhooksRouteParams) (GetWorkspaceWebhooksRouteRes, error) {
	res, err := c.sendGetWorkspaceWebhooksRoute(ctx, params)
	return res, err
}

func (c *Client) sendGetWorkspaceWebhooksRoute(ctx context.Context, params GetWorkspaceWebhooksRouteParams) (res GetWorkspaceWebhooksRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_workspace_webhooks_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/workspace/webhooks"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetWorkspaceWebhooksRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/webhooks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "include_usages" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_usages",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeUsages.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetWorkspaceWebhooksRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HandleSipTrunkOutboundCall invokes handle_sip_trunk_outbound_call operation.
//
// Handle an outbound call via SIP trunk.
//
// POST /v1/convai/sip-trunk/outbound-call
func (c *Client) HandleSipTrunkOutboundCall(ctx context.Context, request *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost, params HandleSipTrunkOutboundCallParams) (HandleSipTrunkOutboundCallRes, error) {
	res, err := c.sendHandleSipTrunkOutboundCall(ctx, request, params)
	return res, err
}

func (c *Client) sendHandleSipTrunkOutboundCall(ctx context.Context, request *BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost, params HandleSipTrunkOutboundCallParams) (res HandleSipTrunkOutboundCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("handle_sip_trunk_outbound_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/sip-trunk/outbound-call"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HandleSipTrunkOutboundCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/sip-trunk/outbound-call"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHandleSipTrunkOutboundCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHandleSipTrunkOutboundCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HandleTwilioOutboundCall invokes handle_twilio_outbound_call operation.
//
// Handle an outbound call via Twilio.
//
// POST /v1/convai/twilio/outbound-call
func (c *Client) HandleTwilioOutboundCall(ctx context.Context, request *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost, params HandleTwilioOutboundCallParams) (HandleTwilioOutboundCallRes, error) {
	res, err := c.sendHandleTwilioOutboundCall(ctx, request, params)
	return res, err
}

func (c *Client) sendHandleTwilioOutboundCall(ctx context.Context, request *BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost, params HandleTwilioOutboundCallParams) (res HandleTwilioOutboundCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("handle_twilio_outbound_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/twilio/outbound-call"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HandleTwilioOutboundCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/twilio/outbound-call"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHandleTwilioOutboundCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHandleTwilioOutboundCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ImportWhatsappAccount invokes import_whatsapp_account operation.
//
// Import a WhatsApp account.
//
// POST /v1/convai/whatsapp-accounts
func (c *Client) ImportWhatsappAccount(ctx context.Context, request *ImportWhatsAppAccountRequest, params ImportWhatsappAccountParams) (ImportWhatsappAccountRes, error) {
	res, err := c.sendImportWhatsappAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendImportWhatsappAccount(ctx context.Context, request *ImportWhatsAppAccountRequest, params ImportWhatsappAccountParams) (res ImportWhatsappAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("import_whatsapp_account"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/whatsapp-accounts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ImportWhatsappAccountOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/whatsapp-accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeImportWhatsappAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeImportWhatsappAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InviteUser invokes invite_user operation.
//
// Sends an email invitation to join your workspace to the provided email. If the user doesn't have
// an account they will be prompted to create one. If the user accepts this invite they will be added
// as a user to your workspace and your subscription using one of your seats. This endpoint may only
// be called by workspace administrators. If the user is already in the workspace a 400 error will be
// returned.
//
// POST /v1/workspace/invites/add
func (c *Client) InviteUser(ctx context.Context, request *BodyInviteUserV1WorkspaceInvitesAddPost, params InviteUserParams) (InviteUserRes, error) {
	res, err := c.sendInviteUser(ctx, request, params)
	return res, err
}

func (c *Client) sendInviteUser(ctx context.Context, request *BodyInviteUserV1WorkspaceInvitesAddPost, params InviteUserParams) (res InviteUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("invite_user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/invites/add"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InviteUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/invites/add"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInviteUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInviteUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InviteUsersBulk invokes invite_users_bulk operation.
//
// Sends email invitations to join your workspace to the provided emails. Requires all email
// addresses to be part of a verified domain. If the users don't have an account they will be
// prompted to create one. If the users accept these invites they will be added as users to your
// workspace and your subscription using one of your seats. This endpoint may only be called by
// workspace administrators.
//
// POST /v1/workspace/invites/add-bulk
func (c *Client) InviteUsersBulk(ctx context.Context, request *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost, params InviteUsersBulkParams) (InviteUsersBulkRes, error) {
	res, err := c.sendInviteUsersBulk(ctx, request, params)
	return res, err
}

func (c *Client) sendInviteUsersBulk(ctx context.Context, request *BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost, params InviteUsersBulkParams) (res InviteUsersBulkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("invite_users_bulk"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/invites/add-bulk"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InviteUsersBulkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/invites/add-bulk"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInviteUsersBulkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInviteUsersBulkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListChatResponseTestsRoute invokes list_chat_response_tests_route operation.
//
// Lists all agent response tests with pagination support and optional search filtering.
//
// GET /v1/convai/agent-testing
func (c *Client) ListChatResponseTestsRoute(ctx context.Context, params ListChatResponseTestsRouteParams) (ListChatResponseTestsRouteRes, error) {
	res, err := c.sendListChatResponseTestsRoute(ctx, params)
	return res, err
}

func (c *Client) sendListChatResponseTestsRoute(ctx context.Context, params ListChatResponseTestsRouteParams) (res ListChatResponseTestsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_chat_response_tests_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/agent-testing"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListChatResponseTestsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/agent-testing"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "search" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "search",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Search.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListChatResponseTestsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDubs invokes list_dubs operation.
//
// List the dubs you have access to.
//
// GET /v1/dubbing
func (c *Client) ListDubs(ctx context.Context, params ListDubsParams) (ListDubsRes, error) {
	res, err := c.sendListDubs(ctx, params)
	return res, err
}

func (c *Client) sendListDubs(ctx context.Context, params ListDubsParams) (res ListDubsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_dubs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/dubbing"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListDubsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/dubbing"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dubbing_status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dubbing_status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DubbingStatus.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter_by_creator" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter_by_creator",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FilterByCreator.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order_direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order_direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderDirection.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDubsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMcpServerToolsRoute invokes list_mcp_server_tools_route operation.
//
// Retrieve all tools available for a specific MCP server configuration.
//
// GET /v1/convai/mcp-servers/{mcp_server_id}/tools
func (c *Client) ListMcpServerToolsRoute(ctx context.Context, params ListMcpServerToolsRouteParams) (ListMcpServerToolsRouteRes, error) {
	res, err := c.sendListMcpServerToolsRoute(ctx, params)
	return res, err
}

func (c *Client) sendListMcpServerToolsRoute(ctx context.Context, params ListMcpServerToolsRouteParams) (res ListMcpServerToolsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_mcp_server_tools_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/mcp-servers/{mcp_server_id}/tools"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListMcpServerToolsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/mcp-servers/"
	{
		// Encode "mcp_server_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcp_server_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.McpServerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tools"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListMcpServerToolsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPhoneNumbersRoute invokes list_phone_numbers_route operation.
//
// Retrieve all Phone Numbers.
//
// GET /v1/convai/phone-numbers
func (c *Client) ListPhoneNumbersRoute(ctx context.Context, params ListPhoneNumbersRouteParams) (ListPhoneNumbersRouteRes, error) {
	res, err := c.sendListPhoneNumbersRoute(ctx, params)
	return res, err
}

func (c *Client) sendListPhoneNumbersRoute(ctx context.Context, params ListPhoneNumbersRouteParams) (res ListPhoneNumbersRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_phone_numbers_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/phone-numbers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListPhoneNumbersRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/phone-numbers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPhoneNumbersRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListTestInvocationsRoute invokes list_test_invocations_route operation.
//
// Lists all test invocations with pagination support and optional search filtering.
//
// GET /v1/convai/test-invocations
func (c *Client) ListTestInvocationsRoute(ctx context.Context, params ListTestInvocationsRouteParams) (ListTestInvocationsRouteRes, error) {
	res, err := c.sendListTestInvocationsRoute(ctx, params)
	return res, err
}

func (c *Client) sendListTestInvocationsRoute(ctx context.Context, params ListTestInvocationsRouteParams) (res ListTestInvocationsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_test_invocations_route"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/test-invocations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListTestInvocationsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/test-invocations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "agent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "agent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "cursor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cursor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Cursor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListTestInvocationsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListWhatsappAccounts invokes list_whatsapp_accounts operation.
//
// List all WhatsApp accounts.
//
// GET /v1/convai/whatsapp-accounts
func (c *Client) ListWhatsappAccounts(ctx context.Context, params ListWhatsappAccountsParams) (ListWhatsappAccountsRes, error) {
	res, err := c.sendListWhatsappAccounts(ctx, params)
	return res, err
}

func (c *Client) sendListWhatsappAccounts(ctx context.Context, params ListWhatsappAccountsParams) (res ListWhatsappAccountsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_whatsapp_accounts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/convai/whatsapp-accounts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListWhatsappAccountsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/whatsapp-accounts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListWhatsappAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrateSegments invokes migrate_segments operation.
//
// Change the attribution of one or more segments to a different speaker.
//
// POST /v1/dubbing/resource/{dubbing_id}/migrate-segments
func (c *Client) MigrateSegments(ctx context.Context, request *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost, params MigrateSegmentsParams) (MigrateSegmentsRes, error) {
	res, err := c.sendMigrateSegments(ctx, request, params)
	return res, err
}

func (c *Client) sendMigrateSegments(ctx context.Context, request *BodyMoveSegmentsBetweenSpeakersV1DubbingResourceDubbingIDMigrateSegmentsPost, params MigrateSegmentsParams) (res MigrateSegmentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrate_segments"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/migrate-segments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MigrateSegmentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrate-segments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMigrateSegmentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrateSegmentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PatchPronunciationDictionary invokes patch_pronunciation_dictionary operation.
//
// Partially update the pronunciation dictionary without changing the version.
//
// PATCH /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}
func (c *Client) PatchPronunciationDictionary(ctx context.Context, request OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch, params PatchPronunciationDictionaryParams) (PatchPronunciationDictionaryRes, error) {
	res, err := c.sendPatchPronunciationDictionary(ctx, request, params)
	return res, err
}

func (c *Client) sendPatchPronunciationDictionary(ctx context.Context, request OptBodyUpdatePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDPatch, params PatchPronunciationDictionaryParams) (res PatchPronunciationDictionaryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("patch_pronunciation_dictionary"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/pronunciation-dictionaries/{pronunciation_dictionary_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PatchPronunciationDictionaryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/pronunciation-dictionaries/"
	{
		// Encode "pronunciation_dictionary_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pronunciation_dictionary_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PronunciationDictionaryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePatchPronunciationDictionaryRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePatchPronunciationDictionaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostAgentAvatarRoute invokes post_agent_avatar_route operation.
//
// Sets the avatar for an agent displayed in the widget.
//
// POST /v1/convai/agents/{agent_id}/avatar
func (c *Client) PostAgentAvatarRoute(ctx context.Context, request *BodyPostAgentAvatarV1ConvaiAgentsAgentIDAvatarPostMultipart, params PostAgentAvatarRouteParams) (PostAgentAvatarRouteRes, error) {
	res, err := c.sendPostAgentAvatarRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendPostAgentAvatarRoute(ctx context.Context, request *BodyPostAgentAvatarV1ConvaiAgentsAgentIDAvatarPostMultipart, params PostAgentAvatarRouteParams) (res PostAgentAvatarRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("post_agent_avatar_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/agents/{agent_id}/avatar"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PostAgentAvatarRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/agents/"
	{
		// Encode "agent_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "agent_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AgentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/avatar"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostAgentAvatarRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostAgentAvatarRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostConversationFeedbackRoute invokes post_conversation_feedback_route operation.
//
// Send the feedback for the given conversation.
//
// POST /v1/convai/conversations/{conversation_id}/feedback
func (c *Client) PostConversationFeedbackRoute(ctx context.Context, request *ConversationFeedbackRequestModel, params PostConversationFeedbackRouteParams) (PostConversationFeedbackRouteRes, error) {
	res, err := c.sendPostConversationFeedbackRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendPostConversationFeedbackRoute(ctx context.Context, request *ConversationFeedbackRequestModel, params PostConversationFeedbackRouteParams) (res PostConversationFeedbackRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("post_conversation_feedback_route"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/conversations/{conversation_id}/feedback"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PostConversationFeedbackRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/conversations/"
	{
		// Encode "conversation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "conversation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ConversationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/feedback"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostConversationFeedbackRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostConversationFeedbackRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RagIndexStatus invokes rag_index_status operation.
//
// In case the document is not RAG indexed, it triggers rag indexing task, otherwise it just returns
// the current status.
//
// POST /v1/convai/knowledge-base/{documentation_id}/rag-index
func (c *Client) RagIndexStatus(ctx context.Context, request *RAGIndexRequestModel, params RagIndexStatusParams) (RagIndexStatusRes, error) {
	res, err := c.sendRagIndexStatus(ctx, request, params)
	return res, err
}

func (c *Client) sendRagIndexStatus(ctx context.Context, request *RAGIndexRequestModel, params RagIndexStatusParams) (res RagIndexStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("rag_index_status"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}/rag-index"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RagIndexStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/rag-index"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRagIndexStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRagIndexStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RedirectToMintlify invokes redirect_to_mintlify operation.
//
// Redirect To Mintlify.
//
// GET /docs
func (c *Client) RedirectToMintlify(ctx context.Context) (jx.Raw, error) {
	res, err := c.sendRedirectToMintlify(ctx)
	return res, err
}

func (c *Client) sendRedirectToMintlify(ctx context.Context) (res jx.Raw, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("redirect_to_mintlify"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/docs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RedirectToMintlifyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/docs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRedirectToMintlifyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterTwilioCall invokes register_twilio_call operation.
//
// Register a Twilio call and return TwiML to connect the call.
//
// POST /v1/convai/twilio/register-call
func (c *Client) RegisterTwilioCall(ctx context.Context, request *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost, params RegisterTwilioCallParams) (RegisterTwilioCallRes, error) {
	res, err := c.sendRegisterTwilioCall(ctx, request, params)
	return res, err
}

func (c *Client) sendRegisterTwilioCall(ctx context.Context, request *BodyRegisterATwilioCallAndReturnTwiMLV1ConvaiTwilioRegisterCallPost, params RegisterTwilioCallParams) (res RegisterTwilioCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("register_twilio_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/twilio/register-call"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RegisterTwilioCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/twilio/register-call"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterTwilioCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRegisterTwilioCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMember invokes remove_member operation.
//
// Removes a member from the specified group. This endpoint may only be called by workspace
// administrators.
//
// POST /v1/workspace/groups/{group_id}/members/remove
func (c *Client) RemoveMember(ctx context.Context, request *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost, params RemoveMemberParams) (RemoveMemberRes, error) {
	res, err := c.sendRemoveMember(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveMember(ctx context.Context, request *BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIDMembersRemovePost, params RemoveMemberParams) (res RemoveMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("remove_member"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/groups/{group_id}/members/remove"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemoveMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/workspace/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/remove"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveRules invokes remove_rules operation.
//
// Remove rules from the pronunciation dictionary.
//
// POST /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/remove-rules
func (c *Client) RemoveRules(ctx context.Context, request *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost, params RemoveRulesParams) (RemoveRulesRes, error) {
	res, err := c.sendRemoveRules(ctx, request, params)
	return res, err
}

func (c *Client) sendRemoveRules(ctx context.Context, request *BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIDRemoveRulesPost, params RemoveRulesParams) (res RemoveRulesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("remove_rules"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/remove-rules"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemoveRulesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pronunciation-dictionaries/"
	{
		// Encode "pronunciation_dictionary_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pronunciation_dictionary_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PronunciationDictionaryID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/remove-rules"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemoveRulesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRemoveRulesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RequestPvcManualVerification invokes request_pvc_manual_verification operation.
//
// Request manual verification for a PVC voice.
//
// POST /v1/voices/pvc/{voice_id}/verification
func (c *Client) RequestPvcManualVerification(ctx context.Context, request *BodyRequestManualVerificationV1VoicesPvcVoiceIDVerificationPostMultipart, params RequestPvcManualVerificationParams) (RequestPvcManualVerificationRes, error) {
	res, err := c.sendRequestPvcManualVerification(ctx, request, params)
	return res, err
}

func (c *Client) sendRequestPvcManualVerification(ctx context.Context, request *BodyRequestManualVerificationV1VoicesPvcVoiceIDVerificationPostMultipart, params RequestPvcManualVerificationParams) (res RequestPvcManualVerificationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("request_pvc_manual_verification"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/verification"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RequestPvcManualVerificationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/verification"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRequestPvcManualVerificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRequestPvcManualVerificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RetryBatchCall invokes retry_batch_call operation.
//
// Retry a batch call, calling failed and no-response recipients again.
//
// POST /v1/convai/batch-calling/{batch_id}/retry
func (c *Client) RetryBatchCall(ctx context.Context, params RetryBatchCallParams) (RetryBatchCallRes, error) {
	res, err := c.sendRetryBatchCall(ctx, params)
	return res, err
}

func (c *Client) sendRetryBatchCall(ctx context.Context, params RetryBatchCallParams) (res RetryBatchCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("retry_batch_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/batch-calling/{batch_id}/retry"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RetryBatchCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/convai/batch-calling/"
	{
		// Encode "batch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "batch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BatchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/retry"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRetryBatchCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RunPvcVoiceTraining invokes run_pvc_voice_training operation.
//
// Start PVC training process for a voice.
//
// POST /v1/voices/pvc/{voice_id}/train
func (c *Client) RunPvcVoiceTraining(ctx context.Context, request OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost, params RunPvcVoiceTrainingParams) (RunPvcVoiceTrainingRes, error) {
	res, err := c.sendRunPvcVoiceTraining(ctx, request, params)
	return res, err
}

func (c *Client) sendRunPvcVoiceTraining(ctx context.Context, request OptBodyRunPVCTrainingV1VoicesPvcVoiceIDTrainPost, params RunPvcVoiceTrainingParams) (res RunPvcVoiceTrainingRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("run_pvc_voice_training"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/train"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RunPvcVoiceTrainingOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/train"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRunPvcVoiceTrainingRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRunPvcVoiceTrainingResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchGroups invokes search_groups operation.
//
// Searches for user groups in the workspace. Multiple or no groups may be returned.
//
// GET /v1/workspace/groups/search
func (c *Client) SearchGroups(ctx context.Context, params SearchGroupsParams) (SearchGroupsRes, error) {
	res, err := c.sendSearchGroups(ctx, params)
	return res, err
}

func (c *Client) sendSearchGroups(ctx context.Context, params SearchGroupsParams) (res SearchGroupsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("search_groups"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/workspace/groups/search"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SearchGroupsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/groups/search"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSearchGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SeparateSongStems invokes separate_song_stems operation.
//
// Separate an audio file into individual stems. This endpoint might have high latency, depending on
// the length of the audio file.
//
// POST /v1/music/stem-separation
func (c *Client) SeparateSongStems(ctx context.Context, request *BodyStemSeparationV1MusicStemSeparationPostMultipart, params SeparateSongStemsParams) (SeparateSongStemsRes, error) {
	res, err := c.sendSeparateSongStems(ctx, request, params)
	return res, err
}

func (c *Client) sendSeparateSongStems(ctx context.Context, request *BodyStemSeparationV1MusicStemSeparationPostMultipart, params SeparateSongStemsParams) (res SeparateSongStemsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("separate_song_stems"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/music/stem-separation"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SeparateSongStemsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/music/stem-separation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSeparateSongStemsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSeparateSongStemsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ShareResourceEndpoint invokes share_resource_endpoint operation.
//
// Grants a role on a workspace resource to a user or a group. It overrides any existing role this
// user/service account/group/workspace api key has on the resource. To target a user or service
// account, pass only the user email. The user must be in your workspace. To target a group, pass
// only the group id. To target a workspace api key, pass the api key id. The resource will be shared
// with the service account associated with the api key. You must have admin access to the resource
// to share it.
//
// POST /v1/workspace/resources/{resource_id}/share
func (c *Client) ShareResourceEndpoint(ctx context.Context, request *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost, params ShareResourceEndpointParams) (ShareResourceEndpointRes, error) {
	res, err := c.sendShareResourceEndpoint(ctx, request, params)
	return res, err
}

func (c *Client) sendShareResourceEndpoint(ctx context.Context, request *BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIDSharePost, params ShareResourceEndpointParams) (res ShareResourceEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("share_resource_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/resources/{resource_id}/share"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ShareResourceEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/workspace/resources/"
	{
		// Encode "resource_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "resource_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ResourceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/share"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeShareResourceEndpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeShareResourceEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SoundGeneration invokes sound_generation operation.
//
// Turn text into sound effects for your videos, voice-overs or video games using the most advanced
// sound effects models in the world.
//
// POST /v1/sound-generation
func (c *Client) SoundGeneration(ctx context.Context, request *BodySoundGenerationV1SoundGenerationPost, params SoundGenerationParams) (SoundGenerationRes, error) {
	res, err := c.sendSoundGeneration(ctx, request, params)
	return res, err
}

func (c *Client) sendSoundGeneration(ctx context.Context, request *BodySoundGenerationV1SoundGenerationPost, params SoundGenerationParams) (res SoundGenerationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("sound_generation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/sound-generation"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SoundGenerationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sound-generation"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSoundGenerationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSoundGenerationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpeechToSpeechFull invokes speech_to_speech_full operation.
//
// Transform audio from one voice to another. Maintain full control over emotion, timing and delivery.
//
// POST /v1/speech-to-speech/{voice_id}
func (c *Client) SpeechToSpeechFull(ctx context.Context, request *BodySpeechToSpeechV1SpeechToSpeechVoiceIDPostMultipart, params SpeechToSpeechFullParams) (SpeechToSpeechFullRes, error) {
	res, err := c.sendSpeechToSpeechFull(ctx, request, params)
	return res, err
}

func (c *Client) sendSpeechToSpeechFull(ctx context.Context, request *BodySpeechToSpeechV1SpeechToSpeechVoiceIDPostMultipart, params SpeechToSpeechFullParams) (res SpeechToSpeechFullRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("speech_to_speech_full"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/speech-to-speech/{voice_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpeechToSpeechFullOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/speech-to-speech/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimize_streaming_latency" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimize_streaming_latency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizeStreamingLatency.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSpeechToSpeechFullRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpeechToSpeechFullResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpeechToSpeechStream invokes speech_to_speech_stream operation.
//
// Stream audio from one voice to another. Maintain full control over emotion, timing and delivery.
//
// POST /v1/speech-to-speech/{voice_id}/stream
func (c *Client) SpeechToSpeechStream(ctx context.Context, request *BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIDStreamPostMultipart, params SpeechToSpeechStreamParams) (SpeechToSpeechStreamRes, error) {
	res, err := c.sendSpeechToSpeechStream(ctx, request, params)
	return res, err
}

func (c *Client) sendSpeechToSpeechStream(ctx context.Context, request *BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIDStreamPostMultipart, params SpeechToSpeechStreamParams) (res SpeechToSpeechStreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("speech_to_speech_stream"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/speech-to-speech/{voice_id}/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpeechToSpeechStreamOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/speech-to-speech/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimize_streaming_latency" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimize_streaming_latency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizeStreamingLatency.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSpeechToSpeechStreamRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpeechToSpeechStreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SpeechToText invokes speech_to_text operation.
//
// Transcribe an audio or video file. If webhook is set to true, the request will be processed
// asynchronously and results sent to configured webhooks. When use_multi_channel is true and the
// provided audio has multiple channels, a 'transcripts' object with separate transcripts for each
// channel is returned. Otherwise, returns a single transcript. The optional webhook_metadata
// parameter allows you to attach custom data that will be included in webhook responses for request
// correlation and tracking.
//
// POST /v1/speech-to-text
func (c *Client) SpeechToText(ctx context.Context, request *BodySpeechToTextV1SpeechToTextPostMultipart, params SpeechToTextParams) (SpeechToTextRes, error) {
	res, err := c.sendSpeechToText(ctx, request, params)
	return res, err
}

func (c *Client) sendSpeechToText(ctx context.Context, request *BodySpeechToTextV1SpeechToTextPostMultipart, params SpeechToTextParams) (res SpeechToTextRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("speech_to_text"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/speech-to-text"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SpeechToTextOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/speech-to-text"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSpeechToTextRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSpeechToTextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StartSpeakerSeparation invokes start_speaker_separation operation.
//
// Start speaker separation process for a sample.
//
// POST /v1/voices/pvc/{voice_id}/samples/{sample_id}/separate-speakers
func (c *Client) StartSpeakerSeparation(ctx context.Context, params StartSpeakerSeparationParams) (StartSpeakerSeparationRes, error) {
	res, err := c.sendStartSpeakerSeparation(ctx, params)
	return res, err
}

func (c *Client) sendStartSpeakerSeparation(ctx context.Context, params StartSpeakerSeparationParams) (res StartSpeakerSeparationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("start_speaker_separation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/samples/{sample_id}/separate-speakers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StartSpeakerSeparationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/samples/"
	{
		// Encode "sample_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sample_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SampleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/separate-speakers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStartSpeakerSeparationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StreamChapterSnapshotAudio invokes stream_chapter_snapshot_audio operation.
//
// Stream the audio from a chapter snapshot. Use `GET
// /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots` to return the snapshots of a
// chapter.
//
// POST /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream
func (c *Client) StreamChapterSnapshotAudio(ctx context.Context, request OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost, params StreamChapterSnapshotAudioParams) (StreamChapterSnapshotAudioRes, error) {
	res, err := c.sendStreamChapterSnapshotAudio(ctx, request, params)
	return res, err
}

func (c *Client) sendStreamChapterSnapshotAudio(ctx context.Context, request OptBodyStreamChapterAudioV1StudioProjectsProjectIDChaptersChapterIDSnapshotsChapterSnapshotIDStreamPost, params StreamChapterSnapshotAudioParams) (res StreamChapterSnapshotAudioRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stream_chapter_snapshot_audio"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StreamChapterSnapshotAudioOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/chapters/"
	{
		// Encode "chapter_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/snapshots/"
	{
		// Encode "chapter_snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chapter_snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChapterSnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStreamChapterSnapshotAudioRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStreamChapterSnapshotAudioResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StreamCompose invokes stream_compose operation.
//
// Stream a composed song from a prompt or a composition plan.
//
// POST /v1/music/stream
func (c *Client) StreamCompose(ctx context.Context, request OptBodyStreamComposedMusicV1MusicStreamPost, params StreamComposeParams) (StreamComposeRes, error) {
	res, err := c.sendStreamCompose(ctx, request, params)
	return res, err
}

func (c *Client) sendStreamCompose(ctx context.Context, request OptBodyStreamComposedMusicV1MusicStreamPost, params StreamComposeParams) (res StreamComposeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stream_compose"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/music/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StreamComposeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/music/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStreamComposeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStreamComposeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StreamProjectSnapshotArchiveEndpoint invokes stream_project_snapshot_archive_endpoint operation.
//
// Returns a compressed archive of the Studio project's audio.
//
// POST /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/archive
func (c *Client) StreamProjectSnapshotArchiveEndpoint(ctx context.Context, params StreamProjectSnapshotArchiveEndpointParams) (StreamProjectSnapshotArchiveEndpointRes, error) {
	res, err := c.sendStreamProjectSnapshotArchiveEndpoint(ctx, params)
	return res, err
}

func (c *Client) sendStreamProjectSnapshotArchiveEndpoint(ctx context.Context, params StreamProjectSnapshotArchiveEndpointParams) (res StreamProjectSnapshotArchiveEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stream_project_snapshot_archive_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/archive"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StreamProjectSnapshotArchiveEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots/"
	{
		// Encode "project_snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectSnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/archive"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStreamProjectSnapshotArchiveEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// StreamProjectSnapshotAudioEndpoint invokes stream_project_snapshot_audio_endpoint operation.
//
// Stream the audio from a Studio project snapshot.
//
// POST /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/stream
func (c *Client) StreamProjectSnapshotAudioEndpoint(ctx context.Context, request OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost, params StreamProjectSnapshotAudioEndpointParams) (StreamProjectSnapshotAudioEndpointRes, error) {
	res, err := c.sendStreamProjectSnapshotAudioEndpoint(ctx, request, params)
	return res, err
}

func (c *Client) sendStreamProjectSnapshotAudioEndpoint(ctx context.Context, request OptBodyStreamStudioProjectAudioV1StudioProjectsProjectIDSnapshotsProjectSnapshotIDStreamPost, params StreamProjectSnapshotAudioEndpointParams) (res StreamProjectSnapshotAudioEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("stream_project_snapshot_audio_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, StreamProjectSnapshotAudioEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots/"
	{
		// Encode "project_snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectSnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeStreamProjectSnapshotAudioEndpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeStreamProjectSnapshotAudioEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToDialogue invokes text_to_dialogue operation.
//
// Converts a list of text and voice ID pairs into speech (dialogue) and returns audio.
//
// POST /v1/text-to-dialogue
func (c *Client) TextToDialogue(ctx context.Context, request *BodyTextToDialogueMultiVoiceV1TextToDialoguePost, params TextToDialogueParams) (TextToDialogueRes, error) {
	res, err := c.sendTextToDialogue(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToDialogue(ctx context.Context, request *BodyTextToDialogueMultiVoiceV1TextToDialoguePost, params TextToDialogueParams) (res TextToDialogueRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_dialogue"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-dialogue"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToDialogueOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-dialogue"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToDialogueRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToDialogueResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToDialogueFullWithTimestamps invokes text_to_dialogue_full_with_timestamps operation.
//
// Generate dialogue from text with precise character-level timing information for audio-text
// synchronization.
//
// POST /v1/text-to-dialogue/with-timestamps
func (c *Client) TextToDialogueFullWithTimestamps(ctx context.Context, request *BodyTextToDialogueFullWithTimestamps, params TextToDialogueFullWithTimestampsParams) (TextToDialogueFullWithTimestampsRes, error) {
	res, err := c.sendTextToDialogueFullWithTimestamps(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToDialogueFullWithTimestamps(ctx context.Context, request *BodyTextToDialogueFullWithTimestamps, params TextToDialogueFullWithTimestampsParams) (res TextToDialogueFullWithTimestampsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_dialogue_full_with_timestamps"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-dialogue/with-timestamps"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToDialogueFullWithTimestampsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-dialogue/with-timestamps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToDialogueFullWithTimestampsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToDialogueFullWithTimestampsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToDialogueStream invokes text_to_dialogue_stream operation.
//
// Converts a list of text and voice ID pairs into speech (dialogue) and returns an audio stream.
//
// POST /v1/text-to-dialogue/stream
func (c *Client) TextToDialogueStream(ctx context.Context, request *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost, params TextToDialogueStreamParams) (TextToDialogueStreamRes, error) {
	res, err := c.sendTextToDialogueStream(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToDialogueStream(ctx context.Context, request *BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost, params TextToDialogueStreamParams) (res TextToDialogueStreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_dialogue_stream"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-dialogue/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToDialogueStreamOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-dialogue/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToDialogueStreamRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToDialogueStreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToDialogueStreamWithTimestamps invokes text_to_dialogue_stream_with_timestamps operation.
//
// Converts a list of text and voice ID pairs into speech (dialogue) and returns a stream of JSON
// blobs containing audio as a base64 encoded string and timestamps.
//
// POST /v1/text-to-dialogue/stream/with-timestamps
func (c *Client) TextToDialogueStreamWithTimestamps(ctx context.Context, request *BodyTextToDialogueStreamWithTimestamps, params TextToDialogueStreamWithTimestampsParams) (TextToDialogueStreamWithTimestampsRes, error) {
	res, err := c.sendTextToDialogueStreamWithTimestamps(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToDialogueStreamWithTimestamps(ctx context.Context, request *BodyTextToDialogueStreamWithTimestamps, params TextToDialogueStreamWithTimestampsParams) (res TextToDialogueStreamWithTimestampsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_dialogue_stream_with_timestamps"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-dialogue/stream/with-timestamps"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToDialogueStreamWithTimestampsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-dialogue/stream/with-timestamps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToDialogueStreamWithTimestampsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToDialogueStreamWithTimestampsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToSpeechFull invokes text_to_speech_full operation.
//
// Converts text into speech using a voice of your choice and returns audio.
//
// POST /v1/text-to-speech/{voice_id}
func (c *Client) TextToSpeechFull(ctx context.Context, request *BodyTextToSpeechFull, params TextToSpeechFullParams) (TextToSpeechFullRes, error) {
	res, err := c.sendTextToSpeechFull(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToSpeechFull(ctx context.Context, request *BodyTextToSpeechFull, params TextToSpeechFullParams) (res TextToSpeechFullRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_speech_full"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-speech/{voice_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToSpeechFullOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/text-to-speech/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimize_streaming_latency" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimize_streaming_latency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizeStreamingLatency.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToSpeechFullRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToSpeechFullResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToSpeechFullWithTimestamps invokes text_to_speech_full_with_timestamps operation.
//
// Generate speech from text with precise character-level timing information for audio-text
// synchronization.
//
// POST /v1/text-to-speech/{voice_id}/with-timestamps
func (c *Client) TextToSpeechFullWithTimestamps(ctx context.Context, request *BodyTextToSpeechFullWithTimestamps, params TextToSpeechFullWithTimestampsParams) (TextToSpeechFullWithTimestampsRes, error) {
	res, err := c.sendTextToSpeechFullWithTimestamps(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToSpeechFullWithTimestamps(ctx context.Context, request *BodyTextToSpeechFullWithTimestamps, params TextToSpeechFullWithTimestampsParams) (res TextToSpeechFullWithTimestampsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_speech_full_with_timestamps"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-speech/{voice_id}/with-timestamps"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToSpeechFullWithTimestampsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/text-to-speech/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/with-timestamps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimize_streaming_latency" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimize_streaming_latency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizeStreamingLatency.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToSpeechFullWithTimestampsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToSpeechFullWithTimestampsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToSpeechStream invokes text_to_speech_stream operation.
//
// Converts text into speech using a voice of your choice and returns audio as an audio stream.
//
// POST /v1/text-to-speech/{voice_id}/stream
func (c *Client) TextToSpeechStream(ctx context.Context, request *BodyTextToSpeechStream, params TextToSpeechStreamParams) (TextToSpeechStreamRes, error) {
	res, err := c.sendTextToSpeechStream(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToSpeechStream(ctx context.Context, request *BodyTextToSpeechStream, params TextToSpeechStreamParams) (res TextToSpeechStreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_speech_stream"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-speech/{voice_id}/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToSpeechStreamOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/text-to-speech/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimize_streaming_latency" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimize_streaming_latency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizeStreamingLatency.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToSpeechStreamRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToSpeechStreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToSpeechStreamWithTimestamps invokes text_to_speech_stream_with_timestamps operation.
//
// Converts text into speech using a voice of your choice and returns a stream of JSONs containing
// audio as a base64 encoded string together with information on when which character was spoken.
//
// POST /v1/text-to-speech/{voice_id}/stream/with-timestamps
func (c *Client) TextToSpeechStreamWithTimestamps(ctx context.Context, request *BodyTextToSpeechStreamWithTimestamps, params TextToSpeechStreamWithTimestampsParams) (TextToSpeechStreamWithTimestampsRes, error) {
	res, err := c.sendTextToSpeechStreamWithTimestamps(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToSpeechStreamWithTimestamps(ctx context.Context, request *BodyTextToSpeechStreamWithTimestamps, params TextToSpeechStreamWithTimestampsParams) (res TextToSpeechStreamWithTimestampsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_speech_stream_with_timestamps"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-speech/{voice_id}/stream/with-timestamps"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToSpeechStreamWithTimestampsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/text-to-speech/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stream/with-timestamps"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "enable_logging" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enable_logging",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnableLogging.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "optimize_streaming_latency" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "optimize_streaming_latency",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OptimizeStreamingLatency.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToSpeechStreamWithTimestampsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToSpeechStreamWithTimestampsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToVoice invokes text_to_voice operation.
//
// Generate a custom voice based on voice description. This method returns a list of voice previews.
// Each preview has a generated_voice_id and a sample of the voice as base64 encoded mp3 audio. If
// you like the a voice previewand want to create the voice call
// /v1/text-to-voice/create-voice-from-preview with the generated_voice_id to create the voice.
//
// POST /v1/text-to-voice/create-previews
func (c *Client) TextToVoice(ctx context.Context, request *VoicePreviewsRequestModel, params TextToVoiceParams) (TextToVoiceRes, error) {
	res, err := c.sendTextToVoice(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToVoice(ctx context.Context, request *VoicePreviewsRequestModel, params TextToVoiceParams) (res TextToVoiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_voice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-voice/create-previews"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToVoiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-voice/create-previews"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToVoiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToVoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToVoiceDesign invokes text_to_voice_design operation.
//
// Design a voice via a prompt. This method returns a list of voice previews. Each preview has a
// generated_voice_id and a sample of the voice as base64 encoded mp3 audio. To create a voice use
// the generated_voice_id of the preferred preview with the /v1/text-to-voice endpoint.
//
// POST /v1/text-to-voice/design
func (c *Client) TextToVoiceDesign(ctx context.Context, request *VoiceDesignRequestModel, params TextToVoiceDesignParams) (TextToVoiceDesignRes, error) {
	res, err := c.sendTextToVoiceDesign(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToVoiceDesign(ctx context.Context, request *VoiceDesignRequestModel, params TextToVoiceDesignParams) (res TextToVoiceDesignRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_voice_design"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-voice/design"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToVoiceDesignOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/text-to-voice/design"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToVoiceDesignRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToVoiceDesignResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToVoicePreviewStream invokes text_to_voice_preview_stream operation.
//
// Stream a voice preview that was created via the /v1/text-to-voice/design endpoint.
//
// GET /v1/text-to-voice/{generated_voice_id}/stream
func (c *Client) TextToVoicePreviewStream(ctx context.Context, params TextToVoicePreviewStreamParams) (TextToVoicePreviewStreamRes, error) {
	res, err := c.sendTextToVoicePreviewStream(ctx, params)
	return res, err
}

func (c *Client) sendTextToVoicePreviewStream(ctx context.Context, params TextToVoicePreviewStreamParams) (res TextToVoicePreviewStreamRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_voice_preview_stream"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/text-to-voice/{generated_voice_id}/stream"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToVoicePreviewStreamOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/text-to-voice/"
	{
		// Encode "generated_voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "generated_voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GeneratedVoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stream"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToVoicePreviewStreamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TextToVoiceRemix invokes text_to_voice_remix operation.
//
// Remix an existing voice via a prompt. This method returns a list of voice previews. Each preview
// has a generated_voice_id and a sample of the voice as base64 encoded mp3 audio. To create a voice
// use the generated_voice_id of the preferred preview with the /v1/text-to-voice endpoint.
//
// POST /v1/text-to-voice/{voice_id}/remix
func (c *Client) TextToVoiceRemix(ctx context.Context, request *VoiceRemixRequestModel, params TextToVoiceRemixParams) (TextToVoiceRemixRes, error) {
	res, err := c.sendTextToVoiceRemix(ctx, request, params)
	return res, err
}

func (c *Client) sendTextToVoiceRemix(ctx context.Context, request *VoiceRemixRequestModel, params TextToVoiceRemixParams) (res TextToVoiceRemixRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("text_to_voice_remix"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/text-to-voice/{voice_id}/remix"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TextToVoiceRemixOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/text-to-voice/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/remix"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "output_format" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "output_format",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OutputFormat.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTextToVoiceRemixRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTextToVoiceRemixResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Transcribe invokes transcribe operation.
//
// Regenerate the transcriptions for the specified segments. Does not automatically regenerate
// translations or dubs.
//
// POST /v1/dubbing/resource/{dubbing_id}/transcribe
func (c *Client) Transcribe(ctx context.Context, request *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost, params TranscribeParams) (TranscribeRes, error) {
	res, err := c.sendTranscribe(ctx, request, params)
	return res, err
}

func (c *Client) sendTranscribe(ctx context.Context, request *BodyTranscribesSegmentsV1DubbingResourceDubbingIDTranscribePost, params TranscribeParams) (res TranscribeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("transcribe"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/transcribe"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TranscribeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/transcribe"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTranscribeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTranscribeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Translate invokes translate operation.
//
// Regenerate the translations for either the entire resource or the specified segments/languages.
// Will automatically transcribe missing transcriptions. Will not automatically regenerate the dubs.
//
// POST /v1/dubbing/resource/{dubbing_id}/translate
func (c *Client) Translate(ctx context.Context, request *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost, params TranslateParams) (TranslateRes, error) {
	res, err := c.sendTranslate(ctx, request, params)
	return res, err
}

func (c *Client) sendTranslate(ctx context.Context, request *BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIDTranslatePost, params TranslateParams) (res TranslateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("translate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/translate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, TranslateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/translate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTranslateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTranslateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnshareResourceEndpoint invokes unshare_resource_endpoint operation.
//
// Removes any existing role on a workspace resource from a user, service account, group or workspace
// api key. To target a user or service account, pass only the user email. The user must be in your
// workspace. To target a group, pass only the group id. To target a workspace api key, pass the api
// key id. The resource will be unshared from the service account associated with the api key. You
// must have admin access to the resource to unshare it. You cannot remove permissions from the user
// who created the resource.
//
// POST /v1/workspace/resources/{resource_id}/unshare
func (c *Client) UnshareResourceEndpoint(ctx context.Context, request *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost, params UnshareResourceEndpointParams) (UnshareResourceEndpointRes, error) {
	res, err := c.sendUnshareResourceEndpoint(ctx, request, params)
	return res, err
}

func (c *Client) sendUnshareResourceEndpoint(ctx context.Context, request *BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIDUnsharePost, params UnshareResourceEndpointParams) (res UnshareResourceEndpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("unshare_resource_endpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/resources/{resource_id}/unshare"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UnshareResourceEndpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/workspace/resources/"
	{
		// Encode "resource_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "resource_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ResourceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/unshare"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnshareResourceEndpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUnshareResourceEndpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAgentResponseTestRoute invokes update_agent_response_test_route operation.
//
// Updates an agent response test by ID.
//
// PUT /v1/convai/agent-testing/{test_id}
func (c *Client) UpdateAgentResponseTestRoute(ctx context.Context, request *UpdateUnitTestRequest, params UpdateAgentResponseTestRouteParams) (UpdateAgentResponseTestRouteRes, error) {
	res, err := c.sendUpdateAgentResponseTestRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAgentResponseTestRoute(ctx context.Context, request *UpdateUnitTestRequest, params UpdateAgentResponseTestRouteParams) (res UpdateAgentResponseTestRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_agent_response_test_route"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/v1/convai/agent-testing/{test_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateAgentResponseTestRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/agent-testing/"
	{
		// Encode "test_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "test_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TestID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAgentResponseTestRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateAgentResponseTestRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDashboardSettingsRoute invokes update_dashboard_settings_route operation.
//
// Update Convai dashboard settings for the workspace.
//
// PATCH /v1/convai/settings/dashboard
func (c *Client) UpdateDashboardSettingsRoute(ctx context.Context, request *PatchConvAIDashboardSettingsRequest, params UpdateDashboardSettingsRouteParams) (UpdateDashboardSettingsRouteRes, error) {
	res, err := c.sendUpdateDashboardSettingsRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDashboardSettingsRoute(ctx context.Context, request *PatchConvAIDashboardSettingsRequest, params UpdateDashboardSettingsRouteParams) (res UpdateDashboardSettingsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_dashboard_settings_route"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/convai/settings/dashboard"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateDashboardSettingsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/settings/dashboard"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDashboardSettingsRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateDashboardSettingsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDocumentRoute invokes update_document_route operation.
//
// Update the name of a document.
//
// PATCH /v1/convai/knowledge-base/{documentation_id}
func (c *Client) UpdateDocumentRoute(ctx context.Context, request *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch, params UpdateDocumentRouteParams) (UpdateDocumentRouteRes, error) {
	res, err := c.sendUpdateDocumentRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDocumentRoute(ctx context.Context, request *BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIDPatch, params UpdateDocumentRouteParams) (res UpdateDocumentRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_document_route"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/convai/knowledge-base/{documentation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateDocumentRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/knowledge-base/"
	{
		// Encode "documentation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "documentation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DocumentationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDocumentRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateDocumentRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePhoneNumberRoute invokes update_phone_number_route operation.
//
// Update assigned agent of a phone number.
//
// PATCH /v1/convai/phone-numbers/{phone_number_id}
func (c *Client) UpdatePhoneNumberRoute(ctx context.Context, request *UpdatePhoneNumberRequest, params UpdatePhoneNumberRouteParams) (UpdatePhoneNumberRouteRes, error) {
	res, err := c.sendUpdatePhoneNumberRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePhoneNumberRoute(ctx context.Context, request *UpdatePhoneNumberRequest, params UpdatePhoneNumberRouteParams) (res UpdatePhoneNumberRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_phone_number_route"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/convai/phone-numbers/{phone_number_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdatePhoneNumberRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/phone-numbers/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePhoneNumberRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePhoneNumberRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePronunciationDictionaries invokes update_pronunciation_dictionaries operation.
//
// Create a set of pronunciation dictionaries acting on a project. This will automatically mark text
// within this project as requiring reconverting where the new dictionary would apply or the old one
// no longer does.
//
// POST /v1/studio/projects/{project_id}/pronunciation-dictionaries
func (c *Client) UpdatePronunciationDictionaries(ctx context.Context, request *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost, params UpdatePronunciationDictionariesParams) (UpdatePronunciationDictionariesRes, error) {
	res, err := c.sendUpdatePronunciationDictionaries(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePronunciationDictionaries(ctx context.Context, request *BodyCreatePronunciationDictionariesV1StudioProjectsProjectIDPronunciationDictionariesPost, params UpdatePronunciationDictionariesParams) (res UpdatePronunciationDictionariesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_pronunciation_dictionaries"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/studio/projects/{project_id}/pronunciation-dictionaries"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdatePronunciationDictionariesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/studio/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pronunciation-dictionaries"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePronunciationDictionariesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePronunciationDictionariesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSecretRoute invokes update_secret_route operation.
//
// Update an existing secret for the workspace.
//
// PATCH /v1/convai/secrets/{secret_id}
func (c *Client) UpdateSecretRoute(ctx context.Context, request *PatchWorkspaceSecretRequest, params UpdateSecretRouteParams) (UpdateSecretRouteRes, error) {
	res, err := c.sendUpdateSecretRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSecretRoute(ctx context.Context, request *PatchWorkspaceSecretRequest, params UpdateSecretRouteParams) (res UpdateSecretRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_secret_route"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/convai/secrets/{secret_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateSecretRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/secrets/"
	{
		// Encode "secret_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "secret_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SecretID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSecretRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSecretRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSegmentLanguage invokes update_segment_language operation.
//
// Modifies a single segment with new text and/or start/end times. Will update the values for only a
// specific language of a segment. Does not automatically regenerate the dub.
//
// PATCH /v1/dubbing/resource/{dubbing_id}/segment/{segment_id}/{language}
func (c *Client) UpdateSegmentLanguage(ctx context.Context, request *SegmentUpdatePayload, params UpdateSegmentLanguageParams) (UpdateSegmentLanguageRes, error) {
	res, err := c.sendUpdateSegmentLanguage(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSegmentLanguage(ctx context.Context, request *SegmentUpdatePayload, params UpdateSegmentLanguageParams) (res UpdateSegmentLanguageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_segment_language"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/segment/{segment_id}/{language}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateSegmentLanguageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/segment/"
	{
		// Encode "segment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "segment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SegmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "language" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "language",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Language))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSegmentLanguageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSegmentLanguageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSettingsRoute invokes update_settings_route operation.
//
// Update Convai settings for the workspace.
//
// PATCH /v1/convai/settings
func (c *Client) UpdateSettingsRoute(ctx context.Context, request *PatchConvAISettingsRequest, params UpdateSettingsRouteParams) (UpdateSettingsRouteRes, error) {
	res, err := c.sendUpdateSettingsRoute(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSettingsRoute(ctx context.Context, request *PatchConvAISettingsRequest, params UpdateSettingsRouteParams) (res UpdateSettingsRouteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_settings_route"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/convai/settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateSettingsRouteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSettingsRouteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSettingsRouteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateSpeaker invokes update_speaker operation.
//
// Amend the metadata associated with a speaker, such as their voice. Both voice cloning and using
// voices from the ElevenLabs library are supported.
//
// PATCH /v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}
func (c *Client) UpdateSpeaker(ctx context.Context, request OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch, params UpdateSpeakerParams) (UpdateSpeakerRes, error) {
	res, err := c.sendUpdateSpeaker(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateSpeaker(ctx context.Context, request OptBodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIDSpeakerSpeakerIDPatch, params UpdateSpeakerParams) (res UpdateSpeakerRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_speaker"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateSpeakerOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/dubbing/resource/"
	{
		// Encode "dubbing_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "dubbing_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.DubbingID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/speaker/"
	{
		// Encode "speaker_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "speaker_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SpeakerID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateSpeakerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateSpeakerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWhatsappAccount invokes update_whatsapp_account operation.
//
// Update a WhatsApp account.
//
// PATCH /v1/convai/whatsapp-accounts/{phone_number_id}
func (c *Client) UpdateWhatsappAccount(ctx context.Context, request *UpdateWhatsAppAccountRequest, params UpdateWhatsappAccountParams) (UpdateWhatsappAccountRes, error) {
	res, err := c.sendUpdateWhatsappAccount(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateWhatsappAccount(ctx context.Context, request *UpdateWhatsAppAccountRequest, params UpdateWhatsappAccountParams) (res UpdateWhatsappAccountRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_whatsapp_account"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/v1/convai/whatsapp-accounts/{phone_number_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateWhatsappAccountOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/convai/whatsapp-accounts/"
	{
		// Encode "phone_number_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "phone_number_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PhoneNumberID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWhatsappAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateWhatsappAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateWorkspaceMember invokes update_workspace_member operation.
//
// Updates attributes of a workspace member. Apart from the email identifier, all parameters will
// remain unchanged unless specified. This endpoint may only be called by workspace administrators.
//
// POST /v1/workspace/members
func (c *Client) UpdateWorkspaceMember(ctx context.Context, request *BodyUpdateMemberV1WorkspaceMembersPost, params UpdateWorkspaceMemberParams) (UpdateWorkspaceMemberRes, error) {
	res, err := c.sendUpdateWorkspaceMember(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateWorkspaceMember(ctx context.Context, request *BodyUpdateMemberV1WorkspaceMembersPost, params UpdateWorkspaceMemberParams) (res UpdateWorkspaceMemberRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_workspace_member"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/workspace/members"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateWorkspaceMemberOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/workspace/members"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateWorkspaceMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateWorkspaceMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsageCharacters invokes usage_characters operation.
//
// Returns the usage metrics for the current user or the entire workspace they are part of. The
// response provides a time axis based on the specified aggregation interval (default: day), with
// usage values for each interval along that axis. Usage is broken down by the selected breakdown
// type. For example, breakdown type "voice" will return the usage of each voice for each interval
// along the time axis.
//
// GET /v1/usage/character-stats
func (c *Client) UsageCharacters(ctx context.Context, params UsageCharactersParams) (UsageCharactersRes, error) {
	res, err := c.sendUsageCharacters(ctx, params)
	return res, err
}

func (c *Client) sendUsageCharacters(ctx context.Context, params UsageCharactersParams) (res UsageCharactersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("usage_characters"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/v1/usage/character-stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsageCharactersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/usage/character-stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start_unix" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start_unix",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.StartUnix))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end_unix" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end_unix",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.EndUnix))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_workspace_metrics" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_workspace_metrics",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeWorkspaceMetrics.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "breakdown_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "breakdown_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BreakdownType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "aggregation_interval" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "aggregation_interval",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AggregationInterval.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "aggregation_bucket_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "aggregation_bucket_size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.AggregationBucketSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "metric" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "metric",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Metric.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUsageCharactersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VerifyPvcVoiceCaptcha invokes verify_pvc_voice_captcha operation.
//
// Submit captcha verification for PVC voice.
//
// POST /v1/voices/pvc/{voice_id}/captcha
func (c *Client) VerifyPvcVoiceCaptcha(ctx context.Context, request *BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIDCaptchaPostMultipart, params VerifyPvcVoiceCaptchaParams) (VerifyPvcVoiceCaptchaRes, error) {
	res, err := c.sendVerifyPvcVoiceCaptcha(ctx, request, params)
	return res, err
}

func (c *Client) sendVerifyPvcVoiceCaptcha(ctx context.Context, request *BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIDCaptchaPostMultipart, params VerifyPvcVoiceCaptchaParams) (res VerifyPvcVoiceCaptchaRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("verify_pvc_voice_captcha"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/voices/pvc/{voice_id}/captcha"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, VerifyPvcVoiceCaptchaOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/voices/pvc/"
	{
		// Encode "voice_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "voice_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VoiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/captcha"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVerifyPvcVoiceCaptchaRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeVerifyPvcVoiceCaptchaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WhatsappOutboundCall invokes whatsapp_outbound_call operation.
//
// Make an outbound call via WhatsApp.
//
// POST /v1/convai/whatsapp/outbound-call
func (c *Client) WhatsappOutboundCall(ctx context.Context, request *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost, params WhatsappOutboundCallParams) (WhatsappOutboundCallRes, error) {
	res, err := c.sendWhatsappOutboundCall(ctx, request, params)
	return res, err
}

func (c *Client) sendWhatsappOutboundCall(ctx context.Context, request *BodyMakeAnOutboundCallViaWhatsAppV1ConvaiWhatsappOutboundCallPost, params WhatsappOutboundCallParams) (res WhatsappOutboundCallRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("whatsapp_outbound_call"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/v1/convai/whatsapp/outbound-call"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, WhatsappOutboundCallOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/convai/whatsapp/outbound-call"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeWhatsappOutboundCallRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "xi-api-key",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XiAPIKey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeWhatsappOutboundCallResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
