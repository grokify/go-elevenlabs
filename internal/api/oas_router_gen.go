// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'd': // Prefix: "docs"

				if l := len("docs"); len(elem) >= l && elem[0:l] == "docs" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleRedirectToMintlifyRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			case 'v': // Prefix: "v"

				if l := len("v"); len(elem) >= l && elem[0:l] == "v" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '1': // Prefix: "1/"

					if l := len("1/"); len(elem) >= l && elem[0:l] == "1/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "audio-"

						if l := len("audio-"); len(elem) >= l && elem[0:l] == "audio-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'i': // Prefix: "isolation"

							if l := len("isolation"); len(elem) >= l && elem[0:l] == "isolation" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleAudioIsolationRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/stream"

								if l := len("/stream"); len(elem) >= l && elem[0:l] == "/stream" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleAudioIsolationStreamRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 'n': // Prefix: "native"

							if l := len("native"); len(elem) >= l && elem[0:l] == "native" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleCreateAudioNativeProjectRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "content"

										if l := len("content"); len(elem) >= l && elem[0:l] == "content" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAudioNativeProjectUpdateContentEndpointRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 's': // Prefix: "settings"

										if l := len("settings"); len(elem) >= l && elem[0:l] == "settings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetAudioNativeProjectSettingsEndpointRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						}

					case 'c': // Prefix: "convai/"

						if l := len("convai/"); len(elem) >= l && elem[0:l] == "convai/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"

							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "gent"

								if l := len("gent"); len(elem) >= l && elem[0:l] == "gent" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '-': // Prefix: "-testing"

									if l := len("-testing"); len(elem) >= l && elem[0:l] == "-testing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleListChatResponseTestsRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "create"
											origElem := elem
											if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleCreateAgentResponseTestRouteRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										case 's': // Prefix: "summaries"
											origElem := elem
											if l := len("summaries"); len(elem) >= l && elem[0:l] == "summaries" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleGetAgentResponseTestsSummariesRouteRequest([0]string{}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

											elem = origElem
										}
										// Param: "test_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleDeleteChatResponseTestRouteRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleGetAgentResponseTestRouteRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PUT":
												s.handleUpdateAgentResponseTestRouteRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET,PUT")
											}

											return
										}

									}

								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "agent_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'k': // Prefix: "knowledge-base/size"

											if l := len("knowledge-base/size"); len(elem) >= l && elem[0:l] == "knowledge-base/size" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetAgentKnowledgeBaseSizeRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'l': // Prefix: "llm-usage/calculate"

											if l := len("llm-usage/calculate"); len(elem) >= l && elem[0:l] == "llm-usage/calculate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleGetAgentLlmExpectedCostCalculationRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetAgentsRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "agent_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "DELETE":
												s.handleDeleteAgentRouteRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "avatar"

												if l := len("avatar"); len(elem) >= l && elem[0:l] == "avatar" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handlePostAgentAvatarRouteRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											case 'd': // Prefix: "duplicate"

												if l := len("duplicate"); len(elem) >= l && elem[0:l] == "duplicate" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleDuplicateAgentRouteRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											case 'l': // Prefix: "link"

												if l := len("link"); len(elem) >= l && elem[0:l] == "link" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetAgentLinkRouteRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										}

									}

								}

							case 'n': // Prefix: "nalytics/live-count"

								if l := len("nalytics/live-count"); len(elem) >= l && elem[0:l] == "nalytics/live-count" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetLiveCountRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						case 'b': // Prefix: "batch-calling/"

							if l := len("batch-calling/"); len(elem) >= l && elem[0:l] == "batch-calling/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "submit"
								origElem := elem
								if l := len("submit"); len(elem) >= l && elem[0:l] == "submit" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleCreateBatchCallRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							case 'w': // Prefix: "workspace"
								origElem := elem
								if l := len("workspace"); len(elem) >= l && elem[0:l] == "workspace" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetWorkspaceBatchCallsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}
							// Param: "batch_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetBatchCallRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "cancel"

									if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCancelBatchCallRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'r': // Prefix: "retry"

									if l := len("retry"); len(elem) >= l && elem[0:l] == "retry" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRetryBatchCallRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'c': // Prefix: "conversation"

							if l := len("conversation"); len(elem) >= l && elem[0:l] == "conversation" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'g': // Prefix: "get"

									if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-signed-url"

										if l := len("-signed-url"); len(elem) >= l && elem[0:l] == "-signed-url" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetConversationSignedLinkRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case '_': // Prefix: "_signed_url"

										if l := len("_signed_url"); len(elem) >= l && elem[0:l] == "_signed_url" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetSignedURLDeprecatedRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								case 't': // Prefix: "token"

									if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetLivekitTokenRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 's': // Prefix: "s"

								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetConversationHistoriesRouteRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "conversation_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handleDeleteConversationRouteRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetConversationHistoryRouteRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "audio"

											if l := len("audio"); len(elem) >= l && elem[0:l] == "audio" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetConversationAudioRouteRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'f': // Prefix: "feedback"

											if l := len("feedback"); len(elem) >= l && elem[0:l] == "feedback" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handlePostConversationFeedbackRouteRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

								}

							}

						case 'k': // Prefix: "knowledge-base"

							if l := len("knowledge-base"); len(elem) >= l && elem[0:l] == "knowledge-base" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetKnowledgeBaseListRouteRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleAddDocumentationToKnowledgeBaseRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'f': // Prefix: "file"
									origElem := elem
									if l := len("file"); len(elem) >= l && elem[0:l] == "file" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCreateFileDocumentRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'r': // Prefix: "rag-index"
									origElem := elem
									if l := len("rag-index"); len(elem) >= l && elem[0:l] == "rag-index" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetRagIndexOverviewRequest([0]string{}, elemIsEscaped, w, r)
										case "POST":
											s.handleGetOrCreateRagIndexesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}

									elem = origElem
								case 's': // Prefix: "summaries"
									origElem := elem
									if l := len("summaries"); len(elem) >= l && elem[0:l] == "summaries" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetAgentKnowledgeBaseSummariesRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								case 't': // Prefix: "text"
									origElem := elem
									if l := len("text"); len(elem) >= l && elem[0:l] == "text" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCreateTextDocumentRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'u': // Prefix: "url"
									origElem := elem
									if l := len("url"); len(elem) >= l && elem[0:l] == "url" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleCreateURLDocumentRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "documentation_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteKnowledgeBaseDocumentRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetDocumentationFromKnowledgeBaseRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateDocumentRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "c"

										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "hunk/"

											if l := len("hunk/"); len(elem) >= l && elem[0:l] == "hunk/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "chunk_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetDocumentationChunkFromKnowledgeBaseRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										case 'o': // Prefix: "ontent"

											if l := len("ontent"); len(elem) >= l && elem[0:l] == "ontent" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "GET":
													s.handleGetKnowledgeBaseContentRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}

										}

									case 'd': // Prefix: "dependent-agents"

										if l := len("dependent-agents"); len(elem) >= l && elem[0:l] == "dependent-agents" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetKnowledgeBaseDependentAgentsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 'r': // Prefix: "rag-index"

										if l := len("rag-index"); len(elem) >= l && elem[0:l] == "rag-index" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleGetRagIndexesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "POST":
												s.handleRagIndexStatusRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "rag_index_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDeleteRagIndexRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}

										}

									}

								}

							}

						case 'l': // Prefix: "llm-usage/calculate"

							if l := len("llm-usage/calculate"); len(elem) >= l && elem[0:l] == "llm-usage/calculate" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleGetPublicLlmExpectedCostCalculationRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'm': // Prefix: "mcp-servers/"

							if l := len("mcp-servers/"); len(elem) >= l && elem[0:l] == "mcp-servers/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "mcp_server_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteMcpServerRouteRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/tool"

								if l := len("/tool"); len(elem) >= l && elem[0:l] == "/tool" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '-': // Prefix: "-configs/"

									if l := len("-configs/"); len(elem) >= l && elem[0:l] == "-configs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tool_name"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetMcpToolConfigOverrideRouteRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListMcpServerToolsRouteRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 'p': // Prefix: "phone-numbers"

							if l := len("phone-numbers"); len(elem) >= l && elem[0:l] == "phone-numbers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListPhoneNumbersRouteRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "phone_number_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeletePhoneNumberRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetPhoneNumberRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdatePhoneNumberRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PATCH")
									}

									return
								}

							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "e"

								if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "crets"

									if l := len("crets"); len(elem) >= l && elem[0:l] == "crets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetSecretsRouteRequest([0]string{}, elemIsEscaped, w, r)
										case "POST":
											s.handleCreateSecretRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "secret_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleDeleteSecretRouteRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleUpdateSecretRouteRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,PATCH")
											}

											return
										}

									}

								case 't': // Prefix: "ttings"

									if l := len("ttings"); len(elem) >= l && elem[0:l] == "ttings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetSettingsRouteRequest([0]string{}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleUpdateSettingsRouteRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,PATCH")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/dashboard"

										if l := len("/dashboard"); len(elem) >= l && elem[0:l] == "/dashboard" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetDashboardSettingsRouteRequest([0]string{}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleUpdateDashboardSettingsRouteRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET,PATCH")
											}

											return
										}

									}

								}

							case 'i': // Prefix: "ip-trunk/outbound-call"

								if l := len("ip-trunk/outbound-call"); len(elem) >= l && elem[0:l] == "ip-trunk/outbound-call" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleHandleSipTrunkOutboundCallRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 't': // Prefix: "t"

							if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "est-invocations"

								if l := len("est-invocations"); len(elem) >= l && elem[0:l] == "est-invocations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListTestInvocationsRouteRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "test_invocation_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetTestInvocationRouteRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'o': // Prefix: "ools/"

								if l := len("ools/"); len(elem) >= l && elem[0:l] == "ools/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tool_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteToolRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/dependent-agents"

									if l := len("/dependent-agents"); len(elem) >= l && elem[0:l] == "/dependent-agents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetToolDependentAgentsRouteRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							case 'w': // Prefix: "wilio/"

								if l := len("wilio/"); len(elem) >= l && elem[0:l] == "wilio/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'o': // Prefix: "outbound-call"

									if l := len("outbound-call"); len(elem) >= l && elem[0:l] == "outbound-call" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleHandleTwilioOutboundCallRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'r': // Prefix: "register-call"

									if l := len("register-call"); len(elem) >= l && elem[0:l] == "register-call" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRegisterTwilioCallRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'w': // Prefix: "whatsapp"

							if l := len("whatsapp"); len(elem) >= l && elem[0:l] == "whatsapp" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '-': // Prefix: "-accounts"

								if l := len("-accounts"); len(elem) >= l && elem[0:l] == "-accounts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListWhatsappAccountsRequest([0]string{}, elemIsEscaped, w, r)
									case "POST":
										s.handleImportWhatsappAccountRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "phone_number_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteWhatsappAccountRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetWhatsappAccountRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "PATCH":
											s.handleUpdateWhatsappAccountRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PATCH")
										}

										return
									}

								}

							case '/': // Prefix: "/outbound-call"

								if l := len("/outbound-call"); len(elem) >= l && elem[0:l] == "/outbound-call" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleWhatsappOutboundCallRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						}

					case 'd': // Prefix: "dubbing"

						if l := len("dubbing"); len(elem) >= l && elem[0:l] == "dubbing" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListDubsRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateDubbingRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "resource/"
								origElem := elem
								if l := len("resource/"); len(elem) >= l && elem[0:l] == "resource/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "dubbing_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleGetDubbingResourceRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "dub"

										if l := len("dub"); len(elem) >= l && elem[0:l] == "dub" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleDubRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 'l': // Prefix: "language"

										if l := len("language"); len(elem) >= l && elem[0:l] == "language" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleAddLanguageRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 'm': // Prefix: "migrate-segments"

										if l := len("migrate-segments"); len(elem) >= l && elem[0:l] == "migrate-segments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleMigrateSegmentsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "egment/"

											if l := len("egment/"); len(elem) >= l && elem[0:l] == "egment/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "segment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleDeleteSegmentRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "language"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "PATCH":
														s.handleUpdateSegmentLanguageRequest([3]string{
															args[0],
															args[1],
															args[2],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PATCH")
													}

													return
												}

											}

										case 'p': // Prefix: "peaker"

											if l := len("peaker"); len(elem) >= l && elem[0:l] == "peaker" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "POST":
													s.handleCreateSpeakerRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "speaker_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "PATCH":
														s.handleUpdateSpeakerRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "PATCH")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/s"

													if l := len("/s"); len(elem) >= l && elem[0:l] == "/s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "egment"

														if l := len("egment"); len(elem) >= l && elem[0:l] == "egment" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handleCreateClipRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}

													case 'i': // Prefix: "imilar-voices"

														if l := len("imilar-voices"); len(elem) >= l && elem[0:l] == "imilar-voices" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "GET":
																s.handleGetSimilarVoicesForSpeakerRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}

													}

												}

											}

										}

									case 't': // Prefix: "trans"

										if l := len("trans"); len(elem) >= l && elem[0:l] == "trans" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "cribe"

											if l := len("cribe"); len(elem) >= l && elem[0:l] == "cribe" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleTranscribeRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										case 'l': // Prefix: "late"

											if l := len("late"); len(elem) >= l && elem[0:l] == "late" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleTranslateRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

								}

								elem = origElem
							}
							// Param: "dubbing_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteDubbingRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetDubbedMetadataRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "audio/"

									if l := len("audio/"); len(elem) >= l && elem[0:l] == "audio/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "language_code"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetDubbedFileRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								case 't': // Prefix: "transcript/"

									if l := len("transcript/"); len(elem) >= l && elem[0:l] == "transcript/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "language_code"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetDubbedTranscriptFileRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						}

					case 'f': // Prefix: "forced-alignment"

						if l := len("forced-alignment"); len(elem) >= l && elem[0:l] == "forced-alignment" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleForcedAlignmentRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

					case 'h': // Prefix: "history"

						if l := len("history"); len(elem) >= l && elem[0:l] == "history" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetSpeechHistoryRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "download"
								origElem := elem
								if l := len("download"); len(elem) >= l && elem[0:l] == "download" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleDownloadSpeechHistoryItemsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "history_item_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteSpeechHistoryItemRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetSpeechHistoryItemByIDRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/audio"

								if l := len("/audio"); len(elem) >= l && elem[0:l] == "/audio" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetAudioFullFromSpeechHistoryItemRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					case 'm': // Prefix: "m"

						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'o': // Prefix: "odels"

							if l := len("odels"); len(elem) >= l && elem[0:l] == "odels" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetModelsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'u': // Prefix: "usic"

							if l := len("usic"); len(elem) >= l && elem[0:l] == "usic" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleGenerateRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "detailed"

									if l := len("detailed"); len(elem) >= l && elem[0:l] == "detailed" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleComposeDetailedRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'p': // Prefix: "plan"

									if l := len("plan"); len(elem) >= l && elem[0:l] == "plan" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleComposePlanRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 's': // Prefix: "st"

									if l := len("st"); len(elem) >= l && elem[0:l] == "st" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "em-separation"

										if l := len("em-separation"); len(elem) >= l && elem[0:l] == "em-separation" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleSeparateSongStemsRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 'r': // Prefix: "ream"

										if l := len("ream"); len(elem) >= l && elem[0:l] == "ream" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleStreamComposeRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								}

							}

						}

					case 'p': // Prefix: "pronunciation-dictionaries"

						if l := len("pronunciation-dictionaries"); len(elem) >= l && elem[0:l] == "pronunciation-dictionaries" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetPronunciationDictionariesMetadataRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "add-from-file"
								origElem := elem
								if l := len("add-from-file"); len(elem) >= l && elem[0:l] == "add-from-file" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleAddFromFileRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "pronunciation_dictionary_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetPronunciationDictionaryMetadataRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PATCH":
									s.handlePatchPronunciationDictionaryRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,PATCH")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'r': // Prefix: "remove-rules"
									origElem := elem
									if l := len("remove-rules"); len(elem) >= l && elem[0:l] == "remove-rules" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRemoveRulesRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "version_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/download"

									if l := len("/download"); len(elem) >= l && elem[0:l] == "/download" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetPronunciationDictionaryVersionPlsRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ervice-accounts"

							if l := len("ervice-accounts"); len(elem) >= l && elem[0:l] == "ervice-accounts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetWorkspaceServiceAccountsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "service_account_user_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/api-keys"

									if l := len("/api-keys"); len(elem) >= l && elem[0:l] == "/api-keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleGetServiceAccountAPIKeysRouteRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "POST":
											s.handleCreateServiceAccountAPIKeyRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET,POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "api_key_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleDeleteServiceAccountAPIKeyRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											case "PATCH":
												s.handleEditServiceAccountAPIKeyRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,PATCH")
											}

											return
										}

									}

								}

							}

						case 'h': // Prefix: "hared-voices"

							if l := len("hared-voices"); len(elem) >= l && elem[0:l] == "hared-voices" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetLibraryVoicesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'i': // Prefix: "i"

							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'm': // Prefix: "milar-voices"

								if l := len("milar-voices"); len(elem) >= l && elem[0:l] == "milar-voices" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleGetSimilarLibraryVoicesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'n': // Prefix: "ngle-use-token/"

								if l := len("ngle-use-token/"); len(elem) >= l && elem[0:l] == "ngle-use-token/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "token_type"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleGetSingleUseTokenRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

						case 'o': // Prefix: "ound-generation"

							if l := len("ound-generation"); len(elem) >= l && elem[0:l] == "ound-generation" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleSoundGenerationRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'p': // Prefix: "peech-to-"

							if l := len("peech-to-"); len(elem) >= l && elem[0:l] == "peech-to-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "speech/"

								if l := len("speech/"); len(elem) >= l && elem[0:l] == "speech/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "voice_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleSpeechToSpeechFullRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/stream"

									if l := len("/stream"); len(elem) >= l && elem[0:l] == "/stream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleSpeechToSpeechStreamRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							case 't': // Prefix: "text"

								if l := len("text"); len(elem) >= l && elem[0:l] == "text" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleSpeechToTextRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/transcripts/"

									if l := len("/transcripts/"); len(elem) >= l && elem[0:l] == "/transcripts/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "transcription_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteTranscriptByIDRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetTranscriptByIDRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET")
										}

										return
									}

								}

							}

						case 't': // Prefix: "tudio/projects"

							if l := len("tudio/projects"); len(elem) >= l && elem[0:l] == "tudio/projects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetProjectsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleAddProjectRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteProjectRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleEditProjectRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "c"

										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "hapters"

											if l := len("hapters"); len(elem) >= l && elem[0:l] == "hapters" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleGetChaptersRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "chapter_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch r.Method {
													case "DELETE":
														s.handleDeleteChapterEndpointRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "DELETE")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "convert"

														if l := len("convert"); len(elem) >= l && elem[0:l] == "convert" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch r.Method {
															case "POST":
																s.handleConvertChapterEndpointRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "POST")
															}

															return
														}

													case 's': // Prefix: "snapshots"

														if l := len("snapshots"); len(elem) >= l && elem[0:l] == "snapshots" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch r.Method {
															case "GET":
																s.handleGetChapterSnapshotsRequest([2]string{
																	args[0],
																	args[1],
																}, elemIsEscaped, w, r)
															default:
																s.notAllowed(w, r, "GET")
															}

															return
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "chapter_snapshot_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch r.Method {
																case "GET":
																	s.handleGetChapterSnapshotEndpointRequest([3]string{
																		args[0],
																		args[1],
																		args[2],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}
															switch elem[0] {
															case '/': // Prefix: "/stream"

																if l := len("/stream"); len(elem) >= l && elem[0:l] == "/stream" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleStreamChapterSnapshotAudioRequest([3]string{
																			args[0],
																			args[1],
																			args[2],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}

															}

														}

													}

												}

											}

										case 'o': // Prefix: "on"

											if l := len("on"); len(elem) >= l && elem[0:l] == "on" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 't': // Prefix: "tent"

												if l := len("tent"); len(elem) >= l && elem[0:l] == "tent" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleEditProjectContentRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											case 'v': // Prefix: "vert"

												if l := len("vert"); len(elem) >= l && elem[0:l] == "vert" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleConvertProjectEndpointRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											}

										}

									case 'p': // Prefix: "pronunciation-dictionaries"

										if l := len("pronunciation-dictionaries"); len(elem) >= l && elem[0:l] == "pronunciation-dictionaries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleUpdatePronunciationDictionariesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 's': // Prefix: "snapshots"

										if l := len("snapshots"); len(elem) >= l && elem[0:l] == "snapshots" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch r.Method {
											case "GET":
												s.handleGetProjectSnapshotsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "project_snapshot_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleGetProjectSnapshotEndpointRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "archive"

													if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleStreamProjectSnapshotArchiveEndpointRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												case 's': // Prefix: "stream"

													if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch r.Method {
														case "POST":
															s.handleStreamProjectSnapshotAudioEndpointRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "POST")
														}

														return
													}

												}

											}

										}

									}

								}

							}

						}

					case 't': // Prefix: "text-to-"

						if l := len("text-to-"); len(elem) >= l && elem[0:l] == "text-to-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "dialogue"

							if l := len("dialogue"); len(elem) >= l && elem[0:l] == "dialogue" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleTextToDialogueRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "stream"

									if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleTextToDialogueStreamRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/with-timestamps"

										if l := len("/with-timestamps"); len(elem) >= l && elem[0:l] == "/with-timestamps" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleTextToDialogueStreamWithTimestampsRequest([0]string{}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								case 'w': // Prefix: "with-timestamps"

									if l := len("with-timestamps"); len(elem) >= l && elem[0:l] == "with-timestamps" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleTextToDialogueFullWithTimestampsRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 's': // Prefix: "speech/"

							if l := len("speech/"); len(elem) >= l && elem[0:l] == "speech/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "voice_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleTextToSpeechFullRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "stream"

									if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleTextToSpeechStreamRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/with-timestamps"

										if l := len("/with-timestamps"); len(elem) >= l && elem[0:l] == "/with-timestamps" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleTextToSpeechStreamWithTimestampsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

								case 'w': // Prefix: "with-timestamps"

									if l := len("with-timestamps"); len(elem) >= l && elem[0:l] == "with-timestamps" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleTextToSpeechFullWithTimestampsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'v': // Prefix: "voice"

							if l := len("voice"); len(elem) >= l && elem[0:l] == "voice" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleCreateVoiceRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "create-previews"
									origElem := elem
									if l := len("create-previews"); len(elem) >= l && elem[0:l] == "create-previews" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleTextToVoiceRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								case 'd': // Prefix: "design"
									origElem := elem
									if l := len("design"); len(elem) >= l && elem[0:l] == "design" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleTextToVoiceDesignRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

									elem = origElem
								}
								// Param: "generated_voice_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'r': // Prefix: "remix"

										if l := len("remix"); len(elem) >= l && elem[0:l] == "remix" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleTextToVoiceRemixRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 's': // Prefix: "stream"

										if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleTextToVoicePreviewStreamRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						}

					case 'u': // Prefix: "us"

						if l := len("us"); len(elem) >= l && elem[0:l] == "us" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "age/character-stats"

							if l := len("age/character-stats"); len(elem) >= l && elem[0:l] == "age/character-stats" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleUsageCharactersRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						case 'e': // Prefix: "er"

							if l := len("er"); len(elem) >= l && elem[0:l] == "er" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetUserInfoRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					case 'v': // Prefix: "voice"

						if l := len("voice"); len(elem) >= l && elem[0:l] == "voice" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-generation/"

							if l := len("-generation/"); len(elem) >= l && elem[0:l] == "-generation/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "create-voice"

								if l := len("create-voice"); len(elem) >= l && elem[0:l] == "create-voice" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleCreateVoiceOldRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							case 'g': // Prefix: "generate-voice"

								if l := len("generate-voice"); len(elem) >= l && elem[0:l] == "generate-voice" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleGenerateRandomVoiceRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/parameters"

									if l := len("/parameters"); len(elem) >= l && elem[0:l] == "/parameters" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetGenerateVoiceParametersRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

								}

							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetVoicesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "add"
									origElem := elem
									if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleAddVoiceRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "public_user_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "voice_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleAddSharingVoiceRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

									}

									elem = origElem
								case 'p': // Prefix: "pvc"
									origElem := elem
									if l := len("pvc"); len(elem) >= l && elem[0:l] == "pvc" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "POST":
											s.handleCreatePvcVoiceRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "voice_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch r.Method {
											case "POST":
												s.handleEditPvcVoiceRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "captcha"

												if l := len("captcha"); len(elem) >= l && elem[0:l] == "captcha" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetPvcVoiceCaptchaRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													case "POST":
														s.handleVerifyPvcVoiceCaptchaRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET,POST")
													}

													return
												}

											case 's': // Prefix: "samples"

												if l := len("samples"); len(elem) >= l && elem[0:l] == "samples" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch r.Method {
													case "POST":
														s.handleAddPvcVoiceSamplesRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "sample_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[1] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch r.Method {
														case "DELETE":
															s.handleDeletePvcVoiceSampleRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														case "POST":
															s.handleEditPvcVoiceSampleRequest([2]string{
																args[0],
																args[1],
															}, elemIsEscaped, w, r)
														default:
															s.notAllowed(w, r, "DELETE,POST")
														}

														return
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'a': // Prefix: "audio"

															if l := len("audio"); len(elem) >= l && elem[0:l] == "audio" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleGetPvcSampleAudioRequest([2]string{
																		args[0],
																		args[1],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}

														case 's': // Prefix: "s"

															if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'e': // Prefix: "eparate-speakers"

																if l := len("eparate-speakers"); len(elem) >= l && elem[0:l] == "eparate-speakers" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch r.Method {
																	case "POST":
																		s.handleStartSpeakerSeparationRequest([2]string{
																			args[0],
																			args[1],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "POST")
																	}

																	return
																}

															case 'p': // Prefix: "peakers"

																if l := len("peakers"); len(elem) >= l && elem[0:l] == "peakers" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch r.Method {
																	case "GET":
																		s.handleGetPvcSampleSpeakersRequest([2]string{
																			args[0],
																			args[1],
																		}, elemIsEscaped, w, r)
																	default:
																		s.notAllowed(w, r, "GET")
																	}

																	return
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "speaker_id"
																	// Match until "/"
																	idx := strings.IndexByte(elem, '/')
																	if idx < 0 {
																		idx = len(elem)
																	}
																	args[2] = elem[:idx]
																	elem = elem[idx:]

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/audio"

																		if l := len("/audio"); len(elem) >= l && elem[0:l] == "/audio" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch r.Method {
																			case "GET":
																				s.handleGetSpeakerAudioRequest([3]string{
																					args[0],
																					args[1],
																					args[2],
																				}, elemIsEscaped, w, r)
																			default:
																				s.notAllowed(w, r, "GET")
																			}

																			return
																		}

																	}

																}

															}

														case 'w': // Prefix: "waveform"

															if l := len("waveform"); len(elem) >= l && elem[0:l] == "waveform" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch r.Method {
																case "GET":
																	s.handleGetPvcSampleVisualWaveformRequest([2]string{
																		args[0],
																		args[1],
																	}, elemIsEscaped, w, r)
																default:
																	s.notAllowed(w, r, "GET")
																}

																return
															}

														}

													}

												}

											case 't': // Prefix: "train"

												if l := len("train"); len(elem) >= l && elem[0:l] == "train" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleRunPvcVoiceTrainingRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											case 'v': // Prefix: "verification"

												if l := len("verification"); len(elem) >= l && elem[0:l] == "verification" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleRequestPvcManualVerificationRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											}

										}

									}

									elem = origElem
								case 's': // Prefix: "settings/default"
									origElem := elem
									if l := len("settings/default"); len(elem) >= l && elem[0:l] == "settings/default" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetVoiceSettingsDefaultRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}

									elem = origElem
								}
								// Param: "voice_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteVoiceRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetVoiceByIDRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "edit"

										if l := len("edit"); len(elem) >= l && elem[0:l] == "edit" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleEditVoiceRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "amples/"

											if l := len("amples/"); len(elem) >= l && elem[0:l] == "amples/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "sample_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch r.Method {
												case "DELETE":
													s.handleDeleteSampleRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/audio"

												if l := len("/audio"); len(elem) >= l && elem[0:l] == "/audio" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "GET":
														s.handleGetAudioFromSampleRequest([2]string{
															args[0],
															args[1],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "GET")
													}

													return
												}

											}

										case 'e': // Prefix: "ettings"

											if l := len("ettings"); len(elem) >= l && elem[0:l] == "ettings" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch r.Method {
												case "GET":
													s.handleGetVoiceSettingsRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "GET")
												}

												return
											}
											switch elem[0] {
											case '/': // Prefix: "/edit"

												if l := len("/edit"); len(elem) >= l && elem[0:l] == "/edit" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch r.Method {
													case "POST":
														s.handleEditVoiceSettingsRequest([1]string{
															args[0],
														}, elemIsEscaped, w, r)
													default:
														s.notAllowed(w, r, "POST")
													}

													return
												}

											}

										}

									}

								}

							}

						}

					case 'w': // Prefix: "workspace/"

						if l := len("workspace/"); len(elem) >= l && elem[0:l] == "workspace/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "groups/"

							if l := len("groups/"); len(elem) >= l && elem[0:l] == "groups/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "search"
								origElem := elem
								if l := len("search"); len(elem) >= l && elem[0:l] == "search" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleSearchGroupsRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

								elem = origElem
							}
							// Param: "group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/members"

								if l := len("/members"); len(elem) >= l && elem[0:l] == "/members" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleAddMemberRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/remove"

									if l := len("/remove"); len(elem) >= l && elem[0:l] == "/remove" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRemoveMemberRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'i': // Prefix: "invites"

							if l := len("invites"); len(elem) >= l && elem[0:l] == "invites" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteInviteRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/add"

								if l := len("/add"); len(elem) >= l && elem[0:l] == "/add" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleInviteUserRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '-': // Prefix: "-bulk"

									if l := len("-bulk"); len(elem) >= l && elem[0:l] == "-bulk" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleInviteUsersBulkRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'm': // Prefix: "members"

							if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleUpdateWorkspaceMemberRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						case 'r': // Prefix: "resources/"

							if l := len("resources/"); len(elem) >= l && elem[0:l] == "resources/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "resource_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetResourceMetadataRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "share"

									if l := len("share"); len(elem) >= l && elem[0:l] == "share" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleShareResourceEndpointRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								case 'u': // Prefix: "unshare"

									if l := len("unshare"); len(elem) >= l && elem[0:l] == "unshare" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleUnshareResourceEndpointRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}

								}

							}

						case 'w': // Prefix: "webhooks"

							if l := len("webhooks"); len(elem) >= l && elem[0:l] == "webhooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetWorkspaceWebhooksRouteRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateWorkspaceWebhookRouteRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "webhook_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteWorkspaceWebhookRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleEditWorkspaceWebhookRouteRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,PATCH")
									}

									return
								}

							}

						}

					}

				case '2': // Prefix: "2/voices"

					if l := len("2/voices"); len(elem) >= l && elem[0:l] == "2/voices" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetUserVoicesV2Request([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name           string
	summary        string
	operationID    string
	operationGroup string
	pathPattern    string
	count          int
	args           [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// OperationGroup returns the x-ogen-operation-group value.
func (r Route) OperationGroup() string {
	return r.operationGroup
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"

			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'd': // Prefix: "docs"

				if l := len("docs"); len(elem) >= l && elem[0:l] == "docs" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = RedirectToMintlifyOperation
						r.summary = "Redirect To Mintlify"
						r.operationID = "redirect_to_mintlify"
						r.operationGroup = ""
						r.pathPattern = "/docs"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			case 'v': // Prefix: "v"

				if l := len("v"); len(elem) >= l && elem[0:l] == "v" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '1': // Prefix: "1/"

					if l := len("1/"); len(elem) >= l && elem[0:l] == "1/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'a': // Prefix: "audio-"

						if l := len("audio-"); len(elem) >= l && elem[0:l] == "audio-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'i': // Prefix: "isolation"

							if l := len("isolation"); len(elem) >= l && elem[0:l] == "isolation" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = AudioIsolationOperation
									r.summary = "Audio Isolation"
									r.operationID = "audio_isolation"
									r.operationGroup = ""
									r.pathPattern = "/v1/audio-isolation"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/stream"

								if l := len("/stream"); len(elem) >= l && elem[0:l] == "/stream" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = AudioIsolationStreamOperation
										r.summary = "Audio Isolation Stream"
										r.operationID = "audio_isolation_stream"
										r.operationGroup = ""
										r.pathPattern = "/v1/audio-isolation/stream"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'n': // Prefix: "native"

							if l := len("native"); len(elem) >= l && elem[0:l] == "native" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = CreateAudioNativeProjectOperation
									r.summary = "Creates Audio Native Enabled Project."
									r.operationID = "create_audio_native_project"
									r.operationGroup = ""
									r.pathPattern = "/v1/audio-native"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "content"

										if l := len("content"); len(elem) >= l && elem[0:l] == "content" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AudioNativeProjectUpdateContentEndpointOperation
												r.summary = "Update Audio-Native Project Content"
												r.operationID = "audio_native_project_update_content_endpoint"
												r.operationGroup = ""
												r.pathPattern = "/v1/audio-native/{project_id}/content"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "settings"

										if l := len("settings"); len(elem) >= l && elem[0:l] == "settings" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetAudioNativeProjectSettingsEndpointOperation
												r.summary = "Get Audio Native Project Settings"
												r.operationID = "get_audio_native_project_settings_endpoint"
												r.operationGroup = ""
												r.pathPattern = "/v1/audio-native/{project_id}/settings"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'c': // Prefix: "convai/"

						if l := len("convai/"); len(elem) >= l && elem[0:l] == "convai/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "a"

							if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "gent"

								if l := len("gent"); len(elem) >= l && elem[0:l] == "gent" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '-': // Prefix: "-testing"

									if l := len("-testing"); len(elem) >= l && elem[0:l] == "-testing" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = ListChatResponseTestsRouteOperation
											r.summary = "List Agent Response Tests"
											r.operationID = "list_chat_response_tests_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/agent-testing"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "create"
											origElem := elem
											if l := len("create"); len(elem) >= l && elem[0:l] == "create" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = CreateAgentResponseTestRouteOperation
													r.summary = "Create Agent Response Test"
													r.operationID = "create_agent_response_test_route"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/agent-testing/create"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										case 's': // Prefix: "summaries"
											origElem := elem
											if l := len("summaries"); len(elem) >= l && elem[0:l] == "summaries" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = GetAgentResponseTestsSummariesRouteOperation
													r.summary = "Get Agent Response Test Summaries By Ids"
													r.operationID = "get_agent_response_tests_summaries_route"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/agent-testing/summaries"
													r.args = args
													r.count = 0
													return r, true
												default:
													return
												}
											}

											elem = origElem
										}
										// Param: "test_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = DeleteChatResponseTestRouteOperation
												r.summary = "Delete Agent Response Test"
												r.operationID = "delete_chat_response_test_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/agent-testing/{test_id}"
												r.args = args
												r.count = 1
												return r, true
											case "GET":
												r.name = GetAgentResponseTestRouteOperation
												r.summary = "Get Agent Response Test By Id"
												r.operationID = "get_agent_response_test_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/agent-testing/{test_id}"
												r.args = args
												r.count = 1
												return r, true
											case "PUT":
												r.name = UpdateAgentResponseTestRouteOperation
												r.summary = "Update Agent Response Test"
												r.operationID = "update_agent_response_test_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/agent-testing/{test_id}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "agent_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'k': // Prefix: "knowledge-base/size"

											if l := len("knowledge-base/size"); len(elem) >= l && elem[0:l] == "knowledge-base/size" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetAgentKnowledgeBaseSizeOperation
													r.summary = "Returns The Size Of The Agent'S Knowledge Base"
													r.operationID = "get_agent_knowledge_base_size"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/agent/{agent_id}/knowledge-base/size"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										case 'l': // Prefix: "llm-usage/calculate"

											if l := len("llm-usage/calculate"); len(elem) >= l && elem[0:l] == "llm-usage/calculate" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = GetAgentLlmExpectedCostCalculationOperation
													r.summary = "Calculate Expected Llm Usage For An Agent"
													r.operationID = "get_agent_llm_expected_cost_calculation"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/agent/{agent_id}/llm-usage/calculate"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetAgentsRouteOperation
											r.summary = "List Agents"
											r.operationID = "get_agents_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/agents"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "agent_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "DELETE":
												r.name = DeleteAgentRouteOperation
												r.summary = "Delete Agent"
												r.operationID = "delete_agent_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/agents/{agent_id}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'a': // Prefix: "avatar"

												if l := len("avatar"); len(elem) >= l && elem[0:l] == "avatar" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = PostAgentAvatarRouteOperation
														r.summary = "Post Agent Avatar"
														r.operationID = "post_agent_avatar_route"
														r.operationGroup = ""
														r.pathPattern = "/v1/convai/agents/{agent_id}/avatar"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											case 'd': // Prefix: "duplicate"

												if l := len("duplicate"); len(elem) >= l && elem[0:l] == "duplicate" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = DuplicateAgentRouteOperation
														r.summary = "Duplicate Agent"
														r.operationID = "duplicate_agent_route"
														r.operationGroup = ""
														r.pathPattern = "/v1/convai/agents/{agent_id}/duplicate"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											case 'l': // Prefix: "link"

												if l := len("link"); len(elem) >= l && elem[0:l] == "link" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = GetAgentLinkRouteOperation
														r.summary = "Get Shareable Agent Link"
														r.operationID = "get_agent_link_route"
														r.operationGroup = ""
														r.pathPattern = "/v1/convai/agents/{agent_id}/link"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											}

										}

									}

								}

							case 'n': // Prefix: "nalytics/live-count"

								if l := len("nalytics/live-count"); len(elem) >= l && elem[0:l] == "nalytics/live-count" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetLiveCountOperation
										r.summary = "Get Live Count"
										r.operationID = "get_live_count"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/analytics/live-count"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 'b': // Prefix: "batch-calling/"

							if l := len("batch-calling/"); len(elem) >= l && elem[0:l] == "batch-calling/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "submit"
								origElem := elem
								if l := len("submit"); len(elem) >= l && elem[0:l] == "submit" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = CreateBatchCallOperation
										r.summary = "Submit A Batch Call Request."
										r.operationID = "create_batch_call"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/batch-calling/submit"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							case 'w': // Prefix: "workspace"
								origElem := elem
								if l := len("workspace"); len(elem) >= l && elem[0:l] == "workspace" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetWorkspaceBatchCallsOperation
										r.summary = "Get All Batch Calls For A Workspace."
										r.operationID = "get_workspace_batch_calls"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/batch-calling/workspace"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "batch_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetBatchCallOperation
									r.summary = "Get A Batch Call By Id."
									r.operationID = "get_batch_call"
									r.operationGroup = ""
									r.pathPattern = "/v1/convai/batch-calling/{batch_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "cancel"

									if l := len("cancel"); len(elem) >= l && elem[0:l] == "cancel" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = CancelBatchCallOperation
											r.summary = "Cancel A Batch Call."
											r.operationID = "cancel_batch_call"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/batch-calling/{batch_id}/cancel"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "retry"

									if l := len("retry"); len(elem) >= l && elem[0:l] == "retry" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = RetryBatchCallOperation
											r.summary = "Retry A Batch Call."
											r.operationID = "retry_batch_call"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/batch-calling/{batch_id}/retry"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'c': // Prefix: "conversation"

							if l := len("conversation"); len(elem) >= l && elem[0:l] == "conversation" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'g': // Prefix: "get"

									if l := len("get"); len(elem) >= l && elem[0:l] == "get" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '-': // Prefix: "-signed-url"

										if l := len("-signed-url"); len(elem) >= l && elem[0:l] == "-signed-url" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetConversationSignedLinkOperation
												r.summary = "Get Signed Url"
												r.operationID = "get_conversation_signed_link"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/conversation/get-signed-url"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									case '_': // Prefix: "_signed_url"

										if l := len("_signed_url"); len(elem) >= l && elem[0:l] == "_signed_url" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetSignedURLDeprecatedOperation
												r.summary = "Get Signed Url"
												r.operationID = "get_signed_url_deprecated"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/conversation/get_signed_url"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								case 't': // Prefix: "token"

									if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetLivekitTokenOperation
											r.summary = "Get Webrtc Token"
											r.operationID = "get_livekit_token"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/conversation/token"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							case 's': // Prefix: "s"

								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = GetConversationHistoriesRouteOperation
										r.summary = "Get Conversations"
										r.operationID = "get_conversation_histories_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/conversations"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "conversation_id"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[0] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = DeleteConversationRouteOperation
											r.summary = "Delete Conversation"
											r.operationID = "delete_conversation_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/conversations/{conversation_id}"
											r.args = args
											r.count = 1
											return r, true
										case "GET":
											r.name = GetConversationHistoryRouteOperation
											r.summary = "Get Conversation Details"
											r.operationID = "get_conversation_history_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/conversations/{conversation_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "audio"

											if l := len("audio"); len(elem) >= l && elem[0:l] == "audio" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetConversationAudioRouteOperation
													r.summary = "Get Conversation Audio"
													r.operationID = "get_conversation_audio_route"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/conversations/{conversation_id}/audio"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										case 'f': // Prefix: "feedback"

											if l := len("feedback"); len(elem) >= l && elem[0:l] == "feedback" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = PostConversationFeedbackRouteOperation
													r.summary = "Send Conversation Feedback"
													r.operationID = "post_conversation_feedback_route"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/conversations/{conversation_id}/feedback"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							}

						case 'k': // Prefix: "knowledge-base"

							if l := len("knowledge-base"); len(elem) >= l && elem[0:l] == "knowledge-base" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetKnowledgeBaseListRouteOperation
									r.summary = "Get Knowledge Base List"
									r.operationID = "get_knowledge_base_list_route"
									r.operationGroup = ""
									r.pathPattern = "/v1/convai/knowledge-base"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = AddDocumentationToKnowledgeBaseOperation
									r.summary = "Add To Knowledge Base"
									r.operationID = "add_documentation_to_knowledge_base"
									r.operationGroup = ""
									r.pathPattern = "/v1/convai/knowledge-base"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'f': // Prefix: "file"
									origElem := elem
									if l := len("file"); len(elem) >= l && elem[0:l] == "file" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = CreateFileDocumentRouteOperation
											r.summary = "Create File Document"
											r.operationID = "create_file_document_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/knowledge-base/file"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'r': // Prefix: "rag-index"
									origElem := elem
									if l := len("rag-index"); len(elem) >= l && elem[0:l] == "rag-index" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetRagIndexOverviewOperation
											r.summary = "Get Rag Index Overview."
											r.operationID = "get_rag_index_overview"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/knowledge-base/rag-index"
											r.args = args
											r.count = 0
											return r, true
										case "POST":
											r.name = GetOrCreateRagIndexesOperation
											r.summary = "Compute Rag Indexes In Batch"
											r.operationID = "get_or_create_rag_indexes"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/knowledge-base/rag-index"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 's': // Prefix: "summaries"
									origElem := elem
									if l := len("summaries"); len(elem) >= l && elem[0:l] == "summaries" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetAgentKnowledgeBaseSummariesRouteOperation
											r.summary = "Get Knowledge Base Summaries By Ids"
											r.operationID = "get_agent_knowledge_base_summaries_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/knowledge-base/summaries"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 't': // Prefix: "text"
									origElem := elem
									if l := len("text"); len(elem) >= l && elem[0:l] == "text" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = CreateTextDocumentRouteOperation
											r.summary = "Create Text Document"
											r.operationID = "create_text_document_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/knowledge-base/text"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'u': // Prefix: "url"
									origElem := elem
									if l := len("url"); len(elem) >= l && elem[0:l] == "url" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = CreateURLDocumentRouteOperation
											r.summary = "Create Url Document"
											r.operationID = "create_url_document_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/knowledge-base/url"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "documentation_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteKnowledgeBaseDocumentOperation
										r.summary = "Delete Knowledge Base Document"
										r.operationID = "delete_knowledge_base_document"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetDocumentationFromKnowledgeBaseOperation
										r.summary = "Get Documentation From Knowledge Base"
										r.operationID = "get_documentation_from_knowledge_base"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdateDocumentRouteOperation
										r.summary = "Update Document"
										r.operationID = "update_document_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "c"

										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "hunk/"

											if l := len("hunk/"); len(elem) >= l && elem[0:l] == "hunk/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "chunk_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetDocumentationChunkFromKnowledgeBaseOperation
													r.summary = "Get Documentation Chunk From Knowledge Base"
													r.operationID = "get_documentation_chunk_from_knowledge_base"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}/chunk/{chunk_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'o': // Prefix: "ontent"

											if l := len("ontent"); len(elem) >= l && elem[0:l] == "ontent" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "GET":
													r.name = GetKnowledgeBaseContentOperation
													r.summary = "Get Document Content"
													r.operationID = "get_knowledge_base_content"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}/content"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									case 'd': // Prefix: "dependent-agents"

										if l := len("dependent-agents"); len(elem) >= l && elem[0:l] == "dependent-agents" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetKnowledgeBaseDependentAgentsOperation
												r.summary = "Get Dependent Agents List"
												r.operationID = "get_knowledge_base_dependent_agents"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}/dependent-agents"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'r': // Prefix: "rag-index"

										if l := len("rag-index"); len(elem) >= l && elem[0:l] == "rag-index" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = GetRagIndexesOperation
												r.summary = "Get Rag Indexes Of The Specified Knowledgebase Document."
												r.operationID = "get_rag_indexes"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}/rag-index"
												r.args = args
												r.count = 1
												return r, true
											case "POST":
												r.name = RagIndexStatusOperation
												r.summary = "Compute Rag Index."
												r.operationID = "rag_index_status"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}/rag-index"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "rag_index_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = DeleteRagIndexOperation
													r.summary = "Delete Rag Index."
													r.operationID = "delete_rag_index"
													r.operationGroup = ""
													r.pathPattern = "/v1/convai/knowledge-base/{documentation_id}/rag-index/{rag_index_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									}

								}

							}

						case 'l': // Prefix: "llm-usage/calculate"

							if l := len("llm-usage/calculate"); len(elem) >= l && elem[0:l] == "llm-usage/calculate" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = GetPublicLlmExpectedCostCalculationOperation
									r.summary = "Calculate Expected Llm Usage"
									r.operationID = "get_public_llm_expected_cost_calculation"
									r.operationGroup = ""
									r.pathPattern = "/v1/convai/llm-usage/calculate"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'm': // Prefix: "mcp-servers/"

							if l := len("mcp-servers/"); len(elem) >= l && elem[0:l] == "mcp-servers/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "mcp_server_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteMcpServerRouteOperation
									r.summary = "Delete Mcp Server"
									r.operationID = "delete_mcp_server_route"
									r.operationGroup = ""
									r.pathPattern = "/v1/convai/mcp-servers/{mcp_server_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/tool"

								if l := len("/tool"); len(elem) >= l && elem[0:l] == "/tool" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '-': // Prefix: "-configs/"

									if l := len("-configs/"); len(elem) >= l && elem[0:l] == "-configs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "tool_name"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetMcpToolConfigOverrideRouteOperation
											r.summary = "Get Mcp Tool Configuration Override"
											r.operationID = "get_mcp_tool_config_override_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/mcp-servers/{mcp_server_id}/tool-configs/{tool_name}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "s"

									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = ListMcpServerToolsRouteOperation
											r.summary = "List Mcp Server Tools"
											r.operationID = "list_mcp_server_tools_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/mcp-servers/{mcp_server_id}/tools"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'p': // Prefix: "phone-numbers"

							if l := len("phone-numbers"); len(elem) >= l && elem[0:l] == "phone-numbers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = ListPhoneNumbersRouteOperation
									r.summary = "List Phone Numbers"
									r.operationID = "list_phone_numbers_route"
									r.operationGroup = ""
									r.pathPattern = "/v1/convai/phone-numbers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "phone_number_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeletePhoneNumberRouteOperation
										r.summary = "Delete Phone Number"
										r.operationID = "delete_phone_number_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/phone-numbers/{phone_number_id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetPhoneNumberRouteOperation
										r.summary = "Get Phone Number"
										r.operationID = "get_phone_number_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/phone-numbers/{phone_number_id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdatePhoneNumberRouteOperation
										r.summary = "Update Phone Number"
										r.operationID = "update_phone_number_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/phone-numbers/{phone_number_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "e"

								if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "crets"

									if l := len("crets"); len(elem) >= l && elem[0:l] == "crets" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetSecretsRouteOperation
											r.summary = "Get Convai Workspace Secrets"
											r.operationID = "get_secrets_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/secrets"
											r.args = args
											r.count = 0
											return r, true
										case "POST":
											r.name = CreateSecretRouteOperation
											r.summary = "Create Convai Workspace Secret"
											r.operationID = "create_secret_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/secrets"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "secret_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = DeleteSecretRouteOperation
												r.summary = "Delete Convai Workspace Secret"
												r.operationID = "delete_secret_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/secrets/{secret_id}"
												r.args = args
												r.count = 1
												return r, true
											case "PATCH":
												r.name = UpdateSecretRouteOperation
												r.summary = "Update Convai Workspace Secret"
												r.operationID = "update_secret_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/secrets/{secret_id}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								case 't': // Prefix: "ttings"

									if l := len("ttings"); len(elem) >= l && elem[0:l] == "ttings" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetSettingsRouteOperation
											r.summary = "Get Convai Settings"
											r.operationID = "get_settings_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/settings"
											r.args = args
											r.count = 0
											return r, true
										case "PATCH":
											r.name = UpdateSettingsRouteOperation
											r.summary = "Update Convai Settings"
											r.operationID = "update_settings_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/settings"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/dashboard"

										if l := len("/dashboard"); len(elem) >= l && elem[0:l] == "/dashboard" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetDashboardSettingsRouteOperation
												r.summary = "Get Convai Dashboard Settings"
												r.operationID = "get_dashboard_settings_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/settings/dashboard"
												r.args = args
												r.count = 0
												return r, true
											case "PATCH":
												r.name = UpdateDashboardSettingsRouteOperation
												r.summary = "Update Convai Dashboard Settings"
												r.operationID = "update_dashboard_settings_route"
												r.operationGroup = ""
												r.pathPattern = "/v1/convai/settings/dashboard"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								}

							case 'i': // Prefix: "ip-trunk/outbound-call"

								if l := len("ip-trunk/outbound-call"); len(elem) >= l && elem[0:l] == "ip-trunk/outbound-call" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = HandleSipTrunkOutboundCallOperation
										r.summary = "Handle An Outbound Call Via Sip Trunk"
										r.operationID = "handle_sip_trunk_outbound_call"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/sip-trunk/outbound-call"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						case 't': // Prefix: "t"

							if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'e': // Prefix: "est-invocations"

								if l := len("est-invocations"); len(elem) >= l && elem[0:l] == "est-invocations" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ListTestInvocationsRouteOperation
										r.summary = "List Test Invocations"
										r.operationID = "list_test_invocations_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/test-invocations"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "test_invocation_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetTestInvocationRouteOperation
											r.summary = "Get Test Invocation"
											r.operationID = "get_test_invocation_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/test-invocations/{test_invocation_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'o': // Prefix: "ools/"

								if l := len("ools/"); len(elem) >= l && elem[0:l] == "ools/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "tool_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteToolRouteOperation
										r.summary = "Delete Tool"
										r.operationID = "delete_tool_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/tools/{tool_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/dependent-agents"

									if l := len("/dependent-agents"); len(elem) >= l && elem[0:l] == "/dependent-agents" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetToolDependentAgentsRouteOperation
											r.summary = "Get Dependent Agents List"
											r.operationID = "get_tool_dependent_agents_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/tools/{tool_id}/dependent-agents"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 'w': // Prefix: "wilio/"

								if l := len("wilio/"); len(elem) >= l && elem[0:l] == "wilio/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'o': // Prefix: "outbound-call"

									if l := len("outbound-call"); len(elem) >= l && elem[0:l] == "outbound-call" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = HandleTwilioOutboundCallOperation
											r.summary = "Handle An Outbound Call Via Twilio"
											r.operationID = "handle_twilio_outbound_call"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/twilio/outbound-call"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'r': // Prefix: "register-call"

									if l := len("register-call"); len(elem) >= l && elem[0:l] == "register-call" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = RegisterTwilioCallOperation
											r.summary = "Register A Twilio Call And Return Twiml"
											r.operationID = "register_twilio_call"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/twilio/register-call"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'w': // Prefix: "whatsapp"

							if l := len("whatsapp"); len(elem) >= l && elem[0:l] == "whatsapp" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '-': // Prefix: "-accounts"

								if l := len("-accounts"); len(elem) >= l && elem[0:l] == "-accounts" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ListWhatsappAccountsOperation
										r.summary = "List Whatsapp Accounts"
										r.operationID = "list_whatsapp_accounts"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/whatsapp-accounts"
										r.args = args
										r.count = 0
										return r, true
									case "POST":
										r.name = ImportWhatsappAccountOperation
										r.summary = "Import Whatsapp Account"
										r.operationID = "import_whatsapp_account"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/whatsapp-accounts"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "phone_number_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteWhatsappAccountOperation
											r.summary = "Delete Whatsapp Account"
											r.operationID = "delete_whatsapp_account"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/whatsapp-accounts/{phone_number_id}"
											r.args = args
											r.count = 1
											return r, true
										case "GET":
											r.name = GetWhatsappAccountOperation
											r.summary = "Get Whatsapp Account"
											r.operationID = "get_whatsapp_account"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/whatsapp-accounts/{phone_number_id}"
											r.args = args
											r.count = 1
											return r, true
										case "PATCH":
											r.name = UpdateWhatsappAccountOperation
											r.summary = "Update Whatsapp Account"
											r.operationID = "update_whatsapp_account"
											r.operationGroup = ""
											r.pathPattern = "/v1/convai/whatsapp-accounts/{phone_number_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case '/': // Prefix: "/outbound-call"

								if l := len("/outbound-call"); len(elem) >= l && elem[0:l] == "/outbound-call" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = WhatsappOutboundCallOperation
										r.summary = "Make An Outbound Call Via Whatsapp"
										r.operationID = "whatsapp_outbound_call"
										r.operationGroup = ""
										r.pathPattern = "/v1/convai/whatsapp/outbound-call"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'd': // Prefix: "dubbing"

						if l := len("dubbing"); len(elem) >= l && elem[0:l] == "dubbing" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ListDubsOperation
								r.summary = "List Dubs"
								r.operationID = "list_dubs"
								r.operationGroup = ""
								r.pathPattern = "/v1/dubbing"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = CreateDubbingOperation
								r.summary = "Dub A Video Or An Audio File"
								r.operationID = "create_dubbing"
								r.operationGroup = ""
								r.pathPattern = "/v1/dubbing"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "resource/"
								origElem := elem
								if l := len("resource/"); len(elem) >= l && elem[0:l] == "resource/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "dubbing_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = GetDubbingResourceOperation
										r.summary = "Get The Dubbing Resource For An Id."
										r.operationID = "get_dubbing_resource"
										r.operationGroup = ""
										r.pathPattern = "/v1/dubbing/resource/{dubbing_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'd': // Prefix: "dub"

										if l := len("dub"); len(elem) >= l && elem[0:l] == "dub" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = DubOperation
												r.summary = "Dubs All Or Some Segments And Languages"
												r.operationID = "dub"
												r.operationGroup = ""
												r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/dub"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'l': // Prefix: "language"

										if l := len("language"); len(elem) >= l && elem[0:l] == "language" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = AddLanguageOperation
												r.summary = "Add A Language To The Resource"
												r.operationID = "add_language"
												r.operationGroup = ""
												r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/language"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 'm': // Prefix: "migrate-segments"

										if l := len("migrate-segments"); len(elem) >= l && elem[0:l] == "migrate-segments" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = MigrateSegmentsOperation
												r.summary = "Move Segments Between Speakers"
												r.operationID = "migrate_segments"
												r.operationGroup = ""
												r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/migrate-segments"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'e': // Prefix: "egment/"

											if l := len("egment/"); len(elem) >= l && elem[0:l] == "egment/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "segment_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = DeleteSegmentOperation
													r.summary = "Deletes A Single Segment"
													r.operationID = "delete_segment"
													r.operationGroup = ""
													r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/segment/{segment_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "language"
												// Leaf parameter, slashes are prohibited
												idx := strings.IndexByte(elem, '/')
												if idx >= 0 {
													break
												}
												args[2] = elem
												elem = ""

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "PATCH":
														r.name = UpdateSegmentLanguageOperation
														r.summary = "Modify A Single Segment"
														r.operationID = "update_segment_language"
														r.operationGroup = ""
														r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/segment/{segment_id}/{language}"
														r.args = args
														r.count = 3
														return r, true
													default:
														return
													}
												}

											}

										case 'p': // Prefix: "peaker"

											if l := len("peaker"); len(elem) >= l && elem[0:l] == "peaker" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "POST":
													r.name = CreateSpeakerOperation
													r.summary = "Create A New Speaker"
													r.operationID = "create_speaker"
													r.operationGroup = ""
													r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/speaker"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "speaker_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "PATCH":
														r.name = UpdateSpeakerOperation
														r.summary = "Update Metadata For A Speaker"
														r.operationID = "update_speaker"
														r.operationGroup = ""
														r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/s"

													if l := len("/s"); len(elem) >= l && elem[0:l] == "/s" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'e': // Prefix: "egment"

														if l := len("egment"); len(elem) >= l && elem[0:l] == "egment" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "POST":
																r.name = CreateClipOperation
																r.summary = "Create A Segment For The Speaker"
																r.operationID = "create_clip"
																r.operationGroup = ""
																r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/segment"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 'i': // Prefix: "imilar-voices"

														if l := len("imilar-voices"); len(elem) >= l && elem[0:l] == "imilar-voices" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "GET":
																r.name = GetSimilarVoicesForSpeakerOperation
																r.summary = "Search The Elevenlabs Library For Voices Similar To A Speaker."
																r.operationID = "get_similar_voices_for_speaker"
																r.operationGroup = ""
																r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/speaker/{speaker_id}/similar-voices"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													}

												}

											}

										}

									case 't': // Prefix: "trans"

										if l := len("trans"); len(elem) >= l && elem[0:l] == "trans" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'c': // Prefix: "cribe"

											if l := len("cribe"); len(elem) >= l && elem[0:l] == "cribe" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = TranscribeOperation
													r.summary = "Transcribes Segments"
													r.operationID = "transcribe"
													r.operationGroup = ""
													r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/transcribe"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										case 'l': // Prefix: "late"

											if l := len("late"); len(elem) >= l && elem[0:l] == "late" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = TranslateOperation
													r.summary = "Translates All Or Some Segments And Languages"
													r.operationID = "translate"
													r.operationGroup = ""
													r.pathPattern = "/v1/dubbing/resource/{dubbing_id}/translate"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

									}

								}

								elem = origElem
							}
							// Param: "dubbing_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteDubbingOperation
									r.summary = "Delete Dubbing"
									r.operationID = "delete_dubbing"
									r.operationGroup = ""
									r.pathPattern = "/v1/dubbing/{dubbing_id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetDubbedMetadataOperation
									r.summary = "Get Dubbing"
									r.operationID = "get_dubbed_metadata"
									r.operationGroup = ""
									r.pathPattern = "/v1/dubbing/{dubbing_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "audio/"

									if l := len("audio/"); len(elem) >= l && elem[0:l] == "audio/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "language_code"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetDubbedFileOperation
											r.summary = "Get Dubbed File"
											r.operationID = "get_dubbed_file"
											r.operationGroup = ""
											r.pathPattern = "/v1/dubbing/{dubbing_id}/audio/{language_code}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								case 't': // Prefix: "transcript/"

									if l := len("transcript/"); len(elem) >= l && elem[0:l] == "transcript/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "language_code"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetDubbedTranscriptFileOperation
											r.summary = "Get Dubbed Transcript"
											r.operationID = "get_dubbed_transcript_file"
											r.operationGroup = ""
											r.pathPattern = "/v1/dubbing/{dubbing_id}/transcript/{language_code}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 'f': // Prefix: "forced-alignment"

						if l := len("forced-alignment"); len(elem) >= l && elem[0:l] == "forced-alignment" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = ForcedAlignmentOperation
								r.summary = "Create Forced Alignment"
								r.operationID = "forced_alignment"
								r.operationGroup = ""
								r.pathPattern = "/v1/forced-alignment"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

					case 'h': // Prefix: "history"

						if l := len("history"); len(elem) >= l && elem[0:l] == "history" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetSpeechHistoryOperation
								r.summary = "List Generated Items"
								r.operationID = "get_speech_history"
								r.operationGroup = ""
								r.pathPattern = "/v1/history"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "download"
								origElem := elem
								if l := len("download"); len(elem) >= l && elem[0:l] == "download" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = DownloadSpeechHistoryItemsOperation
										r.summary = "Download History Items"
										r.operationID = "download_speech_history_items"
										r.operationGroup = ""
										r.pathPattern = "/v1/history/download"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "history_item_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteSpeechHistoryItemOperation
									r.summary = "Delete History Item"
									r.operationID = "delete_speech_history_item"
									r.operationGroup = ""
									r.pathPattern = "/v1/history/{history_item_id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = GetSpeechHistoryItemByIDOperation
									r.summary = "Get History Item"
									r.operationID = "get_speech_history_item_by_id"
									r.operationGroup = ""
									r.pathPattern = "/v1/history/{history_item_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/audio"

								if l := len("/audio"); len(elem) >= l && elem[0:l] == "/audio" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetAudioFullFromSpeechHistoryItemOperation
										r.summary = "Get Audio From History Item"
										r.operationID = "get_audio_full_from_speech_history_item"
										r.operationGroup = ""
										r.pathPattern = "/v1/history/{history_item_id}/audio"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					case 'm': // Prefix: "m"

						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'o': // Prefix: "odels"

							if l := len("odels"); len(elem) >= l && elem[0:l] == "odels" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetModelsOperation
									r.summary = "Get Models"
									r.operationID = "get_models"
									r.operationGroup = ""
									r.pathPattern = "/v1/models"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'u': // Prefix: "usic"

							if l := len("usic"); len(elem) >= l && elem[0:l] == "usic" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = GenerateOperation
									r.summary = "Compose Music"
									r.operationID = "generate"
									r.operationGroup = ""
									r.pathPattern = "/v1/music"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'd': // Prefix: "detailed"

									if l := len("detailed"); len(elem) >= l && elem[0:l] == "detailed" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ComposeDetailedOperation
											r.summary = "Compose Music With A Detailed Response"
											r.operationID = "compose_detailed"
											r.operationGroup = ""
											r.pathPattern = "/v1/music/detailed"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 'p': // Prefix: "plan"

									if l := len("plan"); len(elem) >= l && elem[0:l] == "plan" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ComposePlanOperation
											r.summary = "Generate Composition Plan"
											r.operationID = "compose_plan"
											r.operationGroup = ""
											r.pathPattern = "/v1/music/plan"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								case 's': // Prefix: "st"

									if l := len("st"); len(elem) >= l && elem[0:l] == "st" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "em-separation"

										if l := len("em-separation"); len(elem) >= l && elem[0:l] == "em-separation" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = SeparateSongStemsOperation
												r.summary = "Stem Separation"
												r.operationID = "separate_song_stems"
												r.operationGroup = ""
												r.pathPattern = "/v1/music/stem-separation"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									case 'r': // Prefix: "ream"

										if l := len("ream"); len(elem) >= l && elem[0:l] == "ream" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = StreamComposeOperation
												r.summary = "Stream Composed Music"
												r.operationID = "stream_compose"
												r.operationGroup = ""
												r.pathPattern = "/v1/music/stream"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'p': // Prefix: "pronunciation-dictionaries"

						if l := len("pronunciation-dictionaries"); len(elem) >= l && elem[0:l] == "pronunciation-dictionaries" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetPronunciationDictionariesMetadataOperation
								r.summary = "Get Pronunciation Dictionaries"
								r.operationID = "get_pronunciation_dictionaries_metadata"
								r.operationGroup = ""
								r.pathPattern = "/v1/pronunciation-dictionaries"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "add-from-file"
								origElem := elem
								if l := len("add-from-file"); len(elem) >= l && elem[0:l] == "add-from-file" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = AddFromFileOperation
										r.summary = "Add A Pronunciation Dictionary"
										r.operationID = "add_from_file"
										r.operationGroup = ""
										r.pathPattern = "/v1/pronunciation-dictionaries/add-from-file"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "pronunciation_dictionary_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetPronunciationDictionaryMetadataOperation
									r.summary = "Get Metadata For A Pronunciation Dictionary"
									r.operationID = "get_pronunciation_dictionary_metadata"
									r.operationGroup = ""
									r.pathPattern = "/v1/pronunciation-dictionaries/{pronunciation_dictionary_id}"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = PatchPronunciationDictionaryOperation
									r.summary = "Update Pronunciation Dictionary"
									r.operationID = "patch_pronunciation_dictionary"
									r.operationGroup = ""
									r.pathPattern = "/v1/pronunciation-dictionaries/{pronunciation_dictionary_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'r': // Prefix: "remove-rules"
									origElem := elem
									if l := len("remove-rules"); len(elem) >= l && elem[0:l] == "remove-rules" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = RemoveRulesOperation
											r.summary = "Remove Rules From The Pronunciation Dictionary"
											r.operationID = "remove_rules"
											r.operationGroup = ""
											r.pathPattern = "/v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/remove-rules"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "version_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/download"

									if l := len("/download"); len(elem) >= l && elem[0:l] == "/download" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetPronunciationDictionaryVersionPlsOperation
											r.summary = "Get A Pls File With A Pronunciation Dictionary Version Rules"
											r.operationID = "get_pronunciation_dictionary_version_pls"
											r.operationGroup = ""
											r.pathPattern = "/v1/pronunciation-dictionaries/{dictionary_id}/{version_id}/download"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "ervice-accounts"

							if l := len("ervice-accounts"); len(elem) >= l && elem[0:l] == "ervice-accounts" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetWorkspaceServiceAccountsOperation
									r.summary = "Get Workspace Service Accounts"
									r.operationID = "get_workspace_service_accounts"
									r.operationGroup = ""
									r.pathPattern = "/v1/service-accounts"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "service_account_user_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/api-keys"

									if l := len("/api-keys"); len(elem) >= l && elem[0:l] == "/api-keys" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = GetServiceAccountAPIKeysRouteOperation
											r.summary = "Get Service Account Api Keys Route"
											r.operationID = "get_service_account_api_keys_route"
											r.operationGroup = ""
											r.pathPattern = "/v1/service-accounts/{service_account_user_id}/api-keys"
											r.args = args
											r.count = 1
											return r, true
										case "POST":
											r.name = CreateServiceAccountAPIKeyOperation
											r.summary = "Create Service Account Api Key"
											r.operationID = "create_service_account_api_key"
											r.operationGroup = ""
											r.pathPattern = "/v1/service-accounts/{service_account_user_id}/api-keys"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "api_key_id"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[1] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = DeleteServiceAccountAPIKeyOperation
												r.summary = "Delete Service Account Api Key"
												r.operationID = "delete_service_account_api_key"
												r.operationGroup = ""
												r.pathPattern = "/v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}"
												r.args = args
												r.count = 2
												return r, true
											case "PATCH":
												r.name = EditServiceAccountAPIKeyOperation
												r.summary = "Edit Service Account Api Key"
												r.operationID = "edit_service_account_api_key"
												r.operationGroup = ""
												r.pathPattern = "/v1/service-accounts/{service_account_user_id}/api-keys/{api_key_id}"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						case 'h': // Prefix: "hared-voices"

							if l := len("hared-voices"); len(elem) >= l && elem[0:l] == "hared-voices" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetLibraryVoicesOperation
									r.summary = "Get Voices"
									r.operationID = "get_library_voices"
									r.operationGroup = ""
									r.pathPattern = "/v1/shared-voices"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'i': // Prefix: "i"

							if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'm': // Prefix: "milar-voices"

								if l := len("milar-voices"); len(elem) >= l && elem[0:l] == "milar-voices" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = GetSimilarLibraryVoicesOperation
										r.summary = "Get Similar Library Voices"
										r.operationID = "get_similar_library_voices"
										r.operationGroup = ""
										r.pathPattern = "/v1/similar-voices"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'n': // Prefix: "ngle-use-token/"

								if l := len("ngle-use-token/"); len(elem) >= l && elem[0:l] == "ngle-use-token/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "token_type"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = GetSingleUseTokenOperation
										r.summary = "Create Single Use Token"
										r.operationID = "get_single_use_token"
										r.operationGroup = ""
										r.pathPattern = "/v1/single-use-token/{token_type}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 'o': // Prefix: "ound-generation"

							if l := len("ound-generation"); len(elem) >= l && elem[0:l] == "ound-generation" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = SoundGenerationOperation
									r.summary = "Sound Generation"
									r.operationID = "sound_generation"
									r.operationGroup = ""
									r.pathPattern = "/v1/sound-generation"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'p': // Prefix: "peech-to-"

							if l := len("peech-to-"); len(elem) >= l && elem[0:l] == "peech-to-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "speech/"

								if l := len("speech/"); len(elem) >= l && elem[0:l] == "speech/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "voice_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = SpeechToSpeechFullOperation
										r.summary = "Speech To Speech"
										r.operationID = "speech_to_speech_full"
										r.operationGroup = ""
										r.pathPattern = "/v1/speech-to-speech/{voice_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/stream"

									if l := len("/stream"); len(elem) >= l && elem[0:l] == "/stream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = SpeechToSpeechStreamOperation
											r.summary = "Speech To Speech Streaming"
											r.operationID = "speech_to_speech_stream"
											r.operationGroup = ""
											r.pathPattern = "/v1/speech-to-speech/{voice_id}/stream"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							case 't': // Prefix: "text"

								if l := len("text"); len(elem) >= l && elem[0:l] == "text" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = SpeechToTextOperation
										r.summary = "Speech To Text"
										r.operationID = "speech_to_text"
										r.operationGroup = ""
										r.pathPattern = "/v1/speech-to-text"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/transcripts/"

									if l := len("/transcripts/"); len(elem) >= l && elem[0:l] == "/transcripts/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "transcription_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteTranscriptByIDOperation
											r.summary = "Delete Transcript By Id"
											r.operationID = "delete_transcript_by_id"
											r.operationGroup = ""
											r.pathPattern = "/v1/speech-to-text/transcripts/{transcription_id}"
											r.args = args
											r.count = 1
											return r, true
										case "GET":
											r.name = GetTranscriptByIDOperation
											r.summary = "Get Transcript By Id"
											r.operationID = "get_transcript_by_id"
											r.operationGroup = ""
											r.pathPattern = "/v1/speech-to-text/transcripts/{transcription_id}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 't': // Prefix: "tudio/projects"

							if l := len("tudio/projects"); len(elem) >= l && elem[0:l] == "tudio/projects" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetProjectsOperation
									r.summary = "List Studio Projects"
									r.operationID = "get_projects"
									r.operationGroup = ""
									r.pathPattern = "/v1/studio/projects"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = AddProjectOperation
									r.summary = "Create Studio Project"
									r.operationID = "add_project"
									r.operationGroup = ""
									r.pathPattern = "/v1/studio/projects"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "project_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteProjectOperation
										r.summary = "Delete Studio Project"
										r.operationID = "delete_project"
										r.operationGroup = ""
										r.pathPattern = "/v1/studio/projects/{project_id}"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = EditProjectOperation
										r.summary = "Update Studio Project"
										r.operationID = "edit_project"
										r.operationGroup = ""
										r.pathPattern = "/v1/studio/projects/{project_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'c': // Prefix: "c"

										if l := len("c"); len(elem) >= l && elem[0:l] == "c" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'h': // Prefix: "hapters"

											if l := len("hapters"); len(elem) >= l && elem[0:l] == "hapters" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = GetChaptersOperation
													r.summary = "List Chapters"
													r.operationID = "get_chapters"
													r.operationGroup = ""
													r.pathPattern = "/v1/studio/projects/{project_id}/chapters"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												// Param: "chapter_id"
												// Match until "/"
												idx := strings.IndexByte(elem, '/')
												if idx < 0 {
													idx = len(elem)
												}
												args[1] = elem[:idx]
												elem = elem[idx:]

												if len(elem) == 0 {
													switch method {
													case "DELETE":
														r.name = DeleteChapterEndpointOperation
														r.summary = "Delete Chapter"
														r.operationID = "delete_chapter_endpoint"
														r.operationGroup = ""
														r.pathPattern = "/v1/studio/projects/{project_id}/chapters/{chapter_id}"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														break
													}
													switch elem[0] {
													case 'c': // Prefix: "convert"

														if l := len("convert"); len(elem) >= l && elem[0:l] == "convert" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															// Leaf node.
															switch method {
															case "POST":
																r.name = ConvertChapterEndpointOperation
																r.summary = "Convert Chapter"
																r.operationID = "convert_chapter_endpoint"
																r.operationGroup = ""
																r.pathPattern = "/v1/studio/projects/{project_id}/chapters/{chapter_id}/convert"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}

													case 's': // Prefix: "snapshots"

														if l := len("snapshots"); len(elem) >= l && elem[0:l] == "snapshots" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															switch method {
															case "GET":
																r.name = GetChapterSnapshotsOperation
																r.summary = "List Chapter Snapshots"
																r.operationID = "get_chapter_snapshots"
																r.operationGroup = ""
																r.pathPattern = "/v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots"
																r.args = args
																r.count = 2
																return r, true
															default:
																return
															}
														}
														switch elem[0] {
														case '/': // Prefix: "/"

															if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																elem = elem[l:]
															} else {
																break
															}

															// Param: "chapter_snapshot_id"
															// Match until "/"
															idx := strings.IndexByte(elem, '/')
															if idx < 0 {
																idx = len(elem)
															}
															args[2] = elem[:idx]
															elem = elem[idx:]

															if len(elem) == 0 {
																switch method {
																case "GET":
																	r.name = GetChapterSnapshotEndpointOperation
																	r.summary = "Get Chapter Snapshot"
																	r.operationID = "get_chapter_snapshot_endpoint"
																	r.operationGroup = ""
																	r.pathPattern = "/v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}"
																	r.args = args
																	r.count = 3
																	return r, true
																default:
																	return
																}
															}
															switch elem[0] {
															case '/': // Prefix: "/stream"

																if l := len("/stream"); len(elem) >= l && elem[0:l] == "/stream" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "POST":
																		r.name = StreamChapterSnapshotAudioOperation
																		r.summary = "Stream Chapter Audio"
																		r.operationID = "stream_chapter_snapshot_audio"
																		r.operationGroup = ""
																		r.pathPattern = "/v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream"
																		r.args = args
																		r.count = 3
																		return r, true
																	default:
																		return
																	}
																}

															}

														}

													}

												}

											}

										case 'o': // Prefix: "on"

											if l := len("on"); len(elem) >= l && elem[0:l] == "on" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 't': // Prefix: "tent"

												if l := len("tent"); len(elem) >= l && elem[0:l] == "tent" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = EditProjectContentOperation
														r.summary = "Update Studio Project Content"
														r.operationID = "edit_project_content"
														r.operationGroup = ""
														r.pathPattern = "/v1/studio/projects/{project_id}/content"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											case 'v': // Prefix: "vert"

												if l := len("vert"); len(elem) >= l && elem[0:l] == "vert" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = ConvertProjectEndpointOperation
														r.summary = "Convert Studio Project"
														r.operationID = "convert_project_endpoint"
														r.operationGroup = ""
														r.pathPattern = "/v1/studio/projects/{project_id}/convert"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											}

										}

									case 'p': // Prefix: "pronunciation-dictionaries"

										if l := len("pronunciation-dictionaries"); len(elem) >= l && elem[0:l] == "pronunciation-dictionaries" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = UpdatePronunciationDictionariesOperation
												r.summary = "Create Pronunciation Dictionaries"
												r.operationID = "update_pronunciation_dictionaries"
												r.operationGroup = ""
												r.pathPattern = "/v1/studio/projects/{project_id}/pronunciation-dictionaries"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "snapshots"

										if l := len("snapshots"); len(elem) >= l && elem[0:l] == "snapshots" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "GET":
												r.name = GetProjectSnapshotsOperation
												r.summary = "List Studio Project Snapshots"
												r.operationID = "get_project_snapshots"
												r.operationGroup = ""
												r.pathPattern = "/v1/studio/projects/{project_id}/snapshots"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "project_snapshot_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = GetProjectSnapshotEndpointOperation
													r.summary = "Get Project Snapshot"
													r.operationID = "get_project_snapshot_endpoint"
													r.operationGroup = ""
													r.pathPattern = "/v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/"

												if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													break
												}
												switch elem[0] {
												case 'a': // Prefix: "archive"

													if l := len("archive"); len(elem) >= l && elem[0:l] == "archive" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = StreamProjectSnapshotArchiveEndpointOperation
															r.summary = "Stream Archive With Studio Project Audio"
															r.operationID = "stream_project_snapshot_archive_endpoint"
															r.operationGroup = ""
															r.pathPattern = "/v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/archive"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												case 's': // Prefix: "stream"

													if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
														elem = elem[l:]
													} else {
														break
													}

													if len(elem) == 0 {
														// Leaf node.
														switch method {
														case "POST":
															r.name = StreamProjectSnapshotAudioEndpointOperation
															r.summary = "Stream Studio Project Audio"
															r.operationID = "stream_project_snapshot_audio_endpoint"
															r.operationGroup = ""
															r.pathPattern = "/v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/stream"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}

												}

											}

										}

									}

								}

							}

						}

					case 't': // Prefix: "text-to-"

						if l := len("text-to-"); len(elem) >= l && elem[0:l] == "text-to-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "dialogue"

							if l := len("dialogue"); len(elem) >= l && elem[0:l] == "dialogue" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = TextToDialogueOperation
									r.summary = "Text To Dialogue (Multi-Voice)"
									r.operationID = "text_to_dialogue"
									r.operationGroup = ""
									r.pathPattern = "/v1/text-to-dialogue"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "stream"

									if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = TextToDialogueStreamOperation
											r.summary = "Text To Dialogue (Multi-Voice) Streaming"
											r.operationID = "text_to_dialogue_stream"
											r.operationGroup = ""
											r.pathPattern = "/v1/text-to-dialogue/stream"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/with-timestamps"

										if l := len("/with-timestamps"); len(elem) >= l && elem[0:l] == "/with-timestamps" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = TextToDialogueStreamWithTimestampsOperation
												r.summary = "Text To Dialogue Streaming With Timestamps"
												r.operationID = "text_to_dialogue_stream_with_timestamps"
												r.operationGroup = ""
												r.pathPattern = "/v1/text-to-dialogue/stream/with-timestamps"
												r.args = args
												r.count = 0
												return r, true
											default:
												return
											}
										}

									}

								case 'w': // Prefix: "with-timestamps"

									if l := len("with-timestamps"); len(elem) >= l && elem[0:l] == "with-timestamps" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = TextToDialogueFullWithTimestampsOperation
											r.summary = "Text To Dialogue With Timestamps"
											r.operationID = "text_to_dialogue_full_with_timestamps"
											r.operationGroup = ""
											r.pathPattern = "/v1/text-to-dialogue/with-timestamps"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 's': // Prefix: "speech/"

							if l := len("speech/"); len(elem) >= l && elem[0:l] == "speech/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "voice_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = TextToSpeechFullOperation
									r.summary = "Text To Speech"
									r.operationID = "text_to_speech_full"
									r.operationGroup = ""
									r.pathPattern = "/v1/text-to-speech/{voice_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "stream"

									if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = TextToSpeechStreamOperation
											r.summary = "Text To Speech Streaming"
											r.operationID = "text_to_speech_stream"
											r.operationGroup = ""
											r.pathPattern = "/v1/text-to-speech/{voice_id}/stream"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/with-timestamps"

										if l := len("/with-timestamps"); len(elem) >= l && elem[0:l] == "/with-timestamps" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = TextToSpeechStreamWithTimestampsOperation
												r.summary = "Text To Speech Streaming With Timestamps"
												r.operationID = "text_to_speech_stream_with_timestamps"
												r.operationGroup = ""
												r.pathPattern = "/v1/text-to-speech/{voice_id}/stream/with-timestamps"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								case 'w': // Prefix: "with-timestamps"

									if l := len("with-timestamps"); len(elem) >= l && elem[0:l] == "with-timestamps" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = TextToSpeechFullWithTimestampsOperation
											r.summary = "Text To Speech With Timestamps"
											r.operationID = "text_to_speech_full_with_timestamps"
											r.operationGroup = ""
											r.pathPattern = "/v1/text-to-speech/{voice_id}/with-timestamps"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'v': // Prefix: "voice"

							if l := len("voice"); len(elem) >= l && elem[0:l] == "voice" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = CreateVoiceOperation
									r.summary = "Create A New Voice From Voice Preview"
									r.operationID = "create_voice"
									r.operationGroup = ""
									r.pathPattern = "/v1/text-to-voice"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "create-previews"
									origElem := elem
									if l := len("create-previews"); len(elem) >= l && elem[0:l] == "create-previews" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = TextToVoiceOperation
											r.summary = "Generate A Voice Preview From Description"
											r.operationID = "text_to_voice"
											r.operationGroup = ""
											r.pathPattern = "/v1/text-to-voice/create-previews"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								case 'd': // Prefix: "design"
									origElem := elem
									if l := len("design"); len(elem) >= l && elem[0:l] == "design" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = TextToVoiceDesignOperation
											r.summary = "Design A Voice."
											r.operationID = "text_to_voice_design"
											r.operationGroup = ""
											r.pathPattern = "/v1/text-to-voice/design"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "generated_voice_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'r': // Prefix: "remix"

										if l := len("remix"); len(elem) >= l && elem[0:l] == "remix" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = TextToVoiceRemixOperation
												r.summary = "Remix A Voice."
												r.operationID = "text_to_voice_remix"
												r.operationGroup = ""
												r.pathPattern = "/v1/text-to-voice/{voice_id}/remix"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "stream"

										if l := len("stream"); len(elem) >= l && elem[0:l] == "stream" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = TextToVoicePreviewStreamOperation
												r.summary = "Text To Voice Preview Streaming"
												r.operationID = "text_to_voice_preview_stream"
												r.operationGroup = ""
												r.pathPattern = "/v1/text-to-voice/{generated_voice_id}/stream"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'u': // Prefix: "us"

						if l := len("us"); len(elem) >= l && elem[0:l] == "us" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "age/character-stats"

							if l := len("age/character-stats"); len(elem) >= l && elem[0:l] == "age/character-stats" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = UsageCharactersOperation
									r.summary = "Get Characters Usage Metrics"
									r.operationID = "usage_characters"
									r.operationGroup = ""
									r.pathPattern = "/v1/usage/character-stats"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'e': // Prefix: "er"

							if l := len("er"); len(elem) >= l && elem[0:l] == "er" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetUserInfoOperation
									r.summary = "Get User Info"
									r.operationID = "get_user_info"
									r.operationGroup = ""
									r.pathPattern = "/v1/user"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					case 'v': // Prefix: "voice"

						if l := len("voice"); len(elem) >= l && elem[0:l] == "voice" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-generation/"

							if l := len("-generation/"); len(elem) >= l && elem[0:l] == "-generation/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "create-voice"

								if l := len("create-voice"); len(elem) >= l && elem[0:l] == "create-voice" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = CreateVoiceOldOperation
										r.summary = "Create A Previously Generated Voice"
										r.operationID = "create_voice_old"
										r.operationGroup = ""
										r.pathPattern = "/v1/voice-generation/create-voice"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							case 'g': // Prefix: "generate-voice"

								if l := len("generate-voice"); len(elem) >= l && elem[0:l] == "generate-voice" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = GenerateRandomVoiceOperation
										r.summary = "Generate A Random Voice"
										r.operationID = "generate_random_voice"
										r.operationGroup = ""
										r.pathPattern = "/v1/voice-generation/generate-voice"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/parameters"

									if l := len("/parameters"); len(elem) >= l && elem[0:l] == "/parameters" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetGenerateVoiceParametersOperation
											r.summary = "Voice Generation Parameters"
											r.operationID = "get_generate_voice_parameters"
											r.operationGroup = ""
											r.pathPattern = "/v1/voice-generation/generate-voice/parameters"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetVoicesOperation
									r.summary = "List Voices"
									r.operationID = "get_voices"
									r.operationGroup = ""
									r.pathPattern = "/v1/voices"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "add"
									origElem := elem
									if l := len("add"); len(elem) >= l && elem[0:l] == "add" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = AddVoiceOperation
											r.summary = "Add Voice"
											r.operationID = "add_voice"
											r.operationGroup = ""
											r.pathPattern = "/v1/voices/add"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "public_user_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "voice_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = AddSharingVoiceOperation
													r.summary = "Add Shared Voice"
													r.operationID = "add_sharing_voice"
													r.operationGroup = ""
													r.pathPattern = "/v1/voices/add/{public_user_id}/{voice_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										}

									}

									elem = origElem
								case 'p': // Prefix: "pvc"
									origElem := elem
									if l := len("pvc"); len(elem) >= l && elem[0:l] == "pvc" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											r.name = CreatePvcVoiceOperation
											r.summary = "Create Pvc Voice"
											r.operationID = "create_pvc_voice"
											r.operationGroup = ""
											r.pathPattern = "/v1/voices/pvc"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "voice_id"
										// Match until "/"
										idx := strings.IndexByte(elem, '/')
										if idx < 0 {
											idx = len(elem)
										}
										args[0] = elem[:idx]
										elem = elem[idx:]

										if len(elem) == 0 {
											switch method {
											case "POST":
												r.name = EditPvcVoiceOperation
												r.summary = "Edit Pvc Voice"
												r.operationID = "edit_pvc_voice"
												r.operationGroup = ""
												r.pathPattern = "/v1/voices/pvc/{voice_id}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
										switch elem[0] {
										case '/': // Prefix: "/"

											if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												break
											}
											switch elem[0] {
											case 'c': // Prefix: "captcha"

												if l := len("captcha"); len(elem) >= l && elem[0:l] == "captcha" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = GetPvcVoiceCaptchaOperation
														r.summary = "Get Pvc Voice Captcha"
														r.operationID = "get_pvc_voice_captcha"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/pvc/{voice_id}/captcha"
														r.args = args
														r.count = 1
														return r, true
													case "POST":
														r.name = VerifyPvcVoiceCaptchaOperation
														r.summary = "Verify Pvc Voice Captcha"
														r.operationID = "verify_pvc_voice_captcha"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/pvc/{voice_id}/captcha"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											case 's': // Prefix: "samples"

												if l := len("samples"); len(elem) >= l && elem[0:l] == "samples" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													switch method {
													case "POST":
														r.name = AddPvcVoiceSamplesOperation
														r.summary = "Add Samples To Pvc Voice"
														r.operationID = "add_pvc_voice_samples"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/pvc/{voice_id}/samples"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}
												switch elem[0] {
												case '/': // Prefix: "/"

													if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
														elem = elem[l:]
													} else {
														break
													}

													// Param: "sample_id"
													// Match until "/"
													idx := strings.IndexByte(elem, '/')
													if idx < 0 {
														idx = len(elem)
													}
													args[1] = elem[:idx]
													elem = elem[idx:]

													if len(elem) == 0 {
														switch method {
														case "DELETE":
															r.name = DeletePvcVoiceSampleOperation
															r.summary = "Delete Pvc Voice Sample"
															r.operationID = "delete_pvc_voice_sample"
															r.operationGroup = ""
															r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}"
															r.args = args
															r.count = 2
															return r, true
														case "POST":
															r.name = EditPvcVoiceSampleOperation
															r.summary = "Update Pvc Voice Sample"
															r.operationID = "edit_pvc_voice_sample"
															r.operationGroup = ""
															r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}"
															r.args = args
															r.count = 2
															return r, true
														default:
															return
														}
													}
													switch elem[0] {
													case '/': // Prefix: "/"

														if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
															elem = elem[l:]
														} else {
															break
														}

														if len(elem) == 0 {
															break
														}
														switch elem[0] {
														case 'a': // Prefix: "audio"

															if l := len("audio"); len(elem) >= l && elem[0:l] == "audio" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "GET":
																	r.name = GetPvcSampleAudioOperation
																	r.summary = "Retrieve Voice Sample Audio"
																	r.operationID = "get_pvc_sample_audio"
																	r.operationGroup = ""
																	r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}/audio"
																	r.args = args
																	r.count = 2
																	return r, true
																default:
																	return
																}
															}

														case 's': // Prefix: "s"

															if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																break
															}
															switch elem[0] {
															case 'e': // Prefix: "eparate-speakers"

																if l := len("eparate-speakers"); len(elem) >= l && elem[0:l] == "eparate-speakers" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	// Leaf node.
																	switch method {
																	case "POST":
																		r.name = StartSpeakerSeparationOperation
																		r.summary = "Start Speaker Separation"
																		r.operationID = "start_speaker_separation"
																		r.operationGroup = ""
																		r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}/separate-speakers"
																		r.args = args
																		r.count = 2
																		return r, true
																	default:
																		return
																	}
																}

															case 'p': // Prefix: "peakers"

																if l := len("peakers"); len(elem) >= l && elem[0:l] == "peakers" {
																	elem = elem[l:]
																} else {
																	break
																}

																if len(elem) == 0 {
																	switch method {
																	case "GET":
																		r.name = GetPvcSampleSpeakersOperation
																		r.summary = "Retrieve Speaker Separation Status"
																		r.operationID = "get_pvc_sample_speakers"
																		r.operationGroup = ""
																		r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers"
																		r.args = args
																		r.count = 2
																		return r, true
																	default:
																		return
																	}
																}
																switch elem[0] {
																case '/': // Prefix: "/"

																	if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
																		elem = elem[l:]
																	} else {
																		break
																	}

																	// Param: "speaker_id"
																	// Match until "/"
																	idx := strings.IndexByte(elem, '/')
																	if idx < 0 {
																		idx = len(elem)
																	}
																	args[2] = elem[:idx]
																	elem = elem[idx:]

																	if len(elem) == 0 {
																		break
																	}
																	switch elem[0] {
																	case '/': // Prefix: "/audio"

																		if l := len("/audio"); len(elem) >= l && elem[0:l] == "/audio" {
																			elem = elem[l:]
																		} else {
																			break
																		}

																		if len(elem) == 0 {
																			// Leaf node.
																			switch method {
																			case "GET":
																				r.name = GetSpeakerAudioOperation
																				r.summary = "Retrieve Separated Speaker Audio"
																				r.operationID = "get_speaker_audio"
																				r.operationGroup = ""
																				r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}/speakers/{speaker_id}/audio"
																				r.args = args
																				r.count = 3
																				return r, true
																			default:
																				return
																			}
																		}

																	}

																}

															}

														case 'w': // Prefix: "waveform"

															if l := len("waveform"); len(elem) >= l && elem[0:l] == "waveform" {
																elem = elem[l:]
															} else {
																break
															}

															if len(elem) == 0 {
																// Leaf node.
																switch method {
																case "GET":
																	r.name = GetPvcSampleVisualWaveformOperation
																	r.summary = "Retrieve Voice Sample Visual Waveform"
																	r.operationID = "get_pvc_sample_visual_waveform"
																	r.operationGroup = ""
																	r.pathPattern = "/v1/voices/pvc/{voice_id}/samples/{sample_id}/waveform"
																	r.args = args
																	r.count = 2
																	return r, true
																default:
																	return
																}
															}

														}

													}

												}

											case 't': // Prefix: "train"

												if l := len("train"); len(elem) >= l && elem[0:l] == "train" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = RunPvcVoiceTrainingOperation
														r.summary = "Run Pvc Training"
														r.operationID = "run_pvc_voice_training"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/pvc/{voice_id}/train"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											case 'v': // Prefix: "verification"

												if l := len("verification"); len(elem) >= l && elem[0:l] == "verification" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = RequestPvcManualVerificationOperation
														r.summary = "Request Manual Verification"
														r.operationID = "request_pvc_manual_verification"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/pvc/{voice_id}/verification"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											}

										}

									}

									elem = origElem
								case 's': // Prefix: "settings/default"
									origElem := elem
									if l := len("settings/default"); len(elem) >= l && elem[0:l] == "settings/default" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "GET":
											r.name = GetVoiceSettingsDefaultOperation
											r.summary = "Get Default Voice Settings."
											r.operationID = "get_voice_settings_default"
											r.operationGroup = ""
											r.pathPattern = "/v1/voices/settings/default"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

									elem = origElem
								}
								// Param: "voice_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteVoiceOperation
										r.summary = "Delete Voice"
										r.operationID = "delete_voice"
										r.operationGroup = ""
										r.pathPattern = "/v1/voices/{voice_id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetVoiceByIDOperation
										r.summary = "Get Voice"
										r.operationID = "get_voice_by_id"
										r.operationGroup = ""
										r.pathPattern = "/v1/voices/{voice_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "edit"

										if l := len("edit"); len(elem) >= l && elem[0:l] == "edit" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = EditVoiceOperation
												r.summary = "Edit Voice"
												r.operationID = "edit_voice"
												r.operationGroup = ""
												r.pathPattern = "/v1/voices/{voice_id}/edit"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 's': // Prefix: "s"

										if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "amples/"

											if l := len("amples/"); len(elem) >= l && elem[0:l] == "amples/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "sample_id"
											// Match until "/"
											idx := strings.IndexByte(elem, '/')
											if idx < 0 {
												idx = len(elem)
											}
											args[1] = elem[:idx]
											elem = elem[idx:]

											if len(elem) == 0 {
												switch method {
												case "DELETE":
													r.name = DeleteSampleOperation
													r.summary = "Delete Sample"
													r.operationID = "delete_sample"
													r.operationGroup = ""
													r.pathPattern = "/v1/voices/{voice_id}/samples/{sample_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/audio"

												if l := len("/audio"); len(elem) >= l && elem[0:l] == "/audio" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "GET":
														r.name = GetAudioFromSampleOperation
														r.summary = "Get Audio From Sample"
														r.operationID = "get_audio_from_sample"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/{voice_id}/samples/{sample_id}/audio"
														r.args = args
														r.count = 2
														return r, true
													default:
														return
													}
												}

											}

										case 'e': // Prefix: "ettings"

											if l := len("ettings"); len(elem) >= l && elem[0:l] == "ettings" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "GET":
													r.name = GetVoiceSettingsOperation
													r.summary = "Get Voice Settings"
													r.operationID = "get_voice_settings"
													r.operationGroup = ""
													r.pathPattern = "/v1/voices/{voice_id}/settings"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}
											switch elem[0] {
											case '/': // Prefix: "/edit"

												if l := len("/edit"); len(elem) >= l && elem[0:l] == "/edit" {
													elem = elem[l:]
												} else {
													break
												}

												if len(elem) == 0 {
													// Leaf node.
													switch method {
													case "POST":
														r.name = EditVoiceSettingsOperation
														r.summary = "Edit Voice Settings"
														r.operationID = "edit_voice_settings"
														r.operationGroup = ""
														r.pathPattern = "/v1/voices/{voice_id}/settings/edit"
														r.args = args
														r.count = 1
														return r, true
													default:
														return
													}
												}

											}

										}

									}

								}

							}

						}

					case 'w': // Prefix: "workspace/"

						if l := len("workspace/"); len(elem) >= l && elem[0:l] == "workspace/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'g': // Prefix: "groups/"

							if l := len("groups/"); len(elem) >= l && elem[0:l] == "groups/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "search"
								origElem := elem
								if l := len("search"); len(elem) >= l && elem[0:l] == "search" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = SearchGroupsOperation
										r.summary = "Search User Groups"
										r.operationID = "search_groups"
										r.operationGroup = ""
										r.pathPattern = "/v1/workspace/groups/search"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "group_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/members"

								if l := len("/members"); len(elem) >= l && elem[0:l] == "/members" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = AddMemberOperation
										r.summary = "Add Member To User Group"
										r.operationID = "add_member"
										r.operationGroup = ""
										r.pathPattern = "/v1/workspace/groups/{group_id}/members"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/remove"

									if l := len("/remove"); len(elem) >= l && elem[0:l] == "/remove" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = RemoveMemberOperation
											r.summary = "Delete Member From User Group"
											r.operationID = "remove_member"
											r.operationGroup = ""
											r.pathPattern = "/v1/workspace/groups/{group_id}/members/remove"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'i': // Prefix: "invites"

							if l := len("invites"); len(elem) >= l && elem[0:l] == "invites" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteInviteOperation
									r.summary = "Delete Existing Invitation"
									r.operationID = "delete_invite"
									r.operationGroup = ""
									r.pathPattern = "/v1/workspace/invites"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/add"

								if l := len("/add"); len(elem) >= l && elem[0:l] == "/add" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = InviteUserOperation
										r.summary = "Invite User"
										r.operationID = "invite_user"
										r.operationGroup = ""
										r.pathPattern = "/v1/workspace/invites/add"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '-': // Prefix: "-bulk"

									if l := len("-bulk"); len(elem) >= l && elem[0:l] == "-bulk" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = InviteUsersBulkOperation
											r.summary = "Invite Multiple Users"
											r.operationID = "invite_users_bulk"
											r.operationGroup = ""
											r.pathPattern = "/v1/workspace/invites/add-bulk"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'm': // Prefix: "members"

							if l := len("members"); len(elem) >= l && elem[0:l] == "members" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = UpdateWorkspaceMemberOperation
									r.summary = "Update Member"
									r.operationID = "update_workspace_member"
									r.operationGroup = ""
									r.pathPattern = "/v1/workspace/members"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						case 'r': // Prefix: "resources/"

							if l := len("resources/"); len(elem) >= l && elem[0:l] == "resources/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "resource_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetResourceMetadataOperation
									r.summary = "Get Resource"
									r.operationID = "get_resource_metadata"
									r.operationGroup = ""
									r.pathPattern = "/v1/workspace/resources/{resource_id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 's': // Prefix: "share"

									if l := len("share"); len(elem) >= l && elem[0:l] == "share" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = ShareResourceEndpointOperation
											r.summary = "Share Workspace Resource"
											r.operationID = "share_resource_endpoint"
											r.operationGroup = ""
											r.pathPattern = "/v1/workspace/resources/{resource_id}/share"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								case 'u': // Prefix: "unshare"

									if l := len("unshare"); len(elem) >= l && elem[0:l] == "unshare" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "POST":
											r.name = UnshareResourceEndpointOperation
											r.summary = "Unshare Workspace Resource"
											r.operationID = "unshare_resource_endpoint"
											r.operationGroup = ""
											r.pathPattern = "/v1/workspace/resources/{resource_id}/unshare"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}

								}

							}

						case 'w': // Prefix: "webhooks"

							if l := len("webhooks"); len(elem) >= l && elem[0:l] == "webhooks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetWorkspaceWebhooksRouteOperation
									r.summary = "List Workspace Webhooks"
									r.operationID = "get_workspace_webhooks_route"
									r.operationGroup = ""
									r.pathPattern = "/v1/workspace/webhooks"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateWorkspaceWebhookRouteOperation
									r.summary = "Create Workspace Webhook"
									r.operationID = "create_workspace_webhook_route"
									r.operationGroup = ""
									r.pathPattern = "/v1/workspace/webhooks"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "webhook_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteWorkspaceWebhookRouteOperation
										r.summary = "Delete Workspace Webhook"
										r.operationID = "delete_workspace_webhook_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/workspace/webhooks/{webhook_id}"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = EditWorkspaceWebhookRouteOperation
										r.summary = "Update Workspace Webhook"
										r.operationID = "edit_workspace_webhook_route"
										r.operationGroup = ""
										r.pathPattern = "/v1/workspace/webhooks/{webhook_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					}

				case '2': // Prefix: "2/voices"

					if l := len("2/voices"); len(elem) >= l && elem[0:l] == "2/voices" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetUserVoicesV2Operation
							r.summary = "Get Voices V2"
							r.operationID = "get_user_voices_v2"
							r.operationGroup = ""
							r.pathPattern = "/v2/voices"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				}

			}

		}
	}
	return r, false
}
